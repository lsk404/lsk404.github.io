<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022绵阳站E</title>
    <url>/4b96d5c23f0d/</url>
    <content><![CDATA[2022 CCPC 绵阳站 E题 （图上DP，根号分治）题意有一个由n城市组成的国家，城市之间由一条权值为w的边连接，共m条这样的边，并且保证整个国家是连通的。每个城市中有a_i 个居民。
在接下来的q天，每天都会有一个城市遭受灾难b_1,b_2,...,b_q，你必须将该城市的所有人都转移到其它城市才能避免居民受到灾难，转移一个居民到相邻城市的代价为两个城市之间路径的权值w。
请问你最少需要多少代价才能让所有居民都安全度过q天的灾难。
思路我们不必管每个城市中有多少个人，我们只需要求出每个城市中转移一个人的最小代价，在最终计算总代价时再乘上人数即可。很容易想到一个暴力的DP解法如下：
令f(i,j) 表示在第j号点，第i天后所有的操作中最小的代价。那么有f(i,j) = MIN_{(v,w) \in edge_{b_i}}\{w+f(i+1,v)\} 。
 我们发现每天只会更新一个dp值，于是我们可以直接省去f的第一维，然后倒序枚举天数 i 从q到1 。 总的时间复杂度为O(\sum_{i=1}^q deg(b_i) ,我们发现当b_i 的度较大时，复杂度会退化到O(qn) 这是不被允许的。
于是考虑根号分治，设分治边界为SQ ,那么当deg(b_i) \le SQ 时，枚举他的所有边来更新dp， 如果deg(b_i) > SQ 那么我们为这个节点建立一个multiset ，存储所有邻边的dp[v]+w 的值，则multiset的第一项即为当前最小的dp值。每当一个节点的dp值更新时，将与他相邻的deg(v) > SQ的点更新。
当SQ = \sqrt{2 \times m \times logn}  时，复杂度为O(q\sqrt{m \times logn})
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int a[100005];vector&lt;PII&gt; edge[100005];vector&lt;PII&gt; edgeB[100005];int deg[100005];int que[100005];int dp[100005];multiset&lt;int&gt; mulst[100005];const int mod = 998244353;void solve()&#123;    int n,m,q;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    int SQ = sqrt(2LL * m * log2(n));    for(int i = 1;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];    &#125;    for(int i = 1;i&lt;=m;i++)&#123;        int u,v,w;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;        edge[u].push_back(&#123;v,w&#125;);        edge[v].push_back(&#123;u,w&#125;);        deg[v]++;deg[u]++;    &#125;    for(int u = 1;u&lt;=n;u++)&#123;        if(deg[u] &gt; SQ)&#123;            for(auto [v,w] : edge[u])&#123;                if(deg[v] &gt; SQ)&#123;                    edgeB[u].push_back(&#123;v,w&#125;);                &#125;                mulst[u].insert(w);            &#125;        &#125;    &#125;    for(int i = 1;i&lt;=q;i++)&#123;        cin&gt;&gt;que[i];    &#125;    for(int i = q;i&gt;=1;i--)&#123;        int u = que[i];        if(deg[u] &lt;= SQ)&#123;            int cost = INF;            for(auto [v,w] : edge[u])&#123;                cost = min(cost,dp[v]+w);            &#125;            for(auto [v,w] : edge[u])&#123;                if(deg[v] &gt; SQ)&#123;                    mulst[v].erase(mulst[v].find(w+dp[u]));                    mulst[v].insert(w+cost);                &#125;            &#125;            dp[u] = cost;        &#125;else&#123;            int cost = *mulst[u].begin();            for(auto [v,w] : edgeB[u])&#123;                if(deg[v] &gt; SQ)&#123;                    mulst[v].erase(mulst[v].find(w+dp[u]));                    mulst[v].insert(w+cost);                     &#125;            &#125;            dp[u] = cost;        &#125;    &#125;    int ans = 0;    for(int i = 1;i&lt;=n;i++)&#123;        ans = (ans + dp[i] * a[i]) %mod;     &#125;    cout&lt;&lt;ans;&#125;signed main()&#123;    int T = 1;    // cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>分治</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>2023ICPC网络赛第一场</title>
    <url>/3b4839b3d1b7/</url>
    <content><![CDATA[[The 2023 ICPC Asia Regionals Online Contest (1)](https://pintia.cn/market/item/1703381331863785472)，不要选时光机，用签到送的金币就可以练习
G Spanning Tree题意起初树只有n个节点，没有边，按照如下操作进行n-1次，对于第i次操作，选择a_i,b_i ,从a_i 所在的块中**随机**选出一个节点u_i，从b_i 所在的块中**随机**选出一个节点v_i， 连接u_i,v_i保证最终会形成一个树，求构造出的这个树和给出的标准的树T能够完全相同的期望（对 998244353取模）
保证第i次操作前,a_i,b_i 不在同一个块。
定义一个节点v所在的块即v能到达的所有节点的集合（包括v本身）
请注意，所求的期望可能是0。
思路可以得出，最终期望一定是0或者 undefinedfrac{1}{s}： 每次连接两个块时，最多只有一种连接方式能够使得所连边的情况和最终的树匹配。而本次操作会使得操作前的期望s_{i-1}再乘上\frac{1}{sz_a*sz_b}(sz_a,sz_b表示a和b当前所在块的节点数量)。  因此最终的期望的分子一定是1。（由于期望是一个分数，所以最总答案为分母s在MOD的模域下的逆元inv(s)undefined
本体涉及到区块的合并，于是很容易想到并查集，利用并查集便能轻松求出期望。但本体的难点不在于算出期望，而是判断何时应该输出0。
下面思考何时期望为0。
显而易见，每次操作时，a所在的块和b所在的块都是最终树T树上的某个子树的一部分。因此这两个块都会有自己的“根”，而如果我们要合并这两个子树， 就一定是**将一个子树的根作为另一个子树的某个节点的儿子**。假设我们要将a所在子树的根 find(a)  拼接在b块的某个节点上，那么find(a)的父节点就一定和b在同一个块。我们可以通过find(x) == find(y) 来判断某两个节点是否是在同一个块上，使用father[x]来表示x节点在T树上对应的父节点。因此能够找到一条正确的边就等价于 find(father[find(a)]) == find(b) || find(father[find(b)]) == find(a)，如果该条件不成立，那么就代表无法构建合适的边，就应该打印0并退出程序。
代码#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e6+5;int pre[N];//并查集中的父节点int father[N];// 最终树中某个节点的父节点typedef long long LL;const int MOD = 998244353;pair&lt;int,int&gt; ope[N];//n-1次操作vector&lt;int&gt; vec[N];//存储边的关系int sz[N];//在每次合并时，sz[i]表示目前以i为根的块的数量sint find(int x)&#123;//并查集的找根操作    if(pre[x] == x) return x;    else return pre[x] = find(pre[x]);&#125;void join(int x,int y)&#123;//并查集的合并操作    int fx = find(x),fy = find(y);    if(fx != fy)&#123;        sz[fy] = sz[fx] + sz[fy];        pre[fx] = fy;    &#125;    return;&#125;LL qp(LL a , LL b)&#123;//quick pow 快速幂    LL ans = 1ll;    while(b)&#123;        if(b &amp; 1)&#123;            ans = ans * a % MOD;        &#125;        a = a * a % MOD;        b &gt;&gt;=1;    &#125;    return ans;&#125;LL inv(LL x)&#123;//求逆元    return qp(x,MOD-2);&#125;//dfs来判断T树中的父亲关系bool isgone[N];void dfs(int x)&#123;    for(int p : vec[x])&#123;        if(!isgone[p]) &#123;            isgone[p] = true;            father[p] = x;            dfs(p);        &#125;    &#125;    return;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i = 1;i&lt;=n;i++) pre[i] = i;    for(int i = 1;i&lt;=n;i++) sz[i] = 1;    int l , r;    for(int i = 1;i&lt;n;i++)&#123;        scanf(&quot;%d %d&quot;,&amp;l,&amp;r);        ope[i] = &#123;l,r&#125;;    &#125;    int u , v;    for(int i = 1;i&lt;n;i++)&#123;        scanf(&quot;%d %d&quot;,&amp;u,&amp;v);        vec[u].push_back(v);        vec[v].push_back(u);    &#125;    isgone[1] = true;    dfs(1);//令T变为以1为根节点的树    long long sum = 1ll;    for(int i = 1;i&lt;n;i++)&#123;        int a = ope[i].first;        int b = ope[i].second;        if(find(father[find(a)]) == find(b))&#123;            sum = sum *sz[find(a)] % MOD * sz[find(b)] % MOD;            join(a,b);        &#125;else if(find(father[find(b)]) == find(a))&#123;            sum = sum *sz[find(a)] % MOD * sz[find(b)] % MOD;            join(b,a);        &#125;else&#123;            // cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;            cout&lt;&lt;0;            return 0;         &#125;    &#125;    // cout&lt;&lt;sum&lt;&lt;endl;    cout&lt;&lt;inv(sum);    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2023ICPC网络赛第二场</title>
    <url>/026c0040b952/</url>
    <content><![CDATA[[The 2023 ICPC Asia Regionals Online Contest (2) (pintia.cn)](https://pintia.cn/market/item/1705511462254264320)
**K Super-knight**题意有一个士兵，起初在n*n的棋盘的左下角，每次向右移动a格，向上移动b格，当越过地图边界时，则到地图的另一边（类似于没有边界墙的贪吃蛇），对这个士兵能到达的格子做标记，所有被标记的格子中，离左下角格子最近的距离是多少。（假设最近的格子为undefinedx, y)，就输出(x - 1)^2+(y - 1)^2$ )
（ 2 \le n \le 10^{18}, 1 \le a,b \le 200)
思路可以得出，在经过n次移动后，一定回回到起始点，所以最终的路径一定是循环的。
但n太大，无法通过这样判断所有的被标记的点。
可以发现，在移动了若干次后，除非穿过地图边界，否则只会增加 与原点的距离。因此我们只需要考虑**刚穿过地图边界的点** 即可。这样可以省下很多时间：（每次直接刚好跨出地图边界，设从undefinednowx,nowy)点开始跨，那么一大步就跨了大约min(\frac{n}{a},\frac{n}{b})$步，而一共进行n小步就可以回到初始点完成一次循环，因此总共需要的大跨步的次数仅仅是 a ，b的数量级，于是我们就可以在规定的时间内完成计算）
代码#include&lt;iostream&gt;using namespace std;#define int long long int a,b,n;inline int dis(int x,int y)&#123;	return (x * x  + y * y ); &#125;int cnt = 0;signed main()&#123;	int t;	cin&gt;&gt;t;	while(t--)&#123;		cin&gt;&gt;a&gt;&gt;b&gt;&gt;n;		a = a % n;		b = b % n;		int nowa = a % n;		int nowb = b % n;		int minn = a * a + b * b;		while(nowa !=0 || nowb != 0)&#123;			cnt ++;			if(nowa &lt;=300 &amp;&amp; nowb &lt;=300) 				minn = min(minn,dis(nowa,nowb));			int k = min((n - nowa - 1) / a,(n - nowb - 1) / b) + 1;			nowa = (nowa + a * k % n) % n;			nowb = (nowb + b * k % n) % n;					&#125;		cout&lt;&lt;&quot;**&quot;&lt;&lt;cnt&lt;&lt;endl;		cout&lt;&lt;minn&lt;&lt;endl;	&#125;	return 0;&#125;
L]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年10月ZZUACM实验室招新赛题解</title>
    <url>/c6413222be25/</url>
    <content><![CDATA[注意事项请注意！：

题解仅代表个人看法，不代表最优解

每道题都会附上ac代码，但是仅作参考，要看懂后再了解代码。补题不要直接抄代码！禁止自欺欺人！

只提供题解，不提供题目信息
ac代码为C++版本，如果遇到不懂的语法请自行百度
ac代码中的循环经常用到了for(int i = 1;i&lt;=n;i++) ，这种在for的括号中int i的操作只有大于等于C++11标准才可以使用，编译错误时请检查自己编译使用的标准。

A.数位分解对于一个数x， 

使用  x % 10 (% 是取余数) ，就可以得到他的最后一位
使用 x /= 10  (除以十并取整数)，就可以舍掉他的最后一位

使用while(x) 来进行循环
#include&lt;iostream&gt;using namespace std;int main()&#123;	int x;	cin&gt;&gt;x;	while(x)&#123;		cout&lt;&lt; x % 10 &lt;&lt;&quot; &quot;;		x = x / 10;	&#125;	return 0;&#125;
B.**大小写字母互换**对于一个小写字符ch, 使用代码ch = ch - (&#39;a&#39; - &#39;A&#39;);能够使他转换为大写字母， 相反对于大写字母，则需要使用代码ch = ch + (&#39;a&#39; - &#39;A&#39;);
本题读入的数据中存在空格，因此需要使用 gets()函数来读入。
使用string.h 库文件中的 strlen() 函数来获取字符串的长度
#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123;	char str[85];	gets(str);	for(int i = 0 ;i&lt; strlen(str);i++)&#123;		if(&#x27;a&#x27;&lt;=str[i] &amp;&amp; str[i]&lt;=&#x27;z&#x27;) 			str[i] -= (&#x27;a&#x27;-&#x27;A&#x27;);		else if(&#x27;A&#x27;&lt;=str[i] &amp;&amp; str[i]&lt;=&#x27;Z&#x27;) 			str[i] += (&#x27;a&#x27;-&#x27;A&#x27;);	&#125;	cout&lt;&lt;str;	return 0;&#125;
C.八进制转十进制给出的数据规模很小，直接根据进制公式计算即可。
下面通过一个例子来介绍计算公式
13579_{(8)} = 1 * 8^4 + 3*8^3 + 5*8^2 + 7*8^1 + 9*8^0
可以发现式子是可以用循环表示的
#include&lt;iostream&gt;using namespace std;int main()&#123;	int x;	cin&gt;&gt;x;	int p = 1;//p = 8 ^ i	int ans = 0;	for(int i = 0;x &gt; 0;i++)&#123;		ans += (x % 10) * p;//x % 10 数位分离		p = p * 8;//令p一直保持为 8 ^ i		x = x / 10;//数位分离的操作	&#125;	cout&lt;&lt;ans;	return 0;&#125;
**D. 西西务者**使用数组存下所有的数据，然后排序后选择其中的中间部分计算平均值即可，数据的总和会超过int的范围，注意使用**longlong**来存储中间区域的裁判的分数和。
数组占用的空间大，建议放在全局区。（也就是main函数的上面）
输入数据多，建议使用scanf读入数据（最好不要用cin，否则可能会读入超时）
#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 1e6;int dat[MAXN*5 + 5];int main()&#123;	int n;	cin&gt;&gt;n;	for(int i =1;i&lt;=n * 5;i++)&#123;		scanf(&quot;%d&quot;,&amp;dat[i]);	&#125;	sort(dat+1,dat+n*5+1);//C++中的排序函数，需要包含algorithm库	long long sum = 0;//一定要初始化	for(int i = n + 1;i&lt;=n * 4;i++)&#123;		sum += dat[i];	&#125;	printf(&quot;%.1lf&quot;,(double)sum / (n * 3)); //转换为double再计算才会有小数,%.1lf为保留一位小数输出double类型数据	return 0;&#125;
E.睡大觉本题使用的算法知识： 1.前缀和 2.二分查找 。 如果没有学过上述内容，建议前往([OI Wiki ](https://oi-wiki.org/))，或者[CSDN ](https://www.csdn.net/)等平台先行了解。
设每次开始睡觉（或结束睡觉）为一个时间点，使用前缀和数组qz记录从刚开始到某个时间点一共睡了多长时间，因此有以下方程：
qz[i] = qz[i-1](i为偶数)
qz[i] = qz[i-1] + a[i] - a[i-1] (i为奇数)
请根据题意“第i个数为奇数表示睡醒，为偶数表示睡着”认真理解上述公式。
数据处理完毕后，对于每组询问 l , r。 我们可以先计算出从刚开始到 l 一共睡了多长时间（设为timeL），以及从刚开始到r 一共用了多长时间（设为timeR） ，而从l到r的睡眠时间即为timeR - timeL。
下面探讨如何找到从刚开始到时间x 的总睡眠时间：使用int ind = lower_bound(a+1,a+1+n,x) - a - 1; 来找到从x往左数的第一个时间点的下标ind。（low\_bound()能够从a数组中二分找到第一个大于x的索引，减去首地址a即为下标，再减去a变为第一个小于x的下标）

如果ind为奇数，那么代表[ind,x] 这段时间是醒着的。那么直接返回 qz[ind]即可。

如果ind为偶数，那么代表[ind,x] 这段时间是睡着的，那么返回 qz[ind] + (x - ind)


需要注意的是：

答案可能会超出int的范围，建议使用long long。

使用cin cout可能会超时，建议使用scanf和printf


#include&lt;iostream&gt;using namespace std;const long long MAXN = 2e5+5;long long a[MAXN];//原始数据long long qz[MAXN];//前缀数组long long n; long long getnum(long long x)&#123;//获取从开始到x的睡眠时间	long long ind = (lower_bound(a+1,a+1+n,x) - a) ;	ind--;	if(ind % 2 == 0LL)&#123;		return x - a[ind] + qz[ind];	&#125;else return qz[ind];&#125;signed main()&#123;	scanf(&quot;%lld&quot;,&amp;n);	for(long long i = 1;i&lt;=n;i++)&#123;		scanf(&quot;%lld&quot;,&amp;a[i]);		if(i % 2 == 0) qz[i] = qz[i - 1];		else qz[i] =qz[i-1] + a[i] - a[i-1];	&#125;	long long q;	scanf(&quot;%lld&quot;,&amp;q);	while(q--)&#123;		long long l ,r;		scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r);		printf(&quot;%lld\n&quot;,getnum(r) - getnum(l));	&#125;	return 0;&#125;
F.ZZUacm 欢迎你直接输出即可
#include&lt;iostream&gt;using namespace std;int main()&#123;	cout&lt;&lt;&quot;hello zzuacm&quot;;	return 0;&#125;
G. 区间和的和注意使用int会溢出！！！
本题两种思路：
方案一、使用前缀和数组。
qz[i] 表示从第1个数到第i个数的总和。计算出前缀和数组后 q[i+k-1] - qz[i-1]就能表示 [i,i+k-1] 的总和。
#include&lt;iostream&gt;using namespace std;const int MAXN = 1e6+5;long long qz[MAXN];int main()&#123;	int n,k;	cin&gt;&gt;n&gt;&gt;k;	long long num;	qz[0] = 0;	for(int i = 1;i&lt;=n;i++)&#123;		scanf(&quot;%lld&quot;,&amp;qz[i]);		qz[i] += qz[i-1];	&#125;	long long ans = 0;//一定要初始化	for(int i = 1;i+k-1&lt;=n;i++)&#123;		ans += qz[i + k -1] - qz[i-1];	&#125;	cout&lt;&lt;ans;	return 0;&#125;
方案二、使用滑动窗口
如果用a[i] 表示第i个数，用 sum(L,R) ( R = L +k-1)   表示从第L个数到第R个数的总和。
那么可以发现 对于任意的L和R。都有sum(L+1,R+1) = sum(L,R) - a[L] + a[R] ，因此可以使用一个变量sum来记录当前k个数的总和，然后窗口每向右移动一下，就使用上述公式来更新sum的值。然后让ans每次都加上sum即可。
#include&lt;iostream&gt;using namespace std;const int MAXN = 1e6+5;long long a[MAXN];int main()&#123;	int n,k;	cin&gt;&gt;n&gt;&gt;k;	a[0] = 0;	for(int i = 1;i&lt;=n;i++)&#123;		scanf(&quot;%lld&quot;,&amp;a[i]);	&#125;	long long sum = 0;	for(int i = 1;i&lt;k;i++)&#123;		sum += a[i];	&#125;	long long ans = 0;	for(int i = k;i&lt;=n;i++)&#123;//i遍历右端点		sum = sum + a[i] - a[i-k];		ans += sum;	&#125;	cout&lt;&lt;ans;	return 0;&#125;
H. Sum of Maximum Weights压轴题！！
本题考察的算法知识： 并查集及其优化策略，树
题目要求每两点之间的 “最短路径的**最大权值** ”的和 ， 我们可以对边按照权值排序，这样每次处理都会是比之前都要大的权值。
每次处理一条边，考虑这个边的起点u和终点v。他们一定在不同的组（并查集中的组），设为U组和V组, 并且这两组分别有sizeU和sizeV个成员。那么U组中任意一个成员，到V组中的任意一个成员，他路径的最大权值都是e（e为当前边的权值）。这样我们就可以让ans = ans + size[u]*size[v]*e 来计算这两组成员之间互相连通产生的 最大权值的和。 然后就可以将这两组合并。
依次对每条边考虑上述情况，就可以得到总共的最大权值的和。
注意：本题使用int记录答案会导致数据溢出。
#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N = 2e6+5;const int M = N*2;int a[N],b[N];int fa[N];//并查集的father数组int size[N];//并查集中记录该组数据的数量int getf(int u)&#123;//并查集中的寻找祖先函数get_father	return u == fa[u] ? u : fa[u] = getf(fa[u]);&#125;struct edge&#123;	int u,v,e;//从u到v有一条权值为e的边&#125; e[N];//存储边的关系bool cmp(edge x,edge y)&#123;//edge结构体的比较函数	return x.e &lt; y.e;&#125;signed main()&#123;	int n;	cin&gt;&gt;n;	for(int i = 1;i&lt;n;i++)&#123;		scanf(&quot;%lld %lld %lld&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].e);	&#125;	for(int i = 1;i&lt;=n;i++)&#123;//并查集的初始化		fa[i] = i;		size[i] = 1;	&#125;	sort(e+1,e+n,cmp);	int ans = 0;	for(int i = 1;i&lt;n;i++)&#123;		edge t = e[i];		int u = t.u, v = t.v, e = t.e;		u = getf(u),v = getf(v);//找到祖先		if(size[u] &lt; size[v])&#123;//将并查集中的较小树作为较大树的子树			swap(u,v);		&#125;		ans += size[u] * size[v] * e;//计算ans		//合并		fa[u] = v;		size[v] += size[u];	&#125;	cout&lt;&lt;ans&lt;&lt;endl;&#125;
I. 区间偶数和设a[i]表示第i个数，循环判断，如果l\le i \le r 并且a[i] 为偶数，令答案加上a[i]即可。
需要使用long long来避免int造成的溢出
#include&lt;iostream&gt;using namespace std;int main()&#123;	int n,l,r;	cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;	long long num;	long long ans  = 0;//一定要初始化	for(int i = 1;i&lt;=n;i++)&#123;		scanf(&quot;%lld&quot;,&amp;num);		if(l &lt;= i &amp;&amp; i &lt;= r &amp;&amp; num % 2 == 0)&#123;			ans += num;		&#125;	&#125;	cout&lt;&lt;ans;	return 0;&#125;
J. 矩阵注意：由于01之间没有空格，因此无法使用读入数字的方法读取数据，应该使用读入字符的方法读取
设mp[i][j]表示第i行第j列数字。可以发现，对于原矩阵,mp[i][j]在经过旋转90°，旋转180°，旋转270° 之后，他们会分别到mp[j][n+1-i],mp[n+1-i][n+1-j],mp[n+1-j][i]  这些位置。
我们说mp[i][j],mp[j][n+1-i],mp[n+1-i][n+1-j],mp[n+1-j][i]，这四个位置是相关联的。如果让矩阵在旋转的过程中原封不动，那么就应该令每组**”相关联的“** 的四个字符变为同一个数字。考虑要尽可能少地改变数字，我们改变出现次数少的数字。（即如果出现了1个1和3个0，那么就把1变成0）
不重不漏地遍历所有的**”关联组“** 即可。（也可以遍历所有的数字，这样的话每个关联组都会被重复调用四次，因此最后需要令ans/=4）
#include&lt;iostream&gt;using namespace std;char mp[105][105];int main()&#123;	int n;	cin&gt;&gt;n;	int ans =0;	for(int i = 1;i&lt;=n;i++)&#123;		for(int j = 1;j&lt;=n;j++)&#123;			cin&gt;&gt;mp[i][j];		&#125;	&#125;	for(int i = 1;i&lt;=n;i++)&#123;		for(int j = 1;j&lt;=n;j++)&#123;			int cnt = 0;			if(mp[i][j] == &#x27;0&#x27;) cnt++;			if(mp[j][n+1-i] == &#x27;0&#x27;) cnt++;			if(mp[n+1-i][n+1-j] == &#x27;0&#x27;) cnt++;			if(mp[n+1-j][i] == &#x27;0&#x27;) cnt++;			ans += min(cnt,4-cnt);		&#125;	&#125;	cout&lt;&lt;ans/4;	return 0;&#125;
K. 模拟类问题方案一、使用一个数组来存储邻居关系，gx[i][j] 表示i和j有邻居关系，之后遍历所有的关系，数出其中没有邻居关系的即可。
#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int dat[55][55];int gx[55][55];//gx[i][j]表示i和j之间有邻居关系int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    int l,r;    for(int i = 1;i&lt;=m;i++)&#123;        for(int j = 1;j&lt;=n;j++)&#123;            scanf(&quot;%d&quot;,&amp;dat[i][j]);        &#125;    &#125;    for(int i = 1;i&lt;=m;i++)&#123;        for(int j = 1;j&lt;n;j++)&#123;            gx[dat[i][j]][dat[i][j+1]] = gx[dat[i][j+1]][dat[i][j]] = 1;        &#125;    &#125;    int ans = 0;    for(int i = 1;i&lt;=n;i++)&#123;        for(int j = i+1;j&lt;=n;j++)&#123;            if(gx[i][j] == 0)                ans ++;        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
方案二、数据量很小，把数据存储起来后，暴力枚举每一对关系即可。
#include&lt;iostream&gt;using namespace std;int dat[55][55];int main()&#123;	int n,m;	cin&gt;&gt;n&gt;&gt;m;	for(int i = 1;i&lt;=m;i++)&#123;		for(int j = 1;j&lt;=n;j++)&#123;			scanf(&quot;%d&quot;,&amp;dat[i][j]);		&#125;	&#125;	int ans = 0;//记录答案	for(int i = 1;i&lt;n;i++)&#123;		for(int j = i+1;j&lt;=n;j++)&#123;//枚举每一对人			int flag = 0;//flag记录是否找到了邻居关系			for(int p = 1;p&lt;=m;p++)&#123;				for(int q = 1;q&lt;n;q++)&#123;					//如果第p行第q这对邻居恰好是i和j					if((dat[p][q] == i &amp;&amp; dat[p][q+1] == j) || (dat[p][q] == j &amp;&amp; dat[p][q+1] == i))						flag = 1;				&#125;			&#125;			if(flag == 0) ans++;//如果没有找到邻居关系		&#125;	&#125;	cout&lt;&lt;ans;	return 0;&#125;
L. 找最大值只考虑奇数，如果比当前的最大值大，就更新最大值。
#include&lt;iostream&gt;using namespace std;int main()&#123;	int mx = -1000000;//使最大值起初为无穷小	int n;	cin&gt;&gt;n;	int num;	for(int i = 1;i&lt;=n;i++)&#123;		cin&gt;&gt;num;		if(num % 2 == 1 &amp;&amp; mx &lt; num)&#123;			mx = num;		&#125; 	&#125;	cout&lt;&lt;mx;	return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM板子</title>
    <url>/67688c8325b8/</url>
    <content><![CDATA[动态规划LIS（最长上升子序列）//复杂度O(nlogn)int n;cin&gt;&gt;n;vector&lt;int&gt; v(n+5);//原始数据int len = 0;for(int i= 1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;v[i]);vector&lt;int&gt; stk;//stk[i]表示长度为i+1的上升子序列，末尾最小是多少。for(int i = 1;i&lt;=n;i++)&#123;    if(stk.empty() || v[i] &gt; stk.back())&#123;//如果能接在后面        stk.push_back(v[i]);    &#125;else&#123;//如果不能，就在stk中找第一个大于等于v[i]的stk[t],用v[i]替换        int t = lower_bound(stk.begin(),stk.end(),v[i]) - stk.begin();        stk[t] = v[i];    &#125;&#125;cout&lt;&lt;stk.size();
LCS（最长公共子序列）int f[N][N];int n,m;cin&gt;&gt;n&gt;&gt;m;string A, B;cin&gt;&gt;A&gt;&gt;B;A = &quot; &quot; + A;B = &quot; &quot; + B;for(int i = 1;i&lt;=n;i++)&#123;    for(int j = 1;j&lt;=m;j++)&#123;        f[i][j] = max(f[i][j],f[i-1][j]);        f[i][j] = max(f[i][j],f[i][j-1]);        if(A[i] == B[j])&#123;            f[i][j] = max(f[i][j],f[i-1][j-1] + 1);        &#125;    &#125;&#125;cout&lt;&lt;f[n][m];
数论博弈论：sg函数#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;unordered_set&gt;using namespace std;const int N = 1e5+5;//N表示一个堆最多多少物品int f[N];//f[i] = sg(i).记忆化搜索int num[50];//num储存总的有向图的数量（也就是NIM中的有几堆物品）int sg(int x)&#123;    if(f[x] != -1) return f[x];    unordered_set&lt;int&gt; s;    //出边，分别代表取一个，取两个，全取出来    if(x &gt;= 1) s.insert(sg(x-1));    if(x &gt;= 2) s.insert(sg(x-2));    s.insert(sg(0));    //mex    for(int i = 0;;i++)&#123;        if(!s.count(i)) return f[x] = i;    &#125;&#125;int main()&#123;    memset(f,-1,sizeof(f));    f[0] = 0;//初始值，可以不设?,也可以视情况设其他的(例如脑算出sg(1),sg(2)等，然后直接给出值)    int res = 0;//总的sg    for(int x : num)&#123;        // res ^= sg(x);    &#125;    return 0;&#125;
数据结构线段树查询区间最值struct segment_tree&#123;	#define ls (p&lt;&lt;1)	#define rs (p&lt;&lt;1|1)		int n;	struct node&#123;		int mx,mi;	&#125;tr[maxn&lt;&lt;3];		void push_up(int p)&#123;		tr[p]=node(max(tr[ls].mx,tr[rs].mx),min(tr[ls].mi,tr[rs].mi));		return;	&#125;	void build(int p,int l,int r)&#123;		if(l==r)&#123;			cin&gt;&gt;tr[p].mx;			tr[p].mi=tr[p].mx;			return;		&#125;		int mid=(l+r)&gt;&gt;1;		build(ls,l,mid);		build(rs,mid+1,r);		push_up(p);	&#125;	void build(int _n)&#123;		n=_n;		build(1,1,n);	&#125;	void print(int p=1,int l=1,int r=n)&#123;		printf(&quot;%2d[%d,%d] %d %d \n&quot;,p,l,r,tr[p].mx,tr[p].mi);		if(l==r)&#123;			return;		&#125;		int mid=(l+r)&gt;&gt;1;		print(ls,l,mid);		print(rs,mid+1,r);	&#125;		void erase(int p,int l,int r,int id)&#123;		if(l==r)&#123;			tr[p].mx=-inf;			tr[p].mi=inf;			return;		&#125;		int mid=(l+r)&gt;&gt;1;		if(id&lt;=mid)erase(ls,l,mid,id);		else erase(rs,mid+1,r,id);		push_up(p);	&#125;	int qmx(int p,int l,int r,int L,int R)&#123;		if(l&lt;=L &amp;&amp; R&lt;=r)&#123;			return tr[p].mx;		&#125;		int mid=(l+r)&gt;&gt;1,ans=-inf;		if(L&lt;=mid)ans=max(ans,qmx(ls,l,mid,L,R));		if(mid+1&lt;=R)ans=max(ans,qmx(rs,mid+1,r,L,R));		return ans;	&#125;	int qmi(int p,int l,int r,int L,int R)&#123;		if(l&lt;=L &amp;&amp; R&lt;=r)&#123;			return tr[p].mi;		&#125;		int mid=(l+r)&gt;&gt;1,ans=inf;		if(L&lt;=mid)ans=min(ans,qmi(ls,l,mid,L,R));		if(mid+1&lt;=R)ans=min(ans,qmi(rs,mid+1,r,L,R));		return ans;	&#125;		#undef ls	#undef rs&#125;tr;
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2025蓝桥杯PythonA组省赛题解</title>
    <url>/d49b5a7aa584/</url>
    <content><![CDATA[2025蓝桥杯PythonA组省赛题解
一定注意，由于在编写本题解时还没有在线题目。所以：
本题解仅供参考，在题意、思路、code上都可能发生错误！

A. RGB三色题意我们可以用三个0~255之间的数(r,g,b)来表示一个颜色，如(0,0,255) 表示蓝色。
那么请问所有的颜色中，有多少种颜色是“偏蓝色”
我们定义当且仅当b > r 并且b > g ，undefinedr,g,b)$ 是偏蓝色的。
思路 &amp; 代码直接暴力枚举！ 复杂度256^3 = 16777216 。
ans = 0for r in range(256):    for g in range(256):        for b in range(256):            if(b &gt; g and b &gt; r):                ans += 1print(ans) # 5559680
方法二：
使用公式计算：
如果我们给定b，那么r和g可以取[0,b-1] 中的任何一个值，有b^2 种可能。于是我们就有如下公式：

ans = \underset{b = 1}{\overset{255}{\sum}} b^2ans = 0for b in range(1,256):    ans += b * bprint(ans) # 5559680
B. IPv6的缩写长度题意给出IPv6的缩写规则：
IPv6由8段组成，每段4个16进制数。
省略规则如下：

对于一段的四个十六进制数，前导零可以省略。
如果一段中只包含零，必须保留一个零。
可以将一段连续的0省略，用:: 替代，但是整个IPv6只能缩写一段。

下面给出一些例子




缩写前
缩写后




2001:0db8:0000:0000:0000:ff00:0042:8329
2001:db8::ff00:42:8329


0000:0000:0000:0000:0000:0000:0000:0001
::1


0000:0000:0000:0000:0000:0000:0000:0000
::


ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff


2001:0db8:85a3:0000:0000:8a2e:0370:7334
2001:db8:85a3::8a2e:370:7334




那么请问：
所有的IPv6地址，把他们的长度加起来是多少？
由于答案太大，我们对10^9+7  取模。
思路直接枚举肯定是不可以的。
我们考虑按段分类枚举：
对于八个段中的每一个段，我们分为以下五种情况：

这一段是0 ,共1个数符合情况
这一段是一位数，即三位前导零，共(000f - 0 = 15)个数符合情况 
这一段是两位数，即两位前导零，共`(00ff - 000f = 15*16)个数符合情况 
这一段是三位数，即一位前导零，共(0fff - 00ff = 15*16*16) 个数符合情况 
这一段是四位数，没有前导零，共(ffff - 0fff = 15*16*16*16) 个数符合情况 

当我们固定了八段所有的情况后， 他的长度就可以求出来了，于是我们对每段枚举这五种情况。循环的时间复杂度是5^8 。
之后我们假设这个IPv6地址如下：a0:a1:a2:a3:a4:a5:a6:a7 
那么我们就可以计算得到在缩写前的总长度是length_{pre} = (l_0+l_1+l_2+...+l_7) + 7 (七个冒号) (这里a_i = 0时l_i=1 ,其他时候l_i = a_i )
在缩写时我们对每段连续0区间进行计算，得到他的缩小程度。我们取其中的最大值length_{omit}即可。
如何计算？假设我们得到了一个区间[l,r]

如果l = 0 \text{ and }r = 7 , length_{omit} = 13
若不满足第一项：如果l = 0 \text{ or } r = 7 , length_{omit} = 2 * (r - l + 1) - 2
如果不满足第一、二项；length_{omit} = 2 * (r - l + 1) - 1

这样我们就计算出来这个地址的长度，那么这个地址的总数则是每段所包含的数的数量，把他们乘到一起。cnt_{all} = \Pi_{i = 0}^7 cnt(a_i)
那么整个这个类型的IPv6的地址总长度，当然就是cnt_{all} * (length_{pre} - length_{omit}) 了。

注：我们枚举八个段，可以使用八重循环（太丑陋！）
也可以直接枚举一个“五进制数”，从0 到5^8 , 然后对他进行进制拆分

代码
我们在调试时可以把N设置的比较小，然后输出所有的情况来查看计算是否有问题。

N = 8ans = 2 # 这里直接把全零的情况提取出来，后面的range从1开始cnt = [1,15,15*16,15*16*16,15*16*16*16]MOD = int(1e9+7)for x in range(1,5**N):    a = [] # a[i]表示第i位是几    for right in range(N):        a.append(x%5)        x //= 5    # 接下来找连续的0串    left = -1    length_omit = 0     for right in range(N):        # 这里枚举的区间是(left,right],区间长度是right-left        if(a[right] == 0):            if(left == -1 or right == N-1):                length_omit = max(length_omit,2 *(right-left)-2)            else:                length_omit = max(length_omit,2 *(right-left)-1)        else :            left = right    length_pre = 0    for i in range(N):        if(a[i] == 0):            length_pre += 1        else:            length_pre += a[i]    length_pre += (N-1)    cnt_all = 1    for i in range(N):        cnt_all = cnt_all * cnt[a[i]] % MOD    # print(a)    # print(length_pre,length_omit)    ans += cnt_all * (length_pre - length_omit) % MOD    ans %= MODprint(ans) # 905307083
C. 2025题意给出n,w, 求出n行m列的2025矩阵：

第1行是2025的不断重复

从第2行开始，每行都是上一行左移一位


当n = 4,m = 10时如下：
2025202520025202520225202520255202520252
思路我们发现，左下-右上对角线上的元素是相同的。他们满足j + i = c ，即列和行的和是定值。
代码import sysInput = sys.stdin.readlinen,m = map(int,Input().split())ch = [2,0,2,5]for i in range(n):    for j in range(m):        print(ch[(i+j)%4],end=&quot;&quot;)    print(&quot;&quot;)
D 1到n的二进制拼接题意把1到n这些数，转换为二进制，然后进行拼接操作。
问怎样拼接能使得数值尽可能大？ 把这个01串再转换回十进制。
例如：n = 3时，1,2,3 的二进制分别为1,10,11 ，进行拼接后最大为11110 ,转换为十进制为30
n \le 10000
思路把代码分为三部分，然后每部分分别处理即可。

第一步，二进制转换，我们使用字符串来保存。

对每个数进行按位分离(每位为2)，然后拼接成字符串即可。

第二步，找最大的拼接。

这是一个经典例题[最大数(leetcode)](https://leetcode.cn/problems/largest-number/description/) , 简单地说就是对字符串进行排序，排序规则是“对于相邻的两个串， 如果s_a + s_b > s_b + s_a，那么s_a 在s_b 的前面” ,详细证明可以看leetcode例题的题解。

第三步，对拼接后的字符串进行二进制转十进制。

从最高位枚举然后乘起来即可，我们python不需要考虑溢出问题。
代码n = int(input())s_lst = []for i in range(1,n+1):    a = []    x = i    while(x):        a.append(str(x%2))        x //= 2    s_lst.append(&quot;&quot;.join(a[::-1])) # 注意这里要倒过来# 自定义排序推荐重写类的___lt__ 方法class Node():    def __init__(self,s):        self.s = s    def __lt__(self,other):        return self.s+other.s &gt; other.s+self.snode_lst = []for i in s_lst:    node_lst.append(Node(i))# 排序node_lst.sort()# 拼接ans_str = &quot;&quot; for i in node_lst:    ans_str += i.s# 进制转换ans = 0for i in ans_str:    ans = ans * 2 + int(i)print(ans)
E. 彩色瓶子题意给你n个瓶子，以及整数k。
每隔k个他们的瓶子颜色就是一样的。即对于所有的i，满足color_i = color_{i + k}  , 每个瓶子中都有一定量的水。记作a_1,a_2,...,a_n  。 
你可以任意次地将第i个瓶子中的整数量的水倒入相同颜色的瓶子j中 ,唯一的要求是i < j。
那么请问，在任意次操作后， 所有瓶子中含水量的最小值，最大的可能是多少。
思路最大的最小值，我们要首先尝试二分答案，在本题，二分求瓶子的最小值x。
我们的check函数应该是这样的：
我们对每个水瓶进行如下处理：

如果当前水瓶的水超过x，那么把多余的水存下来，供后面使用。
如果当前水瓶的水不够x，则用之前相同颜色水瓶存的水补满，补不满则宣告这个x是不可能的。

如果check(x) == True，我们则可以考虑令x更大一些
如果check(x) == False ，我们则考虑令x更小一些。
于是这样就能找到满足check(x) == True的最大的x了。
代码import sysinput = sys.stdin.readlinen,k = list(map(int,input().split()))a = list(map(int,input().split()))def check(x):    global n,a,k    have = [0] * k     for i in range(n):        if(a[i] &gt;= x):            have[i % k] += a[i] - x        else:            if(have[i%k]+a[i] &gt;= x):                have[i%k] -= x - a[i]            else:                return False    return Truel = 1r = int(1e9)while(l &lt; r):    mid = (l + r + 1) // 2    if(check(mid)):        l = mid    else:        r = mid - 1print(l)
F.拼好数题意给出n个正整数。 a_1,a_2,...,a_n
你可以将他们拼接为若干个组。 要求如下：

每组最多由三个数拼接而成
拼接完成后“6”的数位数量不少于6个。

那么请问最多可以分为多少组？
n \le 1000
思路我们不关心a数组之间的顺序关系，并且只关心a_i 中包含6的数量。所以我们可以统计一下出现undefined0,1,2,3,4,5,6+)$个6的数分别有多少个。
注意

当一个数中出现了不少于6个6时，那么只需要一个这个数就可以使得答案成立。我们可以把这一类数归为同一类。这一类不需要参与计算，他们单独一组就是最优的。
当一个数中出现了0个6时，这个数是没有用的，我们可以直接扔掉。

于是我们就得到了cnt数组。其中cnt[i] 表示出现了i个6有多少个数。
于是我们就可以考虑使用搜索来求了，那么如何进行状态转移？action为选择了一个合适的组。我的做法是预处理出所有可选的operator。得到如下数组(直接三重循环即可)：
ope = [[0, 1, 5], [0, 2, 4], [0, 2, 5], [0, 3, 3], [0, 3, 4], [0, 3, 5], [0, 4, 4], [0, 4, 5], [0, 5, 5], [1, 1, 4], [1, 1, 5], [1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 3], [1, 3, 4], [1, 3, 5], [1, 4, 4], [1, 4, 5], [1, 5, 5], [2, 2, 2], [2, 2, 3], [2, 2, 4], [2, 2, 5], [2, 3, 3], [2, 3, 4], [2, 3, 5], [2, 4, 4], [2, 4, 5], [2, 5, 5], [3, 3, 3], [3, 3, 4], [3, 3, 5], [3, 4, 4], [3, 4, 5], [3, 5, 5], [4, 4, 4], [4, 4, 5], [4, 5, 5], [5, 5, 5]]# 我们可以将这里的0视为不选，也可以视为选择一个包含0个6的数，因为“包含0个6的数”可以是任意多个。
然后我们就可以通过这些操作来进行状态转移了。
一个状态可以描述为五元组undefinedcnt[1],cnt[2],…,cnt[5])$ 的取值。
之后我们进行搜索即可。
优化本体的关键在于优化，下面详细讲一下优化策略：

最刚需的优化就是记忆化搜索：

我们发现对于某个状态，我们可能会重复了很多很多次，比如初始状态为undefined0,0,3,3,3)，那么如下两种序列都可以得到(0,0,1,1,3), 于是我们就会计算两次(甚至更多次)状态(0,0,1,1,3)$ 
序列一：

(0,0,3,3,3) \overset{ope(0,3,3)}{\to} (0,0,1,3,3)\overset{ope(0,4,4)}{ \to} (0,0,1,1,3) \\
(0,0,3,3,3) \overset{ope(0,3,4)}{\to} (0,0,1,3,3)\overset{ope(0,4,4)}{ \to} (0,0,1,1,3) \\所以我们每次计算出一个状态的结果后，立刻把他放到字典当中。dic(state) = value .
当下次再一次遇到这个状态时，我们就可以直接返回这个值了。

剪枝

本题的剪枝主要是计算答案的上界。 假设我们要从状态u 转移到状态v 。 v = (s_1,s_2,s_3,s_4,s_5)
那么状态v的贡献一定不会超过这两个值：
首先，必须选择至少两个数来组成一组，所以

ans_v \le \frac{s_1+s_2+...s_5}{2}其次，每组必须有至少6个6.所以

ans_v \le \frac{s_1 + 2 * s_2 + ...+ 5*s_5}{6}当我们在取到等号时，仍然无法做到ans_v + 1 > ans_u 即更新状态u的答案，那么我们再对v搜索就是徒劳的。这时候应该直接跳过本次搜索。
代码import sysinput = sys.stdin.readlinen = int(input()) a = list(map(int,input().split()))# n = 1000# a = [6,66,666,6666,66666] * 200ope = []for i in range(6):    for j in range(i,6):        for k in range(j,6):            if(i + j + k &gt;= 6):                ope.append((i,j,k))cnt = [0] * 7for i in range(n):    x = a[i]    cc = 0    while(x):        if(x % 10 == 6):            cc += 1        x //= 10    cnt[min(cc,6)] += 1cnt[0] = int(1e12)# 给cnt[0]一个足够大的值，代表我们可以选择任意数量的无效数。# 可以减少特判visit = &#123;&#125; # 记忆化字典def dfs():        # 如果当前完全凑不够6个6就该返回了。    cc = 0    for i in range(1,6):        cc += cnt[i] * i    if(cc &lt; 6):        return 0    ans = 0 # 当前dfs最大可能的取值    gt = visit.get(tuple(cnt[1:6]),None)    if(gt != None): # 如果之前计算过，直接返回        return gt    for x,y,z in ope:        ## 尝试选择这组ope        cnt[x] -= 1        cnt[y] -= 1        cnt[z] -= 1        ok = 0 # 这组ope是否是合法的             if(cnt[x] &gt;= 0 and cnt[y] &gt;= 0 and cnt[z] &gt;= 0):            ok = 1 # 是合法的        if(ok):            # 两个剪枝            c1 = 0            for i in range(1,6):                c1 += cnt[i]            # 是否通过剪枝            c2 = 0            for i in range(1,6):                c2 += cnt[i] * i            if(c1//2 + 1 &gt; ans and c2 //6 + 1 &gt; ans):                ans = max(ans,dfs()+1)        # 不管有没有进入dfs，都要返回现场        cnt[x] += 1        cnt[y] += 1        cnt[z] += 1    # 最后记得更新visit    visit[tuple(cnt[1:6])] = ans    return ansprint(dfs()+cnt[6]) #  别忘了加cnt[6]&quot;&quot;&quot;66 66 666 6666 66666 6666664666 66 666666 12345666 6 6 6 6 6&quot;&quot;&quot;
G. 登山题意有一个n行m列的矩阵h 。描绘了一个地图上每个格子的高度。h[i][j] 表示第i行第j 列的高度。
你当前的节点位置为undefinedp,q)$每次可以选择下面操作之一：

选择一个i>p 的节点，并且h[i][q] < h[p][q] , 走到节点undefinedi,q)$
选择一个i h[p][q] , 走到节点undefinedi,q)$
选择一个j>q 的节点，并且h[p][j] < h[p][q] , 走到节点undefinedp,j)$
选择一个j]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM笔记</title>
    <url>/10a9231f6b6b/</url>
    <content><![CDATA[数论博弈论：sg函数定义**NIM博弈：**
给定n堆物品，第i堆物品有A_i 个，两名玩家轮流行动，每次任选一堆，取出任意多个物品，取走最后一件物品者胜利。
**当且仅当 A_1 xorA_2xor...xorA_n时，NIM博弈先手必胜。**
**公平组合游戏ICG**：（NIM就是经典的公平组合游戏）
1.由两名玩家交替行动2.在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关3.不能行动的玩家判负
**有向图游戏：**
给定一个有向无环图，途中有唯一的起点，在起点放一枚棋子。两名玩家交替把这个棋子沿边移动，无法移动者判负。
**公平组合游戏都可以转化为有向图游戏。**
**SG函数**：
在有向图游戏中，对于节点x，设从节点x出发分别到达了y_1,y_2,...,y_k ，定义sg(x):
sg(x) = mex(\{ sg(y_1),sg(y_2),...,sg(y_k)\}) 。（mex(s)表示不属于集合s的最小非负整数）
对于整个有向图G，sg(G) = sg(s)
对于多个有向图游戏G_1,G_2,...,G_m的和GSG(G) = SG(G_1)xorSG(G_2)xor...xorSG(G_m)
sg(x)>0 表示这个局面必胜，sg(x)=0表示这个局面必败
代码模板#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;unordered_set&gt;using namespace std;const int N = 1e5+5;//N表示一个堆最多多少物品int f[N];//f[i] = sg(i).记忆化搜索int num[50];//num储存总的有向图的数量（也就是NIM中的有几堆物品）int sg(int x)&#123;    if(f[x] != -1) return f[x];    unordered_set&lt;int&gt; s;    //出边，分别代表取一个，取两个，全取出来    if(x &gt;= 1) s.insert(sg(x-1));    if(x &gt;= 2) s.insert(sg(x-2));    s.insert(sg(0));    //mex    for(int i = 0;;i++)&#123;        if(!s.count(i)) return f[x] = i;    &#125;&#125;int main()&#123;    memset(f,-1,sizeof(f));    f[0] = 0;//初始值，可以不设?,也可以视情况设其他的(例如脑算出sg(1),sg(2)等，然后直接给出值)    int res = 0;//总的sg    for(int x : num)&#123;        // res ^= sg(x);    &#125;    return 0;&#125;
例题Men’s showdownhttps://codeforces.com/gym/102780/problem/H
给出一堆物品n，双方分别拿走1，5，13个，拿走最后一个者**失败**。问谁会获胜
#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;unordered_set&gt;using namespace std;int f[10005];//f[i] = sg(i).记忆化搜索int num[50];//num储存总的有向图的数量（也就是NIM中的有几堆物品）int sg(int x)&#123;    if(f[x] != -1) return f[x];    unordered_set&lt;int&gt; s;    if(x &gt;= 1) s.insert(sg(x-1));    if(x &gt;= 5) s.insert(sg(x-5));    if(x &gt;= 13) s.insert(sg(x-13));    //mex    for(int i = 0;;i++)&#123;        if(!s.count(i)) return f[x] = i;    &#125;&#125;int main()&#123;    memset(f,-1,sizeof(f));    int x;    cin&gt;&gt;x;    if(sg(x)) cout&lt;&lt;2;    else cout&lt;&lt;1;    return 0;&#125;
A word gamehttps://codeforces.com/gym/102780/problem/F
有一个只有大写字母的字符串，双方轮流进行如下操作之一，最终拿走最后一个字符者获胜1.拿走一个字符2.拿走两个相同的字符3.拿走某种字符的全部
将每种字符看作一个NIM博弈，那么答案就是所有NIM博弈的“和”。最终的sg函数也就是各自的sg函数的异或和。
#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;unordered_set&gt;using namespace std;int num[30];int f[100];int sg(int x)&#123;    if(f[x] != -1) return f[x];    unordered_set&lt;int&gt; s;    if(x &gt;= 1) s.insert(sg(x-1));    if(x &gt;= 2) s.insert(sg(x-2));    if(x &gt;= 3) s.insert(sg(0));    for(int i = 0;;i++)&#123;        if(!s.count(i)) return f[x] = i;    &#125;&#125;int main()&#123;    string str;    cin&gt;&gt;str;    for(auto p : str)&#123;num[p-&#x27;A&#x27;+1]++;&#125;    memset(f,-1,sizeof(f));    f[0] = 0;    int res = 0;    for(int i = 1;i&lt;=26;i++)&#123;        res ^= sg(num[i]);    &#125;    if(res) cout&lt;&lt;&quot;Alice&quot;;    else cout&lt;&lt;&quot;Bob&quot;;    return 0;&#125;
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 346</title>
    <url>/17fe9a65a7dc/</url>
    <content><![CDATA[AtCoder Beginner Contest 346
A - Adjacent Product题意给你一个数组a_1,a_2,...,a_n ，现在有b_i = a_i * a_{i+1} 输出b_1,b_2,...,b_{n-1}
思路照着题意写就行
代码n = int(input())lst = [int(x) for x in input().split()]ans = []for i in range(len(lst)-1):    print(lst[i] * lst[i+1],end=&#x27; &#x27;)
**B - Piano**题意有一个字符串，由无数个wbwbwwbwbwbw 重复得来，现在给出两个数W和Bundefined1\le W,B \le 100 )问是否存在某个子串满足：包含W个`w`以及B$ 个b
思路这个子串一定不会超过200位，所以我们重复wbwbwwbwbwbw 40次(长度12*40 = 480)就可以保证所有的子串都在其中，然后我们求所有长度为W+B 的子串，依次判断他们是否满足情况。
代码str = &quot;wbwbwwbwbwbw&quot;*100w,b = [int(x) for x in input().split()]sm = []sm.append(0)cnt = 0for x in str:    if x == &#x27;w&#x27;:        cnt+=1    sm.append(cnt)for l in range(1,len(sm)):    r = l+w+b-1    if r &gt;= len(sm):        break    if(sm[r] -sm[l-1]==w):        print(&quot;Yes&quot;)        exit(0)print(&#x27;No&#x27;)
**C - Σ**题意给出n,k 以及一个长度为n的数组A ，问所有[1,k] 中**不属于A**的数的总和是多少。
undefined1 \le n \le 2*10^5 , 1\le k,A_i \le 2 * 10^9)$  
思路我们遍历整个数组A，取出其中位于[1,k] 中的所有数， 然后去重。对去重后的数组求和 ，令总和为sum，那么最终答案就是undefinedfrac{k*(k+1)}{2} - sum$
代码n = int(input())string = input()string = &#x27; &#x27; + stringa = [int(x) for x in input().split()]sm = [0]for x in a:    sm.append(sm[-1]+x)a = [0] + acost = [0]*(n+5)for i in range(1,n+1):    cost[i]=cost[i-1]    if (string[i] == &#x27;1&#x27;)^(i%2) :        cost[i]+=a[i]ans = int(1e18)for i in range(1,n):    ans = min(ans,cost[i]+(sm[n]-sm[i])-(cost[n]-cost[i]))    ans = min(ans,(sm[i]-cost[i])+(cost[n]-cost[i]))print(ans)
**D - Gomamayo Sequence**题意给你一个长度为n的01串S，以及一个长度为n的数组a。a_i表示将S_i 进行01翻转所需要的花费。
问最少需要多少花费，能够使得S满足：满足S_i = S_{i+1} 的i恰好有一个。
思路我们先设有如下两个长度同样为n的字符串：
S1 = 1010101...
S2 = 0101010...
对于最终的字符串，他一定是从S1和S2中各取出一边拼接得来。如S = 0101101 则是先取S2的前4个字符，与S1的后3个字符进行拼接。
我们可以计算出将前i个字符替换为S1形式的花销cost1_i 以及将前i个字符替换为S2形式的花销cost2_i 。
于是我们枚举拼接点i(1\le i \le n-1) 。 对于每个拼接点，有两种拼接方式：

选择左半部分为S1，右半部分为S2
选择左半部分为S2，右半部分为S1

利用已经预处理完毕的cost1,cost2 前缀和数组,分别计算出两部分的花费。与答案取MIN。
最终的答案就是这2*(n-1)种选择中的最小值
代码n = int(input())string = input()string = &#x27; &#x27; + stringa = [int(x) for x in input().split()]a = [0] + acost1 = [0]*(n+5)cost2 = [0]*(n+5)for i in range(1,n+1):    cost1[i]=cost1[i-1]    cost2[i]=cost2[i-1]    if (string[i] == &#x27;1&#x27;)^(i%2) :        cost1[i] += a[i]    else :        cost2[i] += a[i]ans = int(1e18)for i in range(1,n):    ans = min(ans,cost1[i]+cost2[n]-cost2[i])    ans = min(ans,cost2[i]+cost1[n]-cost1[i])print(ans)
**E - Paint**题意给出一个H行W 列的表格，起初全部涂满了0 。下面要进行M次操作，每次操作有三个参数t,a,x

t = 1时，将第a​**行**涂为编号为x的颜色。
t = 2时，将第a**列**涂为编号为x的颜色。 

问你最终都有哪些颜色，每种颜色占有多少个格子。(按照颜色编号从小到大输出，占有格子为0的颜色不输出)
思路直接暴力染色很显然会超时(复杂度O(MN)) 。 我们发现后染色的会覆盖之前已经染好的颜色。因此我们倒序处理每一个染色操作。
我们用变量row记录已经染了几行，用col表示已经染了几列。
对于一次新的染色，只能选择之前未染色的格子来染色（因为是逆序），若这次染色为行，那么最终会染m - col 个格子。(这一行共m个格子中有col个格子之前就已经被染色) ，若染色为列，同理n - row。
我们还需要注意，如果选择的这一行，在之前就已经选择过，那么这次染色是无效的(一整行都被之前染色过了)，应该直接跳过
代码n,m,q = [int(x) for x in input().split()]ope = []for _ in range(q):    t,a,x = [int(x) for x in input().split()]    ope.append((t,a,x))sm = n * mcolor = [0]*(int(2e5+5))col = [0]*(int(2e5+5))colsum,rowsum = 0,0row = [0]*(int(2e5+5))for t,a,x in ope[::-1]:    if t == 1:        if row[a] == 0:            rowsum += 1            color[x] += m - colsum            sm -= m - colsum            row[a] = 1    else:        if col[a] == 0:            colsum += 1            color[x] += n - rowsum            sm -= n - rowsum            col[a] = 1color[0]+=smans = []for i in range(int(2e5+2)):    if(color[i] != 0):        ans.append((i,color[i]))print(len(ans))for a,b in ans:    print(a,b,end=&quot; &quot;)    print()
**F - SSttrriinngg in StringString**题意定义f(X,k)表示将X这个字符串整体重复k次。g(X,k)表示将X的每一个字符重复k次后拼接起来。
f(&quot;abc&quot;,2) = abcabc。g(&quot;abc&quot;,2) = aabbcc
现在给你一个整数n和两个字符串S,T ,求出k最大是多少，能使得g(T,k)是f(S,n)的子序列(子序列不连续）。
思路很明显的二分答案。关键在于check函数的编写。
先预处理出来如下信息：

26个字母的在S中出现次数的前缀和。int cnt[26][maxn]; 。cnt[1][3]表示在S的前三个字符中，有几个b字符。
26个字母的第i次出现在S中的下标位置。vector&lt;int&gt; pos[26]; pos[1][2]表示在S中的第二个b的下标是多少。

我们在check中，k是已知的。
可以使用一个变量used 表示已经使用了几个**完整的**S字符串。我们遍历T中的每个字符ch。他要重复k次，因此就需要进行如下两步操作：

如果当前这个字符串还有剩余的ch字符，先用这些字符
如果不够用，就”启封“新的字符串S。直接计算要用多少个成套的字符串S
如果用完这些成套的字符串S，还差一些，就再启封一个S，使用其中的一部分字符串。

我们用p表示**对于当前启封的字符串，用到了哪个位置了(下标）** ，这样下一次只能使用从pos往后的字符。
**注意**在第2步中，不能使用循环来求，应该直接让剩余量整除以cnt[ch-&#39;a&#39;][n] 得到需要的套数。否则会导致超时。
循环结束后，如果我们有一套启封了但没有用完，同样需要对used进行加一操作。
最终我们要判断的是**used是否小于等于N**
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int N;int n;string S,T;const int maxn = 1e5+5;int cnt[26][maxn];vector&lt;int&gt; pos[26];bool check(int k)&#123;    int used = 0;//已经用了多少套完整的S    int p = 0;//目前这一套用到哪了    for(char ch : T)&#123;        int kk = k;//还需要多少个kk        int num = ch-&#x27;a&#x27;;        if(cnt[num][n] == 0)&#123;return false;&#125;        int time = min(cnt[num][n]-cnt[num][p],kk);        kk -= time;        p = pos[num][cnt[num][p]+time];        used += kk/cnt[num][n];        kk -= kk/cnt[num][n] * cnt[num][n];        if(kk)&#123;            used++;            p = pos[num][kk];        &#125;        if(used + (p!=0) &gt; N)&#123; //如果p不等于0表示有一套S用了一半。这时候需要让答案加一            return false;        &#125;    &#125;       return true;&#125;void solve()&#123;    cin&gt;&gt;N&gt;&gt;S&gt;&gt;T;    n = S.length();    S = &quot; &quot;+ S;    for(int i = 0;i&lt;26;i++) pos[i].push_back(0);    for(int i =1;i&lt;=n;i++)&#123;        for(int j = 0;j&lt;26;j++)&#123;            cnt[j][i] += cnt[j][i-1];        &#125;        cnt[S[i]-&#x27;a&#x27;][i]++;        pos[S[i]-&#x27;a&#x27;].push_back(i);    &#125;    int l = 0,r = 1e18;    while(l &lt; r)&#123;        int mid = (l+r+1)/2;        if(check(mid)) l = mid;        else r = mid -1;    &#125;    cout&lt;&lt;l;&#125;signed main()&#123;    int T = 1;    // cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 806 (Div. 4)</title>
    <url>/f6c0852c19b0/</url>
    <content><![CDATA[刚学python，还是免不了C++的代码风格。
[Love Story](https://codeforces.com/contest/1829/problem/A)def solve():    str = input()    ans = 0    for i in range(10):        if(str[i] != std[i]):            ans +=1    print(ans)###########t = int(input())std = &quot;codeforces&quot;for i in range(t):    solve()     
[Blank Space](https://codeforces.com/contest/1829/problem/B)#pythont = int(input())for i in range(t):    n = int(input())    a = map(int,input().split())    temp = 0    ans = -1    for j in a:        if j == 0:            temp+=1        else:            temp = 0        ans = max(ans,temp)    print(ans)
[A. Plus or Minus](https://codeforces.com/contest/1807/problem/A)def solve():    data = list(map(int,input().split()))    if (data[0] + data[1]) == data[2]:        print(&quot;+&quot;)    else:        print(&quot;-&quot;)        ###########t = int(input())for i in range(t):    solve() 
[Grab the Candies](https://codeforces.com/contest/1807/problem/B)def solve():    n = int(input())    a = list(map(int,input().split()))    mh = 0    bika = 0    for i in a:        if(i % 2 == 0):            mh+=i        else:            bika +=i    if(mh &gt; bika):        print(&quot;YES&quot;)    else:        print(&quot;NO&quot;)###########t = int(input())for i in range(t):    solve() 
[Is It a Cat?](https://codeforces.com/contest/1800/problem/A)def solve():    n = int(input())    str = input()    sta = &#x27;m&#x27;    str = str.lower()    ss = str[0]    for i in range(1,n):        if(str[i] != str[i-1]):            ss += str[i]    if(ss == &quot;meow&quot;):        print(&quot;YES&quot;)    else:        print(&quot;NO&quot;)        ###########t = int(input())for i in range(t):    solve()     
[A - YES or YES?](https://codeforces.com/contest/1703/problem/A)def solve():    str = input()    str = str.upper()    if(str == &quot;YES&quot;):        print(&quot;YES&quot;)    else:        print(&quot;NO&quot;)            ###########t = int(input())for i in range(t):    solve()     
[B - ICPC Balloons](https://codeforces.com/contest/1703/problem/B)def solve():    ok = []    for i in range(26):        ok.append(0)    n = int(input())    str = input()    ans = 0    for ch in str:        if(ok[ord(ch) - ord(&#x27;A&#x27;)] == 0):            ans += 2            ok[ord(ch) - ord(&#x27;A&#x27;)] = 1        else:            ans +=1    print(ans)        ###########t = int(input())for i in range(t):    solve()     
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 897 (Div. 2)</title>
    <url>/1f41d16e4fe3/</url>
    <content><![CDATA[[Dashboard - Codeforces Round 897 (Div. 2) - Codeforces](https://codeforces.com/contest/1867)
A - green_gold_dog, array and permutation题意有一个长度为n的数组a，请你找出一个长度为n的排列b。 根据数组a和b来构造出数组c。c[i] = a[i] - b[i] ，尽可能地使c数组中的 互不相同的数的数量。
思路好妙的思路！ 让最小的a[i] 减去n,次小的减去n-1 ,这样每个c[i] 都不一样。
代码#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N = 4e4 + 5;pair&lt;int,int&gt; a[N];pair&lt;int,int&gt; b[N];int main()&#123;	int t;	cin&gt;&gt;t;	while (t--)&#123;		int n;		cin&gt;&gt;n;		int num;		for(int i = 1;i&lt;=n;i++)&#123;			cin&gt;&gt;num;			a[i].first = num;			a[i].second = i;		&#125;		sort(a+1,a+1+n);		for(int i = 1;i&lt;=n;i++)&#123;			b[i].first = a[i].second;			b[i].second = n+1-i;		&#125;		sort(b+1,b+1+n);		for(int i = 1;i&lt;=n;i++)&#123;			cout&lt;&lt;b[i].second &lt;&lt;&quot; &quot;;		&#125;		puts(&quot;&quot;);	&#125;		return 0;&#125;
 ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 899 (Div. 2)</title>
    <url>/0eb0eaa11b1f/</url>
    <content><![CDATA[[Dashboard - Codeforces Round 899 (Div. 2) - Codeforces](https://codeforces.com/contest/1882)
C. Card Game题意有n张卡牌，每张卡牌上有一个整数（可能是负数），按顺序盖好， 你可以选择任意次如下操作，使得你最终的得分最多：

选择一个奇数 i ,将第 i 个数从牌堆中取出，然后获得这张牌上对应的分数
选择一个偶数  i ,将第i个数从牌堆中丢弃，不获得对应分数

问进行若干次操作后（可以为0次） 最多可以获得多少分数。
思路由于牌上的数可以是负数，所以我们要尽量多的选择正数，然后尽量少地选择负数。
我们可以把连续的一段负数（或者连续的一段正数） 称为 负数串（正数串）对于任意一个长度大于等于2的负数串，我们可以通过不断舍弃偶数，使得最终这个串只剩下一个或零个负数对于任意一个长度大于等于2的正数串，我们可以通过不断选取奇数，来让这个串最终只剩一个或零个整数
这样化简到最后，一定会是 负正负正... 的串
因此我们只需要考虑负数在奇数，正数在偶数的情况：这时候我们就需要选择两种情况中的较优解：1. 选取负数，然后选取后面跟着的正数。 2.负数和正数都不选择。并且我们只需要做一次这样的取舍，就可以获得选择之后所有正数的机会。
因此我们可以使用后缀和记录后i个正数的和。然后遍历数组，如果到达了数组的奇数位，则选择 不选或者 选上该位的数字之后再 加上此后的所有正数；如果到达了数组的偶数位，则 可以通过抛弃这一位来选择此后所有的正数。 最终找到最优的选择位置和方案即可。
代码#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define int long long//注意这题会爆intconst int N = 1e5+5;signed main()&#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        int n,ans = 0;        cin&gt;&gt;n;        vector&lt;int&gt; a(n+5);        vector&lt;int&gt; sum(n+5);        for(int i = 1;i&lt;=n;i++) cin&gt;&gt;a[i];        for(int i = n;i&gt;0;i--)&#123;//求后缀中的正数和            sum[i] = sum[i+1];            if(a[i] &gt; 0) sum[i] += a[i];        &#125;        for(int i = 1;i &lt;= n;i++)&#123;            if(i % 2 == 1) ans = max(ans,sum[i+1] + a[i]);            else ans = max(ans,sum[i + 1]);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;    return 0;&#125;
D]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 904 (Div. 2)</title>
    <url>/b104fde463a2/</url>
    <content><![CDATA[[Dashboard - Codeforces Round 904 (Div. 2) - Codeforces](https://codeforces.com/contest/1884)
C. Medium Design题意给长度为m的数组a，初始均为0。1\le m \le 10^9
给出一些区间，请你选出其中某些区间。每选择一个区间，就令区间中的数都加一，问 数组中最大值max(a) ,和最小值min(a) 的差，最大为多少。
思路考虑以下贪心策略：如果我们确定了最终第i个数是最大的那个数，即a[i] = max(a) , 那么我们就可以选择所有的包含i的区间。然后摒弃所有不包含i的区间。（选上包含i的区间一定会令max(a)++) , 这样我们可以遍历所有的数组下标i。 计算假使i为最大数时的ans，最终选择最大的ans即可。
我们可以先对区间进行排序。 然后根据右端点从小到大维护优先队列pq。这样按顺序遍历区间数组，就可以引入所有左端点小于等于i的区间。然后通过剔除优先队列中的右端点小于i的区间。 这样优先队列中就保存了所有的包含i的区间。  因此有 max(a) = pq.size() ,
再考虑寻找最小值min(a) , 如果我们使用 cntl 左端点为1的区间的数量。同理使用 cntr记录右端点为m的区间的数量 。那么 min(a) = min(cntl,cntr) 。
本题m较大。需要离散化处理。
代码#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; PII;struct cmp&#123;	bool operator()(PII x,PII y)&#123;return x.second &gt; y.second;&#125;&#125;;int main()&#123;	int t;	cin&gt;&gt;t;	cin.tie(0);cout.tie(0);	while(t--)&#123;		int n,m;		cin&gt;&gt;n&gt;&gt;m;		vector&lt;int &gt; vec(2 * n+5);//存储端点		vector&lt;PII&gt; seq(2*n+5);//存储区间		int l ,r;		for(int i = 1;i&lt;=n;i++)&#123;			cin&gt;&gt;l&gt;&gt;r;			seq[i] = make_pair(l,r);			vec[2 * i - 1] = l;			vec[2 * i] = r;		&#125;		//离散化处理		vec[0] = 1;//引入1和m两个端点		vec[2 * n + 1] = m;		sort(vec.begin(),vec.begin()+2+2*n);//排序		int len = unique(vec.begin(),vec.begin()+2+2*n) - vec.begin();//去重		// for(int i = 0;i&lt;len;i++) cout&lt;&lt;vec[i] &lt;&lt;&quot; &quot;;		// puts(&quot;&quot;);			unordered_map&lt;int,int&gt; mp;		for(int i = 0;i&lt;len;i++)&#123;			mp[vec[i]] = i;		&#125;		sort(seq.begin() + 1,seq.begin()+1+n);//对区间排序		int ans = -1;		int cntl = 0,cntr = 0;		priority_queue&lt;PII , vector&lt;PII&gt; ,cmp&gt; pq; //优先队列		int p = 1;		for(int i = 0;i&lt;len;i++)&#123;			while(p&lt;=n &amp;&amp; seq[p].first &lt;= vec[i])&#123;//入队				if(seq[p].first == 1) cntl ++;				if(seq[p].second == m) cntr ++;				pq.push(seq[p]);				p++;			&#125;			while(pq.size() &amp;&amp; pq.top().second &lt; vec[i])&#123;//出队				PII temp = pq.top();				if(temp.first == 1) cntl--;				pq.pop();			&#125;			ans = max(ans,(int)pq.size() - min(cntl,cntr));		&#125;		cout&lt;&lt;ans&lt;&lt;endl;	&#125;	return 0;&#125;
D. Counting Rhyme题意给出有n个数的数组a，问有多少个undefinedi,j)对（(i,j)与(j,i)视为同一个对）,满足 **不存在** 任何k，使得a_k 是 a_i,a_j$  的公因子。
（1 \le n \le 10^6, 1 \le a_i \le n）
思路dp，设dp[i] 为以i为最大公因子的对有多少个。我们可以统计 有多少个数有i这个因子 ， 假设有cc个数，那么就会有undefinedfrac{cc * (cc - 1)}{2}个以i为**公因子**（不是最大公因子）的对。 我们要求最大公因子，就还需要令 dp[i] = dp[i] - \sum _{t = 2} ^{i * t &lt;= n} {dp[t * i]}。（即减去以i$的倍数为最大公因子的对的数量）。
所以最终的dp状态转移方程为dp[i] = \frac{cc * (cc - 1)}{2}- \sum _{t = 2} ^{i * t ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 906 (Div. 2)</title>
    <url>/c8f7ca88a8b7/</url>
    <content><![CDATA[[Dashboard - Codeforces Round 906 (Div. 2) - Codeforces](https://codeforces.com/contest/1890)
C. Qingshan Loves Strings 2题意给出一个n长的01串（1 \le n \le 100），每次操作向串中插入一个”01“（最多可以插入300次），问如何插入能够使得最终的串满足：对于任何0\le i < len 都有str[i] \not= str[len-1-i] 。 如果有合理的方案，则输出方案，否则输出-1。
思路首先考虑特判，每次插入”01“ 不会改变0和1的数量关系， 而最终的串要求0和1的数量一样多。所以最初的0和1的数量也需要一样多。
然后考虑如下插入策略：由两边向中间靠拢，逐个检查每个字符。为了方便起见，我们使用l和r来代表待检查的左右字符的下标，

如果str[l] \not= str[r] 则令 l++,r—,

如果str[l] = str[r] ,则代表我们需要插入”01“串来干预。如果str[l] = str[r] = '0' 那么就在第r+1位置插入”01“ ，这样新的r就是r+2，一定是1，满足str[l] \not = str[r] ,  相反，如果str[l] = str[r] = '1',则在第l个位置前插入01。


代码#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long#define OI ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);void solve() &#123;     int n;    cin&gt;&gt; n;    string str;    cin&gt;&gt;str;    if(n&amp;1 || count(str.begin(),str.end(),&#x27;0&#x27;) != count(str.begin(),str.end(),&#x27;1&#x27;)) &#123;cout&lt;&lt;-1&lt;&lt;endl;return ;&#125;     int l = 0;    int r = n - 1;    vector&lt;int&gt; ans;    while(l &lt;= r)&#123;        while(str[l] != str[r]) &#123;l++;r--;&#125;        if(str[l] == &#x27;0&#x27;)&#123;            str.insert(r+1,&quot;01&quot;);            ans.push_back(r + 1);            r += 2;        &#125;        if(str[l] == &#x27;1&#x27;)&#123;            str.insert(l,&quot;01&quot;);            r += 2;            ans.push_back(l);        &#125;        l++;r--;    &#125;    cout&lt;&lt;ans.size()&lt;&lt;endl;    for(auto p : ans) cout&lt;&lt;p&lt;&lt;&quot; &quot;;    cout &lt;&lt; endl;    return ;&#125;signed main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D. Doremy’s Connecting Plan题意给出n个节点，需要你连接一些边使得整张图中任意两点之间是可达的。 当两个节点undefinedi,j)满足如下条件时，这两个节点之间可以连边 ：\sum_{k \in S} a_k \ge c * i * j。  其中S表示为此时从i或j$ 可到达的节点集合。
如果可以通过某种连边顺序得到连通图就输出YES，否则输出NO
思路贪心思想： 每次连边都令i = 1，这样我们只需要关注j的顺序就好 。 此时连边的条件变为undefined\sum _{k \in S}a_k) + a_j \ge c * j,其中S为已经和i相连的节点。可以发现，我们何时将1与j相连，不等式右边不变，而左边则越晚相连越大。 因此我们将2~n号节点按照c * j - a_j$ 从小到大排序，然后按顺序与1号节点相连，即为最优解法。最终只需要判断通过该解法能否全部相连即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long#define OI ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);typedef pair&lt;int,int&gt; PII;int n,c;bool cmp(PII p1,PII p2)&#123;    return p1.first - p1.second * c &gt; p2.first - p2.second * c;&#125;void solve() &#123;     cin&gt;&gt;n&gt;&gt; c;    vector&lt; pair&lt;int,int&gt; &gt; vec(n+5);    for(int i = 1;i&lt;=n;i++)&#123;        cin&gt;&gt;vec[i].first;        vec[i].second = i;    &#125;    sort(vec.begin()+2,vec.begin()+1+n,cmp);//按照cmp排序    int sum = vec[1].first;    for(int i = 2;i&lt;=n;i++)&#123;        if(sum + vec[i].first &lt; vec[i].second * c)&#123;            cout&lt;&lt;&quot;No\n&quot;;            return;        &#125;        sum += vec[i].first;    &#125;    cout&lt;&lt;&quot;Yes\n&quot;;    return ;&#125;signed main()&#123;    int T;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 929 (Div. 3)</title>
    <url>/1bf0beed8499/</url>
    <content><![CDATA[[题目链接](https://codeforces.com/contest/1933)
A. Turtle Puzzle: Rearrange and Negate题意有一个长度为n的数组a，进行两步操作，第一步重新排列数组内元素的顺序， 第二部选择一个连续区间，将其中的元素取反。问进行完这两步操作后，**数组元素的值的总和** 最大是多少。
思路 很显然，把所有的负数放到一起，然后把这段区间取反即可。答案就是所有数的绝对值的和。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;  int n;  cin&gt;&gt;n;  int ans = 0;  for(int i =1;i&lt;=n;i++)&#123;    int num;cin&gt;&gt;num;    ans += abs(num);  &#125;  cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;  int T = 1;  cin&gt;&gt;T;  while(T--)&#123;    solve();  &#125;  return 0;&#125;
B - Turtle Math: Fast Three Task题意给n个数， 每次你可以选择如下操作之一 ，

删除一个数
使一个数的值加一

问最少需要几步可以使得所有数的总和是3的倍数。
思路我们考虑不进行操作时的总和， 

总和本身就是3的倍数，不需要操作，直接输出0
总和除以3之后余2， 对任意数进行加一操作即可，输出1 。
总和除以3之后余1， 那么有两种选择，一是 删除一个**“除以3余1的数”** ，二是进行两次加一操作。因此可以记录一下是否存在**“除以3余1的数”** ，如果存在就输出1，不存在就输出2

代码 solve 函数之外的代码与A题相同。
void solve()&#123;  int n;  cin&gt;&gt;n;  int cnt1 = 0;//除以3余1的数的数量  int sum = 0;  rep(i,1,n)&#123;    int num;cin&gt;&gt;num;    if(num%3 == 1) cnt1++;    sum += num;  &#125;  if(sum%3 == 0)&#123;cout&lt;&lt;0&lt;&lt;&#x27;\n&#x27;;return;&#125;  if(sum%3 == 2)&#123;cout&lt;&lt;1&lt;&lt;&#x27;\n&#x27;;return;&#125;  if(sum%3 == 1)&#123;    if(cnt1)cout&lt;&lt;1&lt;&lt;&#x27;\n&#x27;;    else cout&lt;&lt;2&lt;&lt;&#x27;\n&#x27;;     return ;  &#125;&#125;
C. Turtle Fingers: Count the Values of k题意给出 a , b, l , 那么有l = k * a^x * b ^ y  ,问k有几种可能。 
如 a = 2, b= 5,l = 20 ，那么可以选择

k = 1,x = 2,y = 1
k = 2,x = 1,y = 1
k = 4,x = 0,y = 1
k = 5,x = 2,y = 0
k = 10,x = 1,y = 0
k = 20,x = 0,y = 0

共六种可能 。
思路暴力枚举即可。需要检查当a^x （或者b^y）不再是l的因子时，及时break。 以及在枚举过程中可能出现重复的k，使用set去重即可。
代码void solve()&#123;  int a,b,l;  cin&gt;&gt;a&gt;&gt;b&gt;&gt;l;  set&lt;int&gt; ans;  for(int ax = 1;ax&lt;=l;ax*=a)&#123;//a的x次方    if(l%ax) break;    for(int by = 1;by&lt;=l;by*=b)&#123;//b的y次方      if(l%by) break;       if(l%(ax*by)) break; //如果不存在这样的整数k，就break      ans.insert(l/ax/by);    &#125;  &#125;  cout&lt;&lt;ans.size()&lt;&lt;&#x27;\n&#x27;;&#125;
D. Turtle Tenacity: Continual Mods题意给出数组a_1,a_2,...,a_n 判断是否可能存在重排后的数组b， 使得b_1\ mod \ b_2 \ mod \ ...\ mod\ b_n \not= 0。
思路我们先找到最小的数mn = MIN_{i=1}^n a_i
如果a数组中只有一个mn， 那么我们考虑把mn排在最前面，这样每次取模后得到的结果都是mn，最终的答案也就是mn，一定不为0。
考虑如果有多个mn，那么我们必须用另一个数 num(num \in a) 来取模 mn, 从而得到一个比mn更小的数t = num \ mod\ mn， 借此t 变成了新的最小的数，并且一定唯一。
因此只要存在一个数，他不是mn的倍数，我们就可以让他作为num，这样就可以使得t不为0 ，最终使得答案是t。

总的来说，决策思路为：如果最小数mn的数量大于1，并且不存在num使得num不是mn的倍数，就无解，其他情况均有解。
代码void solve()&#123; 	int n;	cin&gt;&gt;n;	vector&lt;int&gt; a(n+5);	int mn = INF;	rep(i,1,n) &#123;cin&gt;&gt;a[i];mn = min(mn,a[i]);&#125;	bool flag = 0;	rep(i,1,n)&#123;if(a[i]%mn != 0) flag = 1;&#125;	int cnt = 0;	rep(i,1,n)&#123;if(a[i] == mn) cnt++;&#125;	if(flag == 0 &amp;&amp; cnt&gt;=2)&#123;		cout&lt;&lt;&quot;NO\n&quot;;	&#125;else cout&lt;&lt;&quot;YES\n&quot;;&#125;
E - Turtle vs. Rabbit Race: Optimal Trainings题意给出n个区间，他们从左到右并列相接。长度分别为a_1,a_2,...,a_n ， 现在你会选择其中相邻的几个区间， 假设为第l 个到 第r  个区间， 那么你就相当于要学习undefinedsum _{i=l}^r a_i天， 第一天你的分数增加u， 第二天增加u-1, ... , 第i天增加u -i + 1$ , 如果你学的天数过多，可能在某一天增加的分数为负数。 
接下来有多组询问， 每次给出 l和u ,你需要找到一个r， 使得你得到的总分数最大。 如果存在多个r 使得分数最大， 那么输出最小的r。
思路我们可以发现，当学习u天过后， 再学习会减少总分数。 我们维护一个前缀和数组sum， 那么我们只需要找到一个r，使得sum[r]-sum[l] 与 u的差的绝对值尽可能小 。 而由于a是正整数， 因此sum数组是单调递增的，我们在sum数组中使用二分查找位于sum[l]+u 附近的两个位置，然后选出其中更靠近u的即可。
代码注意使用lowber_bound寻找的r下标可能会超出n，应该取r = min(r,n)
找出的最终的r可能会比l要小（因为进行了r - 1操作） ， 因此最终还要取r = max(r,l)
可以计算出两个r的
void solve()&#123;	int n;	cin&gt;&gt;n;	vector&lt;int&gt; a(n+5);	vector&lt;int&gt; sum(n+5);	rep(i,1,n) cin&gt;&gt;a[i];	rep(i,1,n) sum[i] = sum[i-1] + a[i];	int q;	cin&gt;&gt;q;	while(q--)&#123;		int l,u;		cin&gt;&gt;l&gt;&gt;u;		int r = lower_bound(sum.begin(),sum.begin()+1+n,sum[l-1]+u) - sum.begin();		r = min(r,n);		int cnt1 = sum[r] - sum[l-1];		int cnt2 = sum[r-1] - sum[l-1];		int score1 = (u + u-cnt1)*cnt1 / 2;		int score2 = (u + u-cnt2)*cnt2 / 2;		if(score2 &gt; score1) r--;		r = max(r,l);		cout&lt;&lt;r&lt;&lt;&#x27; &#x27;;	&#125;	puts(&quot;&quot;);&#125;
F - Turtle Mission: Robot and the Earthquake题意在一个n*m的地图中， 你最初位于undefined0,0)处，你需要到达地图的右下角(n-1,m-1)$ 。但是地图上会有一些石头， 他们每单位时间都会向上**循环移动**一格，（**循环移动**指的是当移动出地图边界时，会出现在地图的另一侧） 
保证最右边一列不存在石头。
你每次可以选择向 **上，下，右**三个方向移动。其中上下方向为循环移动。
如果你向下移动，那么由于石头在向上移动， 如果你的下方两格中存在石头，你就会撞上石头。
![move1](https://espresso.codeforces.com/54b91480f21e9db9b3082078e8c3f561bbc98d16.png)
同样，如果你向右移动，并且右下方有石头，也会撞上石头
![](https://espresso.codeforces.com/fc36b41ba5b0aaf6e7cb0cd14e3d7753ff8ce551.png)
问能否到达终点，如果能就输出最小步数，不能则输出-1
思路机器人到达最后一列后，没有了石头，就很好办了。所以我们重点考虑机器人如何最快地到达最后一列。
由于每次石头都向上移动， 并且机器人和石头都是循环移动，因此我们可以认为石头不动，而机器人向下移动。这样机器人本身的向下移动就变成了向下移动两格，机器人的向右移动变成了向右下移动。 
由此，我们就将本题的重点转化为了终点为最右一列的任意一点，起点为(0,0) 的广度优先搜索 。 于是我们使用队列来找到最少步数，以及此时的坐标（相对石头的坐标）。由于终点不会像石头那样不断向上移动， 因此每走一步，终点都相对于石头**向下移动了一格** 。
此时我们可以得到当前位置相对于石头的坐标为undefinedx,m-1)，总共走了step步， 此时终点位于((n-1+step)\ mod \ n,m-1)$ 。
设此时终点的横坐标为pos,即 pos = (n-1+step)\ mod \ n 。这时我们可以选择两种方法到达终点，直接到达，花费abs(x-pos)时间， 或者穿越边界再到达终点，花费n-abs(x-pos) 。二者取min即可。
代码需要注意，不能像普通的bfs走迷宫一样，直接将墙壁位置的vis设置为1来省去mp数组：
考虑循在同一列循环的情况， 可能发生如下情况：现在位于undefined3,1)，下一步是(3,3)，并且在上一次循环时已经走过了(3,2)。那么此时vis[3][2]等于1 ，并且可以到达。  
而vis[3][2]=1还有一种可能是(3,2)处有一个石头，那么反而又不能到达。因此我们的vis[3][2]=1$ 出现了两种不同的结果，这是不被允许的。
int mp[1005][1005];int vis[1005][1005];struct Node&#123;    int x,y;    int step;&#125;;void solve()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    rep(i,0,n) rep(j,0,m)&#123;mp[i][j] = vis[i][j]=0;&#125;    queue&lt;Node&gt; q;    rep(i,0,n-1) rep(j,0,m-1) cin&gt;&gt;mp[i][j];    q.push(&#123;0,0,0&#125;);    vis[0][0] = 1;    while(q.size())&#123;        int x = q.front().x;        int y = q.front().y;        int step = q.front().step;        if(y == m-1) break;        q.pop();        int xx = (x+1)%n,yy = y + 1; //xx表示向下移动一格时的坐标，yy则是向右移动一格        if(mp[xx][yy]==0) &#123;            if(vis[xx][yy]==0)&#123;                q.push(&#123;xx,yy,step+1&#125;);                vis[xx][yy] = 1;            &#125;        &#125;        int xx2 = (x+2)%n;//xx2表示向下移动两格时的坐标        if(mp[xx][y]==0&amp;&amp;mp[xx2][y]==0)&#123;            if(vis[xx2][y]==0)&#123;                q.push(&#123;xx2,y,step+1&#125;);                vis[xx2][y] = 1;            &#125;                        &#125;    &#125;    if(q.empty()) &#123;cout&lt;&lt;-1&lt;&lt;&#x27;\n&#x27;;return ;&#125;    int step = q.front().step;    int x = q.front().x;    int pos = (n-1+step)%n;    int ans = step + min(abs(pos-x),n-abs(pos-x));    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 930 (Div. 2)</title>
    <url>/91f678938e53/</url>
    <content><![CDATA[Codeforces Round 930 (Div. 2)
[题目链接](https://codeforces.com/contest/1937)
A. Shuffle Party题意给出一个数组a_1,a_2,...,a_n 起初a_i = i ，之后定义swap(k) 操作为 : 找到最大的，不等于k的因子d ，交换a_d和 a_k 。
下面令i = 2,3,...,n ，依次进行swap(i) ，问最终数值1会在哪个位置。
思路数值1会随着不断运行swap来移动位置，我们可以观察1的移动轨迹。
于是我们模拟一下操作会发现， i = 2时， swap(2)=swap(a_1,a_2) 此时1移动到了位置2 。接下来若想要让位置2发生交换，那么就必须找到一个最小的k，使得这个k所对应的d恰好是2 。 并且k尽可能地小。 于是我们想到了2的2倍4 。 下一步数值1便从位置2 移动到了位置4。接下来就是4的2倍即8， 数值1又从位置4移动到了位置8 。 这样循环往复，直到数值1移动到了2^j , 并且满足2^j \le n < 2^{j+1} 。数值1便无法移动，此时就是他的最终位置。
代码找到小于n的最大的2的次幂即可。
#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	int ans = 1;	for(int j = 1;j&lt;=40;j++)&#123; //枚举2的j次方		if(ans*2&gt;n)&#123;cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;return ;&#125;		ans *= 2;	&#125;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
B. Binary Path题意有一个2*n的 01地图，一个蚂蚱从undefined1，1)开始走，终点位于(2,n)$  。每次可以**向右或者向下走** ，蚂蚱走到终点后，会形成一个路径，问这个路径的字典序最小情况是什么， 以及有多少种走法可以出现这种最小字典序的路径。
思路刚开始看错题了呜呜呜
为了使字典序最小，我们可以总结出如下几个策略：

如果右边的数和下边的数 ， 一个是0，而另一个是1，那么走0那个方向一定字典序更小。

如果右边的数和下边的数相等， 那么走右边方向，因为一旦向下走到第二行走便不能回第一行，而在第一行则可以随时转去第二行。


如果很难理解策略2，可以尝试理解一下这个例子：
000111011111 
当位于起点时，右边和下边都是0 ，但此时若向下走，则之后只能向右走而导致最终路径为0011111 ，若向右走则是0001111 。
于是我们便得出了最优解的路线，再考虑这种方案数：
我们可以发现只有当已经走到了第n列，或者下方为0并且右方为1时， 会选择向下走。那么我们假设在i = p 时选择了向下走。
那么多种方案的出现仅有可能是由于可以提前选择向下走(在p-1,p-2,...时选择了向下走)，并且路径完全相同。
于是每当 a[0][j] == a[1][j-1] 便可以选择提前一格向下走，从而增多一种方案。于是总的方案数变为了: 对于j = k,k+1,...,p-2,p-1 , 都有a[0][j] == a[1][j-1]，而k尽可能小来使得j的可取数量尽可能多 。即在p之前的一些连续格子中，有多少个格子满足 **右边和下边的数相等** 。
代码在实现代码时，有一些可能会有帮助的小技巧。

我们使用flag作为当前所在的行，flag = 0表示当前位于第一行，flag = 1表示当前位于第二行。循环枚举i从1到n表示列，于是求路径时便可以用 s += a[flag][i] 来得到。

我们可以通过比较 a[0][i+1]和a[1][i] 的大小关系来进行操作 。 

如果a[0][i+1]>a[1][i] 则表示需要向下走，于是便可以设置flag = 1。 但我们发现当i  = n时不论如何都要向下走，于是我们不妨提前将a[0][n+1]设置为2，表示无论a[1][n] 为何值，此时a[0][n+1]>a[1][n] 都会成立，便选择了向下走。
而向下走时，i并不会变化，但for循环会使得i每次都加1，于是我们可以使用 i-- 来抵消每次for循环产生的i++

我们用cnt表示已经出现几个右等于下 的格子了，如果a[0][i+1] = a[1][i] ，那么就让cnt++

如果a[0][i+1] < a[1][i] ，那么我们就需要重置cnt为0 。




下面是完整核心代码（只有solve()部分，其他部分和A题相同 ，所以如果不知道rep是什么可以看A题中的define声明）
void solve()&#123;	int n;cin&gt;&gt;n;	string a[2];	cin&gt;&gt;a[0]&gt;&gt;a[1];	a[0] = &quot; &quot; + a[0];a[0]+=&#x27;2&#x27;;	a[1] = &quot; &quot; + a[1];	string ans;	int p = 1;	int cnt;	bool flag = 0;	rep(i,1,n)&#123;		ans+=a[flag][i];		if(!flag)&#123;			if(a[0][i+1]&gt;a[1][i])&#123;				flag = 1;i--;			&#125;else if(a[0][i+1]&lt;a[1][i])&#123;				cnt=0;			&#125;else cnt++;		&#125;	&#125;	cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;	cout&lt;&lt;cnt+1&lt;&lt;&#x27;\n&#x27;;&#125;
C. Bitwise Operation Wizard题意这是一个交互题，有一个长度为n的数组pundefinedp_1,p_2,…,p_n)，他的n个元素分别为(0,1,2,…,n-1)排列顺序未知。每次询问你可以提供四个下标(a,b,c,d)裁判会回应你p_a | p_b和p_c | p_d之间的大小关系（即&lt;.=.&gt;)  现在需要你在询问至多3*n次后， 得到一对下标i,j，满足p_i \oplus p_j最大化。 （\oplus$ 表示按位异或）
思路我们考虑p_i \oplus p_j 最大为多少。 较容易得知 ，若n-1的二进制表示有k位。 那么最大值就是这k位全部为1。  即整个数组中的最大数**mx** ，与另一个数num的异或。 接下来我们分别找这两个数。 
为了找num， 我们发现这个数就是在这k位中，对mx的各位取反得到的数。 （如若mx = 10100_{(2)} 那么num = 01011_{(2)})
先找到最大值，我们发现可以令a = b , c = d 这样裁判就会明确指出某两个数的大小关系。 于是我们可以这样子枚举整个数组，进行挨个儿比较。就可以用n-1 次确定 **最大数** 所处的位置。
for(int i = 1;i&lt;=n-1;i++)&#123;    cout&lt;&lt;&quot;? &quot;&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;endl;    char ch;cin&gt;&gt;ch;    if(ch == &#x27;&lt;&#x27;) mx = i;&#125;
之后我们找所有的满足p_i | mx 为最大（即k位全是1） 的数的集合。 他们一定满足了对于mx上数位为0的位置，num的那个位置一定为1 。
我们使用vec来记录数据，每当遇到更大的p_i | mx 就清空vec并放入p_i ,如果遇到了相等的数，就继续向vec中装入。
这样就可以在n次询问下得到所有的满足对于mx上数位为0的位置，num的那个位置一定为1 的数，那么我们为了发现，在mx中数位为1的位置上，num必须是0才能保证二者异或得到1。 也就是说要在vec中找到0最多的那个数，也就是最小的那个数。
于是我们可以在vec.size() - 1次询问下，得到vec中最小的数mn。
于是num就是mn，我们的最终答案就是 mn和mx。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	int mx = 0;	for(int i = 1;i&lt;n;i++)&#123;		cout&lt;&lt;&quot;? &quot;&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;endl;		char ch;		cin&gt;&gt;ch;		if(ch == &#x27;&lt;&#x27;) mx = i; 	&#125;	int p = 0;	vector&lt;int&gt; vec;	for(int i = 0;i&lt;n;i++)&#123;		cout&lt;&lt;&quot;? &quot;&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;p&lt;&lt;&#x27; &#x27;&lt;&lt;mx&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;endl;		char ch;		cin&gt;&gt;ch;		if(ch == &#x27;&lt;&#x27;) &#123;vec.clear();p = i;vec.push_back(i);&#125;		if(ch == &#x27;=&#x27;) &#123;vec.push_back(i);&#125;	&#125;	int mn = 0;	mn = vec[0];	for(auto t : vec)&#123;		cout&lt;&lt;&quot;? &quot;&lt;&lt;mn&lt;&lt;&#x27; &#x27;&lt;&lt;mn&lt;&lt;&#x27; &#x27;&lt;&lt;t&lt;&lt;&#x27; &#x27;&lt;&lt;t&lt;&lt;endl;		char ch;		cin&gt;&gt;ch;		if(ch == &#x27;&gt;&#x27;) &#123;mn = t;&#125;	&#125;	cout&lt;&lt;&quot;! &quot;&lt;&lt;mn&lt;&lt;&#x27; &#x27;&lt;&lt;mx&lt;&lt;endl;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
D]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 931 (Div. 2)</title>
    <url>/671b7bf0f727/</url>
    <content><![CDATA[[题目链接 -  Codeforces Round 931 (Div. 2)](https://codeforces.com/contest/1934)
A. Too Min Too Max题意给出一个数组， 现在要你选择四个下标i,j,k,l , 问|a_i - a_j|+|a_j - a_k|+|a_k - a_l|+|a_l - a_i| 最大是多少。（i , j,k,l 必须互不相同）
思路题目要求的其实就是选出四个数组成一个环，使得相邻两个数的差的和最大。
于是我们先探究 ： 如果选出了某四个数，如何调整他们在环中的顺序能使得总和最大。 不难想到， 将较大的两个数放在第一和第三位， 较小的两个数放在第二和第四位时， 得到的结果最大。 此时为(a_i - a_j) +( a_k - a_j )+ (a_k - a_l)+(a_i - a_l) ，即2*(a_i + a_k - a_j -a_l) 
第二步我们考虑如何选择这四个数能使得结果最大。 很明显我们需要尽可能让 较大的两个数a_i,a_k 更大，较小的两个数a_j.a_l更小。
于是对于整个数组，选出最大的两个数，以及最小的两个数，就可以得到最优结果。
对数组a进行排序， 就得到了最终结果为 2*(a_n + a_{n-1} - a_1 - a_2)
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	vector&lt;int&gt; a;	rep(i,1,n)&#123;int num;cin&gt;&gt;num;a.push_back(num);&#125;	sort(a.begin(),a.end());	cout&lt;&lt;2*(a[n-1]+a[n-2]-a[0]-a[1])&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
B. Yet Another Coin Problem题意现在有一些面值为1,3,6,10,15 的硬币 ， 问如何选择各个硬币的数量，使得总面值恰好为n，并且硬币的总数量最少。
undefined1 \le n \le 10^9)$
思路我们观察这些硬币的面值，可以发现3,6,15 都是3的倍数。而另一个大面值硬币又可以表示为10 = 3*3+1 。于是我们有如下策略：

尽可能多地选择3 ，此时可能剩下[0,2]的面值。即md = 0,1,2 , 如果md 为0，那么我们就可以将这些面值为3的硬币尽可能多地兑换为面值为15和6的硬币。
如果有剩余， 若手中面值3的硬币的数量大于等于3 ，就可以将这三个3和一个1 换成一个10。 

如果有剩余并且手中的面值3的硬币数量小于3，那么就只能用面值为1的硬币来填补这个空缺了。


代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	int md = n%3; //md是除以3后的余数	int t = n/3;// t是除以3后的结果	int ans = 0;	if(md == 2)&#123;//如果余两个,那么就尝试将一个余数和3个3结合。		if(t&gt;=3) &#123;ans++;t-=3;&#125;//成功结合		else ans++;//不能结合		md = 1;	&#125;	if(md == 1)&#123;//同理		if(t &gt;= 3) &#123;ans++;t-=3;&#125;		else ans++;		md = 0;	&#125;	//这时候md一定为0    ans += t / 5; // 能换成多少个15    t %= 5;    ans += t / 2;// 剩下的还能换成多少个6    t %= 2;    ans+=t; // 都换不成了，就用3吧    //输出答案	cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
C. Find a Mine题意和上一场的C一样，又是交互题。 给出一个n *m的网格，其中有两个位置有地雷，但你不知道他们在哪， 你最多可以询问四次。
每次提供一个坐标， 裁判会告诉你两个地雷距离这个坐标的**曼哈顿距离** 中的最小值是多少。 现在需要你在最多四次询问之后，给出任意一颗地雷的具体坐标。

**曼哈顿距离** ： 两个坐标undefinedx1 ,y1) , (x2,y2)的曼哈顿距离为|x1-x2|+|y1-y2|。对于如下5*5的网格， 点(3,3)$与所有点的曼哈顿距离如下
![picture1](https://img-blog.csdnimg.cn/direct/c973e460ff2e494a825b401370902c50.jpeg#pic_center)
思路我们发现确定一个点以及一个曼哈顿距离后 ，我们可以得到可能的范围是一个菱形。 如果我们将询问点设置在表格的一角，那么表格中可能的格子就组成了一个对角线。 于是我们询问地图的三个角，就得到了三条对角线，他们三者相交一定最多次出现两个交点。（也可能是一个）。之后我们再询问其中一个交点，如果给出的答案是0，就代表他是地雷，如果不是0，就代表另一个是地雷。
![picture2](https://img-blog.csdnimg.cn/direct/125e47c86af345418a45d7be3affd375.jpeg#pic_center)
我们可能遇到两个对角线相交没有准确格子的情况（如上图中的红对角线和蓝对角线，二者没有共同的格子）
代码这里有些地方需要讲解一下：
在代码中，先询问了左上，右下，右上三个角。得到了三个曼哈顿距离 a, b,c。
怎么求两个交点呢？ 先看左上和右上两个对角线形成的交点。假设为undefinedx_1,y_1)$ ，那么就有
x_1 - 1 + y_1 - 1 = a
m - y_1 + x_1 - 1 = c  解方程可以得到 x_1 = \frac{a+c-m+3}{2} , y_1 = \frac{a-c+1+m}{2} , 但我们发现可能会出现x和y不是整数的时候（也就是a+c-m为偶数的时候），这时候就不可取。（代码中表示为将x和y都设置为-1）
按照同样的方法
m - y_2 + x_2 - 1 = c
n-x_2 + m - y_2 = b  
可以找到另一个交点x_2 = \frac{2*m+n-b-c-1}{2} , y_2 = \frac{n+c-b+1}{2}。
#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int n,m;bool inrange(int x,int y)&#123;	if(x&lt;=n &amp;&amp; x &gt;= 1 &amp;&amp; 1&lt;=y &amp;&amp; y&lt;=m) return true;	else return false;&#125;void solve()&#123;	cin&gt;&gt;n&gt;&gt;m;	cout&lt;&lt;&quot;? 1 1&quot;&lt;&lt;endl;	int a; cin&gt;&gt;a;	cout&lt;&lt;&quot;? &quot;&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl;	int b;cin&gt;&gt;b;	cout&lt;&lt;&quot;? 1 &quot;&lt;&lt;m&lt;&lt;endl;	int c;cin&gt;&gt;c;	int x1,y1,x2,y2;	int t = a+c - (m-1);	if(t%2)&#123;x1 = y1 = -1;&#125;	else &#123;y1 = t/2+1;x1 = (a-t/2)+1;&#125;	t = b+c - (n-1);	if(t%2)&#123;x2 = y2 = -1;&#125;	else&#123;y2 = m-t/2;x2=(c-t/2)+1;&#125;	if(!inrange(x1,y1)) &#123;cout&lt;&lt;&quot;! &quot;&lt;&lt;x2&lt;&lt;&quot; &quot;&lt;&lt;y2&lt;&lt;endl;&#125;	else if(!inrange(x2,y2)) &#123;cout&lt;&lt;&quot;! &quot;&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;endl;&#125;	else&#123;		cout&lt;&lt;&quot;? &quot;&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;endl;		int d;cin&gt;&gt;d;		if(d == 0) cout&lt;&lt;&quot;! &quot;&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;endl;		else cout&lt;&lt;&quot;! &quot;&lt;&lt;x2&lt;&lt;&quot; &quot;&lt;&lt;y2&lt;&lt;endl;	&#125;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
D1. XOR Break — Solo Version题意给出操作方法为：若操作前的数值为y，那么选择一个x ，使得x]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 932 (Div. 2)</title>
    <url>/e61f0f23734b/</url>
    <content><![CDATA[A. Entertainment in MAC题意有一个字符串s和偶数n，  你可以对这个字符串进行n次操作（不能多不能少）

操作一：将s的反向字符串拼接到s的后面，比如对字符串abc进行操作会变成  abccba
操作二：将当前的字符串反转

问进行完这n次操作后，最终的字符串的字典序最小的可能是什么样子的。
思路可以发现，如果这个字符串翻转后更大（比如abc ，进行翻转后是cba 比原先更大了）,那么我们就可以进行n次翻转，这样最终的字符串就是原先的字符串，也就实现最小了。
如果这个字符串s在反转后更小了，那么我们就必须执行奇数次翻转，才能保证这个s最终是较小的。但题目中说n是偶数，所以就意味着我们必须进行至少一次拼接操作， 那么显而易见，拼接操作进行的越少越好， 因此需要翻转n-1次，然后拼接一次。 （比如bca， 如果进行偶数次翻转，那么最终的字符串前三个字符是bca ，而进行奇数次翻转时最终的字符串的前三个字符是acb 一定更小）
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    string str;    cin&gt;&gt;str;    string rs = str;    reverse(rs.begin(),rs.end());    if(rs &lt; str)&#123;        cout&lt;&lt;(rs + str)&lt;&lt;&#x27;\n&#x27;;    &#125;else cout&lt;&lt;str&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B. Informatics in MAC题意给出一个长度为n的数组a， 有a_1, a_2,...,a_n （1\le a_i \le n) , 请你给这个数组分为至少两组（每组之间的数都是连续的，所以相当于插入至少一个隔板来分组）， 并且让每组的mex都是相同的。 如果不能分出至少两组，那么就输出 -1 。
一个数组的mex表示为 这个数组中没有出现过的最小的自然数 。如mex(\{0,1,3,2\}) = 4 , mex(\{3,1,0,1 \}) = 2  。
思路我们可以先找到整个数组的mex ，我们称为mx， 这样一定可以分出一个子数组，使得他的mex 为mx , 所以我们就看能否分出两组即可。我们从左到右开始收集数组中的元素， 如果收集到了全部的[0,mx-1] 这mx个数，由于我们已经知道整个数组中不含有mx,所以这个子数组的mex一定是mx，接下来我们再按此法不断收集，每当有完整的[0,mx-1]就分一组，最后看一下能否分出至少两组即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    vector&lt;int&gt; a(n+5);    rep(i,1,n) cin&gt;&gt;a[i];    vector&lt;int&gt; cnt(n+5);    rep(i,1,n) cnt[a[i]] ++;    int mn = INF;    if(cnt[0] == 0)&#123;        cout&lt;&lt;n&lt;&lt;&#x27;\n&#x27;; rep(i,1,n) cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;&#x27;\n&#x27;;        return ;     &#125;    int mex = 0;    for(int i =0;i&lt;=n;i++)&#123;        if(cnt[i] == 0)&#123;            mex = i; break;        &#125;     &#125;    int l = 1;    vector&lt;PII&gt; ans;    set&lt;int&gt; st;    for(int i = 1;i&lt;=n;i++)&#123;        if(a[i]&lt;mex) st.insert(a[i]);        if(st.size() == mex) &#123;            ans.push_back(&#123;l,i&#125;);            st.clear();l = i+1;        &#125;    &#125;    if(ans.size() == 1) &#123;cout&lt;&lt;-1&lt;&lt;&#x27;\n&#x27;;return ;&#125;    ans.back().second = n;    cout&lt;&lt;ans.size()&lt;&lt;endl;    for(auto p : ans)&#123;        cout&lt;&lt;p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second&lt;&lt;&#x27;\n&#x27;;    &#125;    return ;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C. Messenger in MAC题意给出一个数组a和数组b， 我们可以从中取出一些数，这些数的总花费为如下公式：

\Large \sum_{i=1}^{k} a_{p_i} + \sum_{i=1}^{k - 1} |b_{p_i} - b_{p_{i+1}}|现在问保证这个花费不大于l的情况下， 最多能选出**多少个数** 。1\le n^2 \le 4*10^6
思路不难发现，如果已经确定我们选择的数之后，那么第一项undefinedLarge \sum_{i=1}^{k} a_{p_i}就是一个定值，而第二项\Large \sum_{i=1}^{k - 1} |b_{p_i} - b_{p_{i+1}}|的最小值即为MAX(b_{p_1},…,b_{p_k}) - MIN(b_{p_1},…,b_{p_k})。即最大的b减去最小的b$。
于是我们对数据按照b从小到大进行排序，我们选择出的一个数，就是他最右边数的b减去最左边数的b。
**思路一**：我们枚举左右端点，在确定左右端点后，我们只需要在这个区间中找到尽可能小的一些数，让他们相加小于l - a_l -a_r - (b_r - b_l) 即可。
在枚举右端点的时候， 使用一个优先队列来维护”总值不超过l“ ，于是就可以在O(n^2logn) 的复杂度内完成枚举所有的左右端点，每当更新一次区间， 就更新一次优先队列，当优先队列中的元素总和不满足要求时便可以快速地出队较大值的元素，从而保证优先队列中的总和满足条件的情况下，数尽可能少，数的数量尽可能多。
**思路二** ： DP， 我们令dp[i][j]表示为从i个数中我们选第一个数时视为 贡献了 a_i - b_i ，中间的数可以当作背包来选择，每次枚举j时， 我们都试图将i视为最后选择的一项来选出第j+1项，这时候就要加a_i +b_i 即要多算一个结尾贡献的b_i， 所以我们判断dp[i][j]+a[i]+b[i] \le l  如果成立， 那么就代表这种情况下是可以选出j+1 项的，于是ans = max(ans,j+1)
在枚举完j之后，我们让dp[i][1] = min(dp[i-1][1],a[i]-b[i]) , 表示在加入新的第i项后，从这i项中选择1项最小是多少。
我们还要考虑只选择一个数的情况，即当a[i] \le l 成立时，ans = max(ans,1) 
最终输出ans即可。
代码思路一
#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;struct Node&#123;    int a,b;    friend bool operator&lt;(Node n1,Node n2)&#123;        return n1.b &lt; n2.b;    &#125;&#125;;void solve()&#123;    int n,x;    cin&gt;&gt;n&gt;&gt;x;    vector&lt;Node&gt; vec(n+5);    rep(i,1,n)&#123;        cin&gt;&gt;vec[i].a&gt;&gt;vec[i].b;    &#125;    int ans = 0;    sort(vec.begin()+1,vec.begin()+1+n);    for(int i = 1;i&lt;=n;i++)&#123;        priority_queue&lt;int&gt; pq;        int sum = 0;        for(int j = i;j&lt;=n;j++)&#123;            pq.push(vec[j].a);sum+=vec[j].a;            while(pq.size() &amp;&amp; vec[j].b-vec[i].b + sum &gt; x)&#123;                sum -= pq.top();                pq.pop();            &#125;            ans = max(ans,(int)pq.size());        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
**思路二**：jiangly的代码
//***jiangly&#x27;s code ***//https://codeforces.com/contest/1935/submission/249766518#include &lt;bits/stdc++.h&gt;using i64 = long long;constexpr i64 inf = 1E18;void solve() &#123;    int n, l;    std::cin &gt;&gt; n &gt;&gt; l;        std::vector&lt;int&gt; a(n), b(n);    for (int i = 0; i &lt; n; i++) &#123;        std::cin &gt;&gt; a[i] &gt;&gt; b[i];    &#125;        int ans = 0;    //构造一个p从0~n-1的顺序列，之后按照b数组从小到大排序，就得到了一个下标的映射    std::vector&lt;int&gt; p(n);     std::iota(p.begin(), p.end(), 0);    std::sort(p.begin(), p.end(),        [&amp;](int i, int j) &#123;            return b[i] &lt; b[j];        &#125;);        std::vector&lt;i64&gt; dp(n + 1, inf);    // 这时候我们按照排好序的下标顺序作为i来访问a和b数组，就可以保证每次的i都是b[i]逐渐增大的    for (auto i : p) &#123;        for (int j = n - 1; j &gt;= 1; j--) &#123;            dp[j + 1] = std::min(dp[j + 1], dp[j] + a[i]);            //或许等价于压缩前的dp[i][j+1] = min(d[i-1][j+1],dp[i-1][j]+a[i])            if (dp[j] + a[i] + b[i] &lt;= l) &#123;                ans = std::max(ans, j + 1);            &#125;        &#125;        dp[1] = std::min(dp[1], 1LL * a[i] - b[i]);        if (a[i] &lt;= l) &#123;            ans = std::max(ans, 1);        &#125;    &#125;    std::cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin &gt;&gt; t;        while (t--) &#123;        solve();    &#125;        return 0;&#125;
D. Exam in MAC题意给出一个集合s 以及一个整数c ， 问有多少对undefinedx,y), 0\le x \le y \le c满足x+y和y-x都不在集合s$中 。
0 \le s_1 < s_2 ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 933 (Div. 3)</title>
    <url>/00ffdd51d0b6/</url>
    <content><![CDATA[[ 题目链接 - Codeforces Round 933 (Div. 3)](https://codeforces.com/contest/1941)
博客中的代码仅供参考，请勿直接提交源代码，这对提升实力毫无作用!!!
题目写一半，自己不小心把编译器搞坏了，中途又重新下载mingw呜呜呜,好在这场时间长
A. Rudolf and the Ticket题意有两个数组a和b，长度分别为n，m。即a_1,a_2,...,a_n,b_1,b_2,..,b_m 。
现要求你从两个数组中各选择一个数a_i,b_j  并且要求a_i + b_j \le k ,问有多少种选法。
思路二分查找， 对b数组排序，然后枚举a_i , 使用upperbound来在b中查找第一个大于k - a_i 的下标p，那么b数组中的区间[0,p-1]上的数都满足和a_i 相加之后小于等于k。 于是产生了p的贡献。按此理计算出总贡献即可。复杂度O(nlogn)
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,m,k;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    vector&lt;int&gt; a,b;    rep(i,1,n)&#123;        int num;cin&gt;&gt;num; a.push_back(num);    &#125;    rep(i,1,m)&#123;        int num;cin&gt;&gt;num; b.push_back(num);    &#125;    int sum = 0;    sort(b.begin(),b.end());    for(auto p : a)&#123;        int t = k - p;        sum += upper_bound(b.begin(),b.end(),t) - b.begin();    &#125;    cout&lt;&lt;sum&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B - Rudolf and 121题意现在有一个长度为n的数组a，a_1,a_2,...,a_n 要求你使用任意次如下操作，问能否使得数组a全为0 。
选择一个下标i(2 \le i \le n-1)，然后进行下面三步：

令a_{i-1} -= 1
令a_{i} -= 2
令a_{i+1} -= 1

思路贪心，观察操作可以发现，我们若想让a_1  归零， 那么就必须选择i = 2 进行操作，并且要准确地操作a_1 次。 此时a_1就一定变为了0 。更新数组,即更新a_1,a_2,a_3 。
然后我们就按照此法再令i = 3 ，进行a_2次操作，来试图将a_2 归零。 但我们发现如果某个数变成了负数，那么他永远无法变成0，因此我们就可以输出NO并结束这组样例。
如此法遍历整个数组即可。
在遍历完整个数组后，我们还无法得知a_{n-1}, a_n 是否成功清零，判断一下即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    vector&lt;int&gt; vec(n+5);    rep(i,1,n) cin&gt;&gt;vec[i];    rep(i,2,n-1)&#123;        if(vec[i-1]&lt;0||vec[i]&lt;0||vec[i+1]&lt;0)&#123;cout&lt;&lt;&quot;No\n&quot;;return ;&#125;//如果某个数变成了负数        if(vec[i-1] == 0) continue;        int t = vec[i-1];//要进行的操作次数        vec[i] -= 2 * t;        vec[i+1] -= t;        vec[i-1] -= t;    &#125;    if(vec[n-1] != 0 || vec[n]!=0)&#123;cout&lt;&lt;&quot;No\n&quot;;return ;&#125;//如果这两个数没有成功清零    cout&lt;&lt;&quot;Yes\n&quot;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C - Rudolf and the Ugly String题意如果一个字符串中存在子串map 或者 pie ，那么就说这个子串是丑陋的，否则就说它是美丽的。现在给你一个字符串，问最少需要删除几个字符才能使得字符串是美丽的。
思路我们需要拆散这个字符串中的map 和 pie ， 容易发现，如果存在某个子串是map ，那么我们删除中间的a即可，这样能够删除这里的map，并且保证不会出现新的map ,pie也是同理， 因此我们找这个字符串中存在几个map或者pie子串即可（吗？）
如果仅仅想到这一步，那么你将获得一发罚时。因为如果字符串中存在子串mapie,那么我们照此法将会删除a和i两个字符，然而直接删除p字符就可以同时拆散map和pie 。
所以最终答案应为字符串中map与pie的数量相加再减去mapie的数量
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    string str;    cin&gt;&gt;str;    int ans = 0;    for(int i = 0;i&lt;n-2;i++)&#123;        if(i&lt;=n-5 &amp;&amp; str.substr(i,5) == &quot;mapie&quot;)&#123;ans--;&#125; //每出现一个mapie就让答案减一        if(str.substr(i,3) == &quot;map&quot;) ans++;        if(str.substr(i,3) == &quot;pie&quot;) ans++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D. Rudolf and the Ball Game题意有n个人按顺时针顺序s围成一个环，标号分别为1,2,..,n , 如图：
![](https://espresso.codeforces.com/9b74f6d4c5991dacc37be972d6589d05a2c4111d.png)
起初球在第x个人的手中，下面进行m次传球。每次传球遵循如下格式：r c 其中r为一个整数，表示传球的距离。c为0 1 ? 中的一个字符 , 0表示下一步要顺时针传球， 1表示这次传球是逆时针的，?则表示这次传球不确定是顺时针还是逆时针。如上图中2号人顺时针传距离5时，传给了7，逆时针时则传给了4 。
问进行完m次传球后， 哪些人可能拿到球。
思路dp，我们使用一个数组dp记录上一步都哪些人可能获得球后，起初dp[x] = 1 ，其他值为0 。
对于每一步传球操作，根据操作情况来生成一个新的数组f表示进行完这步操作后哪些人可能会获得球。然后将f内容复制给dp之后， 清空f 。不断重复如此即可得到最终的数组。
对标号1,2,...,n 的人进行循环取模操作会比较复杂，可以考虑令所有人的标号减一，最终输出的时候通过加一来恢复原始标号。
代码还有一种存储方式是用set， 但原理相同，这里不在赘述
#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,m,x;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;    //这里的vector就等价于数组，但是支持直接赋值整个数组    vector&lt;bool&gt; dp(n+5);//老数组    vector&lt;bool&gt; f(n+5);//新数组    dp[x-1] = 1; //做了减一操作，更方便取模    rep(i,1,m)&#123;        int k;char op;        cin&gt;&gt;k&gt;&gt;op;        for(int i =0;i&lt;n;i++)&#123;            if(dp[i])&#123;                if(op !=&#x27;0&#x27;) f[(i-k+n)%n] = 1; //1和?会进行逆时针操作                if(op !=&#x27;1&#x27;) f[(i+k)%n] = 1;//0和?会进行顺时针操作                //算是一个小技巧,可以少写一个判断            &#125;        &#125;        dp = f;//令dp等于f        fill(f.begin(),f.end(),0);//清空f    &#125;    vector&lt;int&gt; ans;//记录哪些人可能获得球    rep(i,0,n-1) if(dp[i]) ans.push_back(i+1);    cout&lt;&lt;ans.size()&lt;&lt;&#x27;\n&#x27;;    for(auto p : ans)&#123;        cout&lt;&lt;p&lt;&lt;&quot; &quot;;    &#125;     puts(&quot;&quot;);&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
E. Rudolf and k Bridges题意现在有n行m列的网格a，a_{i,j} 表示第i行第j 列的海水深度 ， 保证第1列和第m列是大陆， 深度为0。
![](https://espresso.codeforces.com/f21f7d8bd805233bd6369b6f61033c76a2e8fae6.png)
对每行你可以按照如下规则建桥：
在第1列和第m列必须要有支柱。然后你可能还需要在海中树立一些柱子。需要保证不存在任何两个相邻的柱子之间的距离大于d，如果两个柱子的距离分别为i,j 那么他们之间的距离是j - i - 1 。
建造一个桥所消耗的费用为 这座桥上所有柱子**所在的海水深度加一** 的和。
现在需要你建造k个**连续**的桥。即选择一个i,i\le n-k+1，在i,i+1,...,i+k-1 行都建一个桥。问最少需要多少费用。
思路比较容易得知，对于建造不同的桥，他们的费用是互不影响的。因此我们可以分别计算这n座桥的建造费用，然后选择区间和最小的那组即可。
我们先讲在找到每行的建桥费用并存入ans数组后， 如何找这k个连续的桥（如果你已经会了就跳过）
我们对ans数组进行计算前缀和 ，存入sum中， 于是sum[i] - sum[i-k] 则表示了从第i-k+1 开始建k座桥需要的总花费。于是枚举每一个可能的i，令res为所有可能中的最小值即可。

下面来探讨如何计算建造某个桥的费用。
我们可以使用dp的思想， dp[i] 表示在第i列立下一根柱子的情况下，建好前i格最少需要多少花费，这样dp[m] 就是建造这整座桥的花费。我们dp[i] 必须由dp[i-1],dp[i-2],...,dp[i-k-1] 中的某一个转移而来，可以发现，在建造完成第i格的柱子后，不论之前的方案如何，对之后的影响都是相同的。于是我们选择这些元素中值最小的作为母状态即可。
但是如果我们直接枚举dp[i-1],dp[i-2],...,dp[i-k-1] 这些内容，那么计算一个桥的复杂度就是O(m*d) 这显然会导致超时。于是我们考虑使用数据结构来加速。
下面介绍方案一：优先队列
我们使用优先队列存储一个结构体，表示柱子的下标x以及dp[x] , 并且规定队头元素是dp[x]最小的那个，这样我们就保证可以在O(1)的时间内选出值最小的那个元素。 同时我们每次使用队头元素前都要检查队头元素是否过期（若队头元素的下标x与当前下标i 的距离超过了d ,那么它就已经过期，在之后都无法使用），如果过期，就直接出队。
通过上面的构造，我们的优先队列就满足了如下两个性质：

队头元素一定是花费最小的那个。
队头元素一定没有过期

于是我们就可以借此来知晓dp[i]的值，即dp[i] = pq.front().was + dep+1 。 其中was表示花费，dep表示第i格的深度。之后将undefinedi,dp[i])入队。 复杂度为O(mlogm)$
方案二： 单调队列
很常用的一个数据结构。我们使用一个双端队列，并维护这个队列是递增的。和上面的优先队列原理类似。我们保证队头元素一定不是过期的，如果已经过期就出队它。（若下标x和i的距离大于d，那么我们说x已经过期了），同时在入队时，我们保证入队的这个元素一定比队尾元素更大，如果违背了这个规则，我们就不断从队尾出队（这是一个双端队列，所以可以从队尾出队），等到不违背这个规则时，再入队元素。
于是我们的队列就满足了如下两个性质：

队列中的所有元素从队头到队尾单调递增，因此队头元素一定最小
队列中队头元素一定不是过期的。

于是我们就可以保证得到正确的dp[i]  ，于是就可以得到一个桥的花费，即dp[m]
代码优先队列：
#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;struct Node&#123;    int x; //下标x    int wast;//花费waste    friend bool operator&lt;(Node n1,Node n2)&#123; //用来决定优先队列的排序顺序        return n1.wast &gt; n2.wast;    &#125;&#125;;void solve()&#123;    int n,m,k,d;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;d;    vector&lt;int&gt; ans;    ans.push_back(0);    int t = n;//n还有用    while(t--)&#123;//计算这n行各自的花费        priority_queue&lt;Node&gt; pq;        int x;cin&gt;&gt;x;pq.push(&#123;1,1&#125;);//第一个一定是0,所以直接入队&#123;1,1&#125;        for(int i = 2;i&lt;=m;i++)&#123;            cin&gt;&gt;x;            while(pq.top().x+d+1&lt;i)&#123;//不断出队过期元素                pq.pop();            &#125;            if(i == m)&#123;//如果到达了河对岸                ans.push_back(pq.top().wast+x+1);//可以存答案了                break;            &#125;            pq.push(&#123;i,pq.top().wast+x+1&#125;);//入队元素        &#125;    &#125;    for(int i = 1;i&lt;=n;i++)&#123;        ans[i] += ans[i-1];    &#125;    int res = INF;    for(int i =k;i&lt;=n;i++)&#123;        res = min(res,ans[i] - ans[i-k]);    &#125;    cout&lt;&lt;res&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
单调队列(代码来自队友)：
这是[队友CSDN主页](https://blog.csdn.net/qq_45809243?type=blog)，超强！
#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;queue&gt;#define mk make_pairusing namespace std;typedef long long ll;const int maxn=105;const int maxm=2e5+5;const ll inf=1e18;int T,n,m,k,d;int a[maxm];ll dp[maxm];ll cost[maxn];int main()&#123;	cin&gt;&gt;T;	while(T--)&#123;		cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;d;		for(int bridge=1;bridge&lt;=n;bridge++)&#123;			for(int i=1;i&lt;=m;i++)cin&gt;&gt;a[i],dp[i]=inf; //初始化dp为全INF(最大值)			deque&lt;pair&lt;ll,ll&gt; &gt; q;			dp[1]=1;			q.push_back(mk(1,1));			for(int i=2;i&lt;=m;i++)&#123;				dp[i]=min(dp[i],q.front().first+a[i]+1);				while(!q.empty() &amp;&amp; dp[i]&lt;=q.back().first)q.pop_back();//保证队列单调性				q.push_back(mk(dp[i],i));				if(i-d&gt;q.front().second)q.pop_front();//保证队头不过期			&#125;//			cout&lt;&lt;dp[m]&lt;&lt;endl;						cost[bridge]=cost[bridge-1]+dp[m];//dp[m]是建这座桥的最少费用,cost直接计算了前缀和		&#125;		ll ans=inf;		for(int i=k;i&lt;=n;i++)			ans=min(ans,cost[i]-cost[i-k]);		cout&lt;&lt;ans&lt;&lt;endl;	&#125;	return 0;&#125;
F - Rudolf and Imbalance题意现在给你三个数组a,d,f , 长度分别为n，m，k，你可以从d和f中各选出一个数 d_i, f_j 然后把d_i +f_j 放入a中， 问进行**最多一次** 该操作后， a数组中的  MAX_{i=1}^{n'-1}(a_{i+1} - a_i)  最小是多少。 其中的n' 表示为进行至多一次操作之后的a的元素数量。
**保证a数组是有序的。**
思路由于我们只能插入一个数，因此只有插入到最大的那个间隙中，才能使得最大间隔变短。 因此我们可以先求出最大间隔mx和次大间隔semx ,  并找到产生最大间隔的那两个数l和r，即r - l = mx 。 假设我们找到了一个数t，来插入到l和r中间，那么整个数组a的最大间隔就 变为了 MAX(semx,abs(t-l),abs(r-t))  ， 我们设mid = \frac{l+r}{2} ，那么很明显，semx是一个定值，因此我们的t越靠近mid，便越可能得到更小的答案。于是整道题的目标就变为了找到最接近mid的那个t 。
我们对数组f进行排序， 然后枚举d中 的元素x， 使用lower_bound来从f中找到最接近mid - x 的两个值作为t的 待选项，借此更新更优的t ,得到更优的ans 。最终我们再和次大间隔semx取max即可。
需要注意的是，

注意lower _bound之后可能找到的是数组边界，此时可能会不存在其中一个待选项t。
要特殊考虑n == 2 时没有次大值semx的情况。

代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n ,m,k;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    vector&lt;int&gt; a(n+5);//数组a    for(int i = 1;i&lt;=n;i++) cin&gt;&gt;a[i];    int mx = 0,semx = 0;//a中相邻两个数的差，最大和次大    int l,r;//最大差的左项和右项    //初始化mx和semx,l,r    if(n&gt;=3)&#123;        if(a[3]-a[2]&gt;a[2]-a[1])&#123;            l = a[2],r = a[3];            mx = a[3]-a[2];            semx =a[2]-a[1];        &#125;else &#123;            l = a[1],r = a[2];            mx = a[2]-a[1];            semx =a[3]-a[2];        &#125;    &#125;else if(n == 2)&#123;        mx = a[2]-a[1];l = a[1];r = a[2];    &#125;    //找mx和semx,l,r    rep(i,3,n-1)&#123;        if(a[i+1]-a[i]&gt;mx)&#123;            semx = r - l;            mx = a[i+1]-a[i];            r = a[i+1],l = a[i];        &#125;else if(a[i+1]-a[i]&gt;semx)&#123;            semx = a[i+1]-a[i];        &#125;    &#125;    int mid = (l+r)/2;    vector&lt;int&gt; d,f;    rep(i,1,m)&#123;int num;cin&gt;&gt;num;d.push_back(num);&#125;    rep(i,1,k)&#123;int num;cin&gt;&gt;num;f.push_back(num);&#125;    sort(f.begin(),f.end());    int ans = INF;    for(auto x : d)&#123;//枚举d        int p = upper_bound(f.begin(),f.end(),mid-x) - f.begin();        if(p!=k)&#123;            int t = f[p]+x;            int newans = max(abs(l-t),abs(t-r));            ans = min(ans,newans);        &#125;if(p!=0)&#123;            int t = f[p-1]+x;            int newans = max(abs(l-t),abs(t-r));            ans = min(ans,newans);        &#125;    &#125;    if(ans &gt; mx)&#123;cout&lt;&lt;mx&lt;&lt;endl;return;&#125;    cout&lt;&lt;max(semx,ans)&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 935 (Div. 3)</title>
    <url>/8b31977ec836/</url>
    <content><![CDATA[[题目链接](https://codeforces.com/contest/1945)
A. Setting up Camp题意有一些屋子，每个屋子最多容纳三个人，有三种人，**内向人**必须一个人一个屋，**外向人**必须三个人同时一个屋子，综合人随意（一个两个三个都可）
现在有a 个内向人， b  个外向人， c 个综合人。 问最少需要多少个屋子才能满足所有人的要求，如果无论如何都不能满足那么就输出-1
思路我们很容易发现， 对于内向人，不会导致输出-1.因为给他们一人一个屋子即可。 对于综合人同样不会导致输出-1. 只有当外向人在引入几个综合人之后，仍然无法成为3的倍数时，会导致出现-1的情况。 换成代码语言即为b\%3+c=sum[x] \&\& sum[n]-sum[x]>=n-x-sum[n]+sum[x]
我们直接枚举|\frac{n}{2} - i| 的值，然后推算出两个i ， 分别判断是否满足情况。
代码def solve():    pass    n = int(input())    lst = [0]    lst += [int(x) for x in input()]    sum = [0]*(n+2)    ans = []    for i in range(1,n+1):        sum[i] = sum[i-1] + lst[i]    for x in range(0,n+1):        if x-sum[x]&gt;=sum[x] and sum[n]-sum[x]&gt;=n-x-sum[n]+sum[x]:           ans.append(x)    dis = ans    mn = 9999999    for i in range(len(ans)):        mn = min(mn,abs(n/2-ans[i]))    for i in range(len(ans)):        if(abs(n/2-ans[i]) == mn):            print(ans[i])            break###########for _ in range(int(input())):    solve()
D. Seraphim the Owl题意同学A想插队 ，他前面有n个人， 他想要查到前m人中 ，现在有两个数组 a,b 。若同学A从位置y插队到位置x那么他就需要支付a_x的金币，以及给中间所有人b_i(x]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 936 (Div. 2)</title>
    <url>/6f9f5c409815/</url>
    <content><![CDATA[[题目链接](https://codeforces.com/contest/1946)
A. Median of an Array题意给出一个数组a，每次操作可以让其中一个数增加一。 问最少需要几次操作能改变中位数的值。
长度为n的数组a的中位数表示为，令b是a排完序后的数组，那么b_{\lceil \frac{n}{2}\rceil} 即为a的中位数。
思路假设中位数为m ，那么我们就需要让最终的中位数变为m+1 。做法就是对一些值为m 各进行一次操作。我们假设小于等于m的数的数量为cnt , 起初一定有cnt \ge \lceil \frac{n}{2}\rceil为了让m+1是中位数，就必须cnt< \lceil \frac{n}{2}\rceil 。 每次操作能使得cnt减少1 。于是我们需要的操作数量就是cnt - \lceil \frac{n}{2}\rceil + 1
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    map&lt;int,int&gt; mp; //每个数都出现了几次    int n;    cin&gt;&gt;n;    rep(i,1,n)&#123;        int num;cin&gt;&gt;num;        mp[num] ++;    &#125;    int cnt = 0;    for(auto p:mp)&#123;        if(cnt+p.second &lt; (n+1)/2)&#123;            cnt += p.second;        &#125;        else&#123;//这时候找到了中位数，并且数量是cnt            cout&lt;&lt;cnt + p.second - (n+1)/2 + 1&lt;&lt;endl;            return;        &#125;    &#125;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B. Maximum Sum题意给出一个初始长度为n的数组a 。
对于每步操作，你可以选出其中一个子数组，将这个子数组的总和作为一个新项，插入到整个数组的任意位置。(可以选择空的子数组，这样就插入了一个0)
按照如上操作进行k次后， 问整个数组的总和最大是多少。
思路首先介绍选取策略：我们选取总和最大的子数组（最大区间和）作为第一步操作。这样得到的第一个sum一定是最大的。接下来我们将sum放在这个子数组的末尾，下一次选取子数组时，我们就可以多加上新的那个数(如果新增的数小于0，那么肯定是不能加的，直接令子数组设置为空，sum就变为了0），依次类推共进行k次即可。
例如：
3 32 2 8
我们进行的三步操作为
2 2 8## 选取[2 2 8]2 2 8 12## 选取[2 2 8 12]2 2 8 12 24## 选取[2 2 8 12 24]2 2 8 12 24 48
可以发现，如果我们新增了一个sum在这个子数组之后，下一次就会是sum* 2 ，也就是每次新增的都是上一次的两倍。最终整段子数组的数值总和即为sum_0 * 2^{k} （sum_0表示最初子数组的总和，k表示操作次数），那么整个数组的总和就是SUM + sum_0(2^k - 1) ，其中SUM表示整个初始数组的总和。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int mod = 1e9+7;int qpow(int x,int n)&#123; //快速幂    int ans = 1;    while(n)&#123;        if(n&amp;1) ans = ans * x % mod;        x = x * x % mod;        n &gt;&gt;= 1;    &#125;    return ans;&#125;void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    vector&lt;int&gt; dp(n+5,-INF);//dp数组用来找最大区间和    vector&lt;int&gt; num(n+5);    int sum = 0;    rep(i,1,n)&#123;//求整个数组的和        cin&gt;&gt;num[i];        sum += num[i];    &#125;    rep(i,1,n)&#123;        dp[i] = max(num[i],dp[i-1]+num[i]);    &#125;    int mx = -INF;    rep(i,0,n)&#123;        mx = max(mx,dp[i]);    &#125;    //此时的mx就是最大区间和,也就是sum0    int ans = sum;//    if(mx &gt; 0) ans+=mx%mod*qpow(2,k)-mx;//这里记得要对mx取模再乘2的次幂    cout&lt;&lt;(ans%mod+mod)%mod&lt;&lt;&#x27;\n&#x27;;//记得取模&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C. Tree Cutting题意给你一个树，让你删掉其中k条边，于是就得到了k+1 个子树，现在问在进行完k次删边后，**这些子树的大小(即子树中节点的数量)的最小值x** ，最大可能是多少。
思路最小的最大值（或者最大的最小值），一般情况都是二分答案。
check函数为: 使用dfs遍历整棵树，来检索最多能分成几棵子树，如果分出的子树数量大于等于k+1 那么就是True，否则就是False
对于dfs函数，我们可以使用一个返回值来表示**当前节点下的子树能贡献多少个节点给祖先** 。

如果当前收获的节点数大于等于x，那么就意味着当前这棵子树可以独立地构成一个合格的子树。于是我们切断他和父亲的边，让答案加一。并且return 0;
如果当前收获的节点数cnt小于x，那么就不能独立构成一个合格的子树，就需要将所有的节点都传递到父亲节点。也就是return cnt;

代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;const int maxn = 1e5+5;vector&lt;int&gt; ed[maxn];int n,k;vector&lt;int&gt; vis(maxn);int ans;int dfs(int now,int x)&#123;    int sum = 1;    vis[now] = 1;    for(auto v : ed[now])&#123;        if(!vis[v])&#123;            vis[v] = 1;            sum += dfs(v,x);        &#125;    &#125;    if(sum &gt;= x) &#123;ans ++;return 0;&#125;    else return sum;&#125;bool check(int x)&#123;    //初始化一些变量为0    ans = 0;    rep(i,1,n) vis[i] = 0;    //dfs求一下ans的值    dfs(1,x);    return ans&gt;=(k+1);&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;k;    rep(i,1,n) ed[i].clear();    rep(i,1,n-1)&#123;        int u,v;cin&gt;&gt;u&gt;&gt;v;        ed[u].push_back(v);        ed[v].push_back(u);    &#125;    int l = 1,r = n;    while(l&lt;r)&#123;        int mid = (l+r+1)/2;        if(check(mid)) l = mid;        else r = mid-1;    &#125;    cout&lt;&lt;l&lt;&lt;endl;    return ;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D. Birthday Gift题意给你一个长度为n的数组a,即 a_1,a_2,...,a_n 。 现在你需要将他们划分为一些部分，来使得  **每一部分的异或和** 全部**按位或** 起来后的答案ans 满足ans\le x 。问你最多能划分多少部分。如果无解就输出undefined1$。
即找到k组undefinedl,r)对， 使得l_i \le r_i并且r_i + 1 = l_{i+1}, l_1 = 1,r_k = n。满足(a_{l_1} \oplus a_{l_1+1}\oplus … \oplus a_{r_1})|(a_{l_2} \oplus a_{l_2+1}\oplus … \oplus a_{r_2})|…|(a_{l_k} \oplus a_{l_k+1}\oplus … \oplus a_{r_k}) \le x $
问k最大是多少。
思路我们用sum_i表示**a的前i项的异或和**。即sum_i = a_1 \oplus a_2 ...\oplus a_i ，那么原式就变为了undefinedsum_{r_1}\oplus sum_{l_1-1}) | (sum_{r_2}\oplus sum_{l_2-1})|…|(sum_{r_k}\oplus sum_{l_k-1}) \le x 。 这个式子还是有些麻烦，我们发现他还等价于sum_{r_1} | sum_{r_2}|…|sum_{r_k} \le x$ 。于是我们就把区间异或的或，变成了单点的或。
有一点需要注意的是，sum_n 是必选项。
于是我们考虑x的每一位，

如果这一位是0， 那么就不做改变，直接看有多少个sum_i满足sum_i | x == x 。
如果这一位是1，那么我们就可以将这一位置为0，然后将所有较小位置为1，我们设处理后的x为xx，那么有xx = (x - (1]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 958 (Div. 2)</title>
    <url>/c72741a50d03/</url>
    <content><![CDATA[[比赛链接https://codeforces.com/contest/1988](https://codeforces.com/contest/1988)
A. Split the Multiset题意起初S中只有一个数字 n , 你每次操作可以选择S中的一个任意一个数x，将他拆分成最多k个数，并且这k个数的和仍为x ，问最少需要多少次拆分，能让S中只剩下n个1
思路可以发现，每次拆分出k-1  个 1 效率最高。 所以对于n,k ,我们有总拆分次数为undefinedlceil \frac{n-1}{k-1} \rceil$ 。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    cout&lt;&lt; (n -1 + k - 2) / (k - 1)&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B. Make Majority题意给你一个长度为n的01序列a，你可以进行任意次如下操作：

选择两个数l,r (1\le l\le r \le |a|)   , 其中 |a| 表示a的长度。
将这段区间替换为c， (如果选择的区间中1的数量**大于**0的数量，那么c=1，否则c=0）

问能否在进行一定次数的操作后， 使得a变为 1
思路首先我们可以先选择连续的0 ， 这样这些连续的0就一定会变为一个0 。这样每个0周围都会有1~2个1 。 我们说此刻的序列为a'
于是我们每次可以选择一个0，以及它旁边的两个1， 这样这三个数就会被替换为。不断循环往复， 每次替换都会减少一个1以及一个0。  因此我们直接统计a' 中1和0的数量，若1的数量更多那么就输出Yes,  否则输出No 
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    string str;    cin&gt;&gt;str;    string s;    rep(i,0,n-1)&#123;        if(str[i] == &#x27;0&#x27;)&#123;            s += str[i];            while(i&lt;n &amp;&amp; str[i] == &#x27;0&#x27;) i++;        &#125;        if(i == n) continue;        s += str[i];    &#125;    int c0 = 0,c1 = 0;    for(auto p : s)&#123;        if( p == &#x27;0&#x27;) c0 ++;        else c1 ++;    &#125;    if(c0 &gt;= c1) cout&lt;&lt;&quot;No\n&quot;;    else cout&lt;&lt;&quot;Yes\n&quot;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C. Increasing Sequence with Fixed OR题意给你一个数n , 请你构造一个数列a , 使得1 \le a_1 < a_2 < ... < a_k  , 并且对于任意的2\le i \le k 都有 a_{i-1} | a_i = n 其中|表示按位或运算。要求你构造的k尽可能大。
思路因为要求相邻的数按位或都是n， 所以对于任意的 a_i ，一定有a_i | n = n，  即a_i 一定是从二进制的n中选择一些1来组成。于是我们便只需要考虑n为全1的情况即可（因为n中的数位0在 a_i 中一定为0 )

因为a_i  | a_{i+1} = n 所以对于某一位j ,若a_{i,j} = 0 那么 一定有a_{i+1,j} = 1  。
再根据另一个条件1 \le a_1 < a_2 < ... < a_k ，我们可以得知，当a_{i,j} = 1 时 ，那么a_{i+1,j},a_{i+2,j},...,a_{k,j} 都是1。

于是我们便可以这样构造我们的数列：01111,10111,11011,11101,11110,11111 , 于是若n的二进制中中有t个1，那么我们构造的数列长度便为t+1 . 构造方法即 **让0从高到低地位于t个位中的每一位，最后再加上n本身**。
需要注意的是，如果n是二进制数， 即n中只有一位1，那么答案是1，数列的值为n本身。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    vector&lt;int&gt; v;    for(int i = 0;i&lt;63;i++)&#123;        if((1ll&lt;&lt;i) &amp; n)&#123;            v.push_back(i);        &#125;    &#125;    if(v.size() == 1) &#123;cout&lt;&lt;1&lt;&lt;&#x27;\n&#x27;&lt;&lt;n&lt;&lt;&#x27;\n&#x27;;return ;&#125;    cout&lt;&lt;(v.size()+1)&lt;&lt;endl;    for(int i = v.size()-1;i&gt;=0;i--)&#123;        int t = n;        t ^= (1ll&lt;&lt;v[i]);        cout&lt;&lt;t&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;n&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D. The Omnipotent Monster Killer题意有n头怪兽， 每个怪兽都有其自己的攻击力，他们通过n-1条边连成一个树。 你可以进行足够多的回合。在每个回合中， 会进行如下过程：

所有活着的怪兽都对你造成一次等同于其攻击力的伤害
你选择一些怪兽（这些怪兽不能相邻），将他们杀死

问最少受到多少伤害，你才能够杀死所有的怪物。
思路首先可以发现，对于n头怪兽，我们最多需要 log_2n 个回合就可以在最优解的情况下将他们全部击杀。（考虑完全树）。
这样对于n < 3 * 10^5 ,总回合数最多19个回合就可以将他们全部击败。
于是我们考虑树形dp，  设定节点1为dp[i][j] 表示节点i在第j 个回合被杀死，那么以它为根节点的子树所造成的总伤害。
于是有：
最终答案：ans = min_{1\le j \le 19} dp[1][j] 
状态转移：dp[i][j] = \sum_{v\in sons(i)} min_{1\le k\le 19 \& k \not=j} dp[v][k] + ack[i] * j
复杂度O(n * log^2n)
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int dp[300005][25];int ack[300005];vector&lt;int&gt; edge[300005];void dfs(int u,int fa)&#123;    for(int i = 1;i&lt;=22;i++)&#123;        dp[u][i] = INF;    &#125;    for(auto p : edge[u])&#123;        if(p == fa) continue;        dfs(p,u);    &#125;    for(int j = 1;j&lt;=22;j++)&#123;        bool f = 0;        dp[u][j] = 0;        for(auto p : edge[u])&#123;            if(p == fa) continue;            f = 1;            int mn = INF;            for(int k = 1;k&lt;=22;k++)&#123;                if(k == j) continue;                   mn = min(mn,dp[p][k]);            &#125;            dp[u][j] += mn;        &#125;        dp[u][j] += ack[u] * j;    &#125;    return ;&#125;void solve()&#123;    int n;    cin&gt;&gt;n;    rep(i,1,n) cin&gt;&gt;ack[i];    if(n == 1) &#123;cout&lt;&lt;ack[1] &lt;&lt; endl; return ;&#125;    rep(i,1,n) edge[i].clear();    for(int i = 1;i&lt;n;i++)&#123;        int x ,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    dfs(1,0);    int ans = INF;    for(int i= 1;i&lt;=22;i++)&#123;        ans = min(ans,dp[1][i]);    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
优化O(nlogn)对于递推过程，如果我们用前缀/后缀 数组记录 前缀最小值，以及后缀最小值。
即pre[u][i] = MIN_{1\le j\le i} dp[u][j] \\lst[u][i] = MIN_{i\le j\le 19} dp[u][j]
于是我们在递推时就可以直接写dp[i][j] = \sum_{v\in sons(i)} min(pre[v][j-1],lst[v][j+1]) + ack[i] * j 。
我们就可以省去一层循环。 实现复杂度O(nlogn)
#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int dp[300005][25];int ack[300005];vector&lt;int&gt; edge[300005];int pre[300005][25];int lst[300005][25];void dfs(int u,int fa)&#123;    for(int i = 1;i&lt;= 19;i++)&#123;        dp[u][i] = INF;    &#125;    for(auto p : edge[u])&#123;        if(p == fa) continue;        dfs(p,u);    &#125;    for(int j = 1;j&lt;= 19;j++)&#123;        bool f = 0;        dp[u][j] = 0;        for(auto p : edge[u])&#123;            if(p == fa) continue;            f = 1;			//直接利用前后缀求出mn            int mn = min(pre[p][j-1],lst[p][j+1]);            dp[u][j] += mn;        &#125;        dp[u][j] += ack[u] * j;    &#125;	// 求前后缀	pre[u][0] = INF;	for(int i = 1;i&lt;= 19;i++)&#123;		pre[u][i] = min(dp[u][i],pre[u][i-1]);	&#125;	lst[u][20] = INF;	for(int i =  19;i&gt;=1;i--)&#123;		lst[u][i] = min(dp[u][i],lst[u][i+1]);	&#125;    return ;&#125;void solve()&#123;    int n;    cin&gt;&gt;n;    rep(i,1,n) cin&gt;&gt;ack[i];    if(n == 1) &#123;cout&lt;&lt;ack[1] &lt;&lt; endl; return ;&#125;    rep(i,1,n) edge[i].clear();    for(int i = 1;i&lt;n;i++)&#123;        int x ,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    dfs(1,0);    int ans = INF;    for(int i= 1;i&lt;= 19;i++)&#123;        ans = min(ans,dp[1][i]);    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
优化O(n)如果再细心一些，可以发现，对于一个节点i , 设它的度数为deg_i ， 它会在第b_i 轮被杀死，  那么一定有b_i \le deg_i 。于是我们没必要对每个结点都循环到19, 只需要循环到它对应的度数即可。
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 941 (Div. 2)</title>
    <url>/1991cceefb9e/</url>
    <content><![CDATA[[题目链接](https://codeforces.com/contest/1966)
A. Card Exchange题意给你n个牌，每个牌都有一个数字。
每次你可以选择恰好k个相同数字的牌， 然后将他们替换为任意的k-1张牌。（这k-1张牌的上的数字任意）
问在经过一些操作后，最终能剩下的牌的数量最少是多少。
思路最终剩下牌的数量 = n - 最多执行的操作次数。
所以我们很明显地发现，如果起初不存在相同的k个数，那么就无法进行操作，直接输出n即可。
给出结论，如果可以进行第一次操作，那么就可以使得最终牌的数量变为k - 1。
下面是证明：
我们设当前有n张牌 ， 在满足”存在相同的k张牌“的前提下， 有如下两种情况：

只有k张牌，且全部相同。那么再进行一次操作就可以实现最终剩下k-1张牌。
除了这k张牌之外，还有其他的牌（设他的值为num），那么我们就可以选择k-1张num来替换起初的k张相同牌， 这样就变为了总数为n-1的，仍然满足”存在相同的k张牌“的状态。最终会逐渐转化为第一种情况，并变为只剩k-1张牌的情况。

按照以上两种情况进行考虑，就可以保证最终会剩下k-1张牌。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n,k;	cin&gt;&gt;n&gt;&gt;k;	vector&lt;int&gt; cnt(105);	rep(i,1,n)&#123;		int num;cin&gt;&gt;num;		cnt[num]++;	&#125;	bool f = 0;	rep(i,1,100)&#123;		if(cnt[i] &gt;= k ) f = 1;	&#125;	if(!f)&#123;		cout&lt;&lt;n&lt;&lt;endl;		return ;	&#125;else&#123;		cout&lt;&lt;min(n,k-1)&lt;&lt;endl;		return ;	&#125;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
B. Rectangle Filling题意有一个n*m的表格，涂满了黑白两色。
规定如下操作： 每次选出两个相同颜色的格子， 让**”以他们为对角线的矩形区域“** 全部变为和选择方格同一种颜色。
在进行一些次数的操作后，能否使得整个n*m的表格全部变为某一种颜色。
思路若四条边中同时存在某一种颜色，那么就可以将整个表格变为同一个颜色，否则就不可以。
比如有如下样例：
3 4BWBBWBWBBBBW
我们可以将上面的表格变为白色， 只需从四个边中各自任意选出一个白色块W（可以重复选择某一块，如(3,4)这个W块，即作为靠下的边，也作为靠右边。）
我们选出至多四个块， 然后将他们作为操作时要选择的块，就可以使得整个表格变为这个颜色。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n,m;	cin&gt;&gt;n&gt;&gt;m;	int bl,br,bu,bd;	int wl,wr,wu,wd;	bl = bu = wl = wu = 0x3f3f3f3f;	br = bd = wr = wd = -0x3f3f3f3f;	rep(i,1,n)&#123;		rep(j,1,m)&#123;			char ch;cin&gt;&gt;ch;			if(ch == &#x27;B&#x27;)&#123;				bl = min(bl,j);br = max(br,j);				bu = min(bu,i);bd = max(bd,i);			&#125;else&#123;				wl = min(wl,j);wr = max(wr,j);				wu = min(wu,i);wd = max(wd,i);			&#125;		&#125;	&#125;	if(bl == 1 &amp;&amp; br == m &amp;&amp; bu == 1&amp;&amp;bd == n)&#123;		cout&lt;&lt;&quot;YES\n&quot;;return ;	&#125;	if(wl == 1 &amp;&amp; wr == m &amp;&amp; wu == 1&amp;&amp;wd == n)&#123;		cout&lt;&lt;&quot;YES\n&quot;;return ;	&#125;	cout&lt;&lt;&quot;NO\n&quot;;	return ;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
C. Everything Nim题意有n个堆， 第i个堆初始有a_i 个石头， Alice和Bob轮流进行操作，Alice先手，每次操作如下：

选择一个数x，保证x > 0且x不大于 任何非空堆 的剩余石头数量。

从所有的非空堆中都拿去x个石头。


最终无法操作（即所有堆全部为空）者会输掉比赛。
二人都选取最优策略，问谁会胜利
思路我们先将堆按照从小到大的顺序排序， 并且去重。我们会从小到大地不断清空每一堆。
**情况一：**当某一堆和前一堆的数量只差1的时候， 清空这堆时别无他法，只能设置x为1，并拿走这堆的最后一个，（因为在清空前一个堆的时候已经将这一堆拿到只剩下1个石头）
**情况二：**如果这一堆和上一堆的数量差大于1，那么就可以选择

全部拿走，即让对手去清空下一堆。
拿到只剩一个， 即让自己去清空下一堆。

可以发现这两者会正好对应相反的结果， 而我们又可以从中任选一个，所以就一定会获胜。于是就有如下结论：第一个遇到情况二的人会获胜。
注意考虑第一堆的数量情况，如果第一堆的数量大于2，那么Alice起手变获胜
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	vector&lt;int&gt; a(n+5);	rep(i,1,n)&#123;		cin&gt;&gt;a[i];	&#125;	sort(a.begin()+1,a.begin()+1+n);	bool f = 1;	int cnt = 0;	for(int i = 0;i&lt;n;i++)&#123;		if(a[i] == a[i+1]) continue;		if(a[i] == a[i+1] - 1)&#123;			f ^= 1;		&#125;else&#123;			f^= 1;			break;		&#125;	&#125;	if(f)cout&lt;&lt;&quot;Bob\n&quot;;	else cout&lt;&lt;&quot;Alice\n&quot;;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
D. Missing Subsequence Sum题意给出n和k， 请你构造一个长度不大于25的数组， 保证：

a中不存在某个子序列的和为k
对于任意1\le v \le n , v \not= k ,都有 **a中存在某个子序列的和为k**

思路k将[1,n] 分割为了两部分， [1,k-1]和 [k+1,n] ，我们分别构造这两部分。
对于[1,k-1]部分， 我们使用二进制数组来构造[1,2,4,...,2^p,Q] , 这些数的组合可以表示出 [1,2^{p+1}-1+Q] 之间的任意数，于是我们设置2^{p+1} 为”小于等于k的 最大的二次幂数“ , 即2^{p+1} \le k且2^{p + 2} > k  。而Q = k - 2^{p+1} 。 这样我们就可以构造出所有的[1,k-1] 的数。
对于[k+1,n]  部分，我们先选两个数k+1,k+2 。 此时我们可以表示出[k+1,k+2]之间的数，
我们设能表示的最大的数是mx, 那么下一个要表示的数nxt就是mx + 1 ,我们选择数nxt -(k+1) 作为下一个要加的数，这时候就可以将”可表示区域“ 拓宽为[k+1,mx+nxt-(k+1)] ,但是我们发现，如果num = nxt - (k + 1) \le k 那么会导致k被num + (k - num) 表示出来，就出现了问题，如果出现了这个问题，我们就不能直接将nxt - (k+1) 插入答案序列中，而是选择换成nxt 直接插入序列中。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n,k;	cin&gt;&gt;n&gt;&gt;k;	int mx = 0;	int nx = 1;	vector&lt;int&gt; ans;	while(mx + (mx + 1) &lt; k - 1)&#123;		ans.push_back(mx+1);		mx += mx + 1;	&#125;	ans.push_back(k - 1 - mx);	mx = k - 1;	ans.push_back(k+1);	ans.push_back(k+2);	mx = k+2;	while(mx &lt; n)&#123;		int tt = mx-k;		if(tt &lt;= k)&#123;			ans.push_back(mx+1);			mx += mx+1;			continue;		&#125;		ans.push_back(tt);		mx += tt;	&#125;	cout&lt;&lt;ans.size()&lt;&lt;endl;	for(auto p : ans)&#123;		cout&lt;&lt;p&lt;&lt;&quot; &quot;;	&#125;	puts(&quot;&quot;);&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 961 (Div. 2)</title>
    <url>/dee8b640169c/</url>
    <content><![CDATA[[比赛链接https://codeforces.com/contest/1995](https://codeforces.com/contest/1995)
A. Diagonals题意给定一个n*n 的矩阵， 定义对角线为i+j 相同的值，其中i为行号，j为列号 。
给你k个棋子要放在这么一个n*n 的矩阵中， 问最少需要占据多少个对角线。
思路对角线的长度为 n,n-1,n-1,n-2,n-2,...,1,1 。  我们按照对角线的长度从大到小按顺序填充棋子即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    if(k == 0) &#123;        cout&lt;&lt;0&lt;&lt;endl;        return ;    &#125;    int cnt =1;    k -= n;    int t = n-1;    int f = 0;    while(k&gt;0)&#123;        k -= t;        cnt++;        if(f) t--;        f ^= 1;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B. Bouquet由于简单版本和困难版本差距不大，这边直接上**hard vision**
题意有一个花店， 花店里有一些花，我们按照花所含有的花瓣数量来对花分类。你总共有x金币。
 你可以花费k个金币购买一个拥有k个花瓣的花，并且**你购买的花中，任意两朵花的花瓣数量相差不大于1** 。 问你最多能获得多少花瓣。
思路我们使用map来记录每个花瓣的花有多少朵 ， 显而易见， 若购买k花瓣的花，那么便只能再购买k+1花瓣的花 。所以我们枚举k为花店中每一种花的花瓣数量， 在每次枚举中，我们只考虑购买 k 和k+1的情况，最终在枚举的每种情况下取MAX即可。我们按照如下贪心策略来购买花，就可以保证买到的花瓣数量尽可能多。

尽可能多地购买k花瓣的花（直到没钱买或者把所有的花都买完了）
尽可能多地购买k+1花瓣的花（直到没钱买或者把所有的花都买完了）
尽可能多地将一些k花瓣的花换成k+1花瓣的花（每换一个花需要额外1金币， 并且要求有足够的k+1花瓣的花）

按照如上思路就可以得到“只够买k和k+1花瓣的花的情况下， 最多购买多少花瓣” ，将所有k的取值对应的答案取最大值就可以得到最终答案。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    map&lt;int,int&gt; mp;    vector&lt;int&gt; a(n+1),b(n+1);    rep(i,1,n)&#123;        cin&gt;&gt;a[i];    &#125;    rep(i,1,n)&#123;        cin&gt;&gt;b[i];    &#125;    rep(i,1,n) mp[a[i]] = b[i];    int ans = 0;    for(auto [x,y] : mp)&#123;        if(y==0) continue;        int sum = 0;        int mm = m;        int t1 = min(y,mm/x);        mm -= t1 * x;        int y2 = mp[x+1];        int t2 = min(y2,mm/(x+1));        mm -= t2 * (x+1);        y2 -= t2;        int t3 = min(mm,min(y2,t1));        sum = t1 * x + t2 * (x+1) + t3;        ans = max(ans,sum);    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C. Squaring题意给一个长度为n的数组a_1,a_2,..,a_n ， 每次操作你可以选择一个数i, 令a_i = a_i ^2  ，请问最少需要多少次操作，能让数组a变为单调不减数列。若无论如何都无法实现，那么输出-1
思路可以很容易想到，我们从左到右遍历数组，不断检查每一个数是否大于等于上一个数，若出现a_i < a_{i-1} 就对a_i进行操作，直到满足a_{i} \ge a_{i-1} 。 
特判：只有当存在a_i = 1 ,a_{i-1} > 1  时， 无论如何都无法令a_{i-1}\le a_i ，此时要输出-1 。
本题的难点在于在对一个数进行操作时，我们很容易就会发生超出longlong范围的情况，因此我们不能直接比较两个数的大小，而应该将他们作为a^p ,b^q 的形式，直接比较二者的大小。 

错解：
起初我很容易想到了一个”解法“， 即若判断 a^p, b^q 的大小关系， 可以比较 a^{\frac{1}{q}} 和b^{\frac{1}{p}} 的大小关系， 于是便成功WA5了。。。

正解：
本题我们要用到每次操作都是平方的特性，即a^p ,b^q中的p,q 都是**2的次幂**，  假设 a_{i-1}^p > a_{i} , 我们可以先令二者的幂相同，即设c ,满足c^p = a_{i}  , 于是为了令a^p_{i-1} \le a_i^q =(c^p)^q = (c^q)^p  ， 于是我们只需要找到一个q ,使得恰有c^q \ge a_{i-1}  即可, 也即a_i ^ {\frac{q}{p}} \ge a_{i-1} ， 又因为我们每次进行操作为乘方操作， 所以有p,q 都是**2的次幂** ， 设p = 2^x,q = 2^y , 那么a_i^{\frac{q}{p}} = a_i^{2^{y-x}} ， 此处的y-x  即为我们要对a_i 进行的操作次数。
那么会出现下面两种情况：

a_i \le a_{i-1} ，那么我们不断对a_i 进行乘二操作， 直到进行完cnt 次操作后，a_i \ge a_{i-1} ，此时对a_i 进行的总次数即为q = p + cnt
a_i > a_{i-1} ，那么我们不断对a_i 进行除以二操作， 直到进行完cnt 次操作后，恰好a_i \ge a_{i-1} , 此时a_i 进行的总次数即为q = p - cnt

代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)#define endl &#x27;\n&#x27;const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;struct node &#123;    int x;    int ope = 0;&#125;;void solve()&#123;    int n;    cin&gt;&gt;n;    vector&lt;int&gt; a(n+5);    int ans = 0;    vector&lt;node&gt; b(n+5);    for(int i = 1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i = 2;i&lt;=n;i++)&#123;        if(a[i] &lt; a[i-1] &amp;&amp; a[i] == 1)&#123;            cout&lt;&lt;-1&lt;&lt;&#x27;\n&#x27;;            return ;        &#125;    &#125;    for(int i = 1;i&lt;=n;i++)&#123;        b[i] = &#123;a[i],0&#125;;    &#125;    for(int i = 2;i&lt;=n;i++)&#123;        int x1 = a[i-1];        int q1 = b[i-1].ope;        int x2 = a[i];        int q2 = b[i].ope;        if(x1 &gt; x2)&#123;            int xx = x2;            int t = 0;            while(xx &lt; x1)&#123;                xx *= xx;                t++;            &#125;            b[i].ope = b[i-1].ope + t;        &#125;else if(x1 == x2)&#123;            b[i].ope = b[i-1].ope;        &#125;else&#123;            if(b[i-1].x == 1) &#123;                b[i].ope = 0;                continue;            &#125;            int t = 0;            int xx = x1;            while(xx &lt; x2)&#123;                xx *= xx;                t++;            &#125;            if(xx&gt;x2) t--;            b[i].ope = max(0LL,b[i-1].ope-t);        &#125;        ans += b[i].ope;    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D. Cases题意给你一个长度为n的只含有前c种字母的字符串S，你可以将这个字符串切割为一些子串，并使得每一子串的长度都不大于k , 定义切割后的字符串的价值为选取每一个子串的最后一个字符，将其放入集合set中，最终set的大小 ， 即所有子串最后一个字符的种类数量。
问给定n,c,k,S ，最小价值为多少。
思路题意可以理解为， 我们尽可能少地选择一些字母， 要求相邻的被选择的字母之间距离不大于k。
也即： **任选一个长度为k的子串，其中必须包含至少一个我们所选择的字母。**
我们判断一个长度为k的子串中有没有某一个字符，可以使用前缀和来判断，我们用sum[i][j] **表示前i个字符中，有多少个字符j**
if(sum[i+k][j] - sum[i][j]==0)
我们提取所有的长度为k的子串，将他们没出现过的字母状态进行二进制表示后存储起来，表示“只选择这些字母，会出现错误”。设对应的二进制码为msk，那么就令bad[msk] = 1 .
较容易得知，如果我们在选择一个组合之后，会发生错误，那么我们再从中去掉一些后，同样会出现错误。（如若选择AC 两种字母会出现相邻的被选择的字母之间距离大于k ,那么如果我们只选择A 或者C ，就一定也会导致相邻的被选择的字母之间距离大于k
例如样例：
6 3 2ABCABC
我们提取出长度为2的子串后，得到AB, BC, CA, AB,BC ,  取反后得到C ,A ,B ,C,A , 即如果选择其中一种组合或其子集(A或B或C或空) ，会出现错误。
在处理完bad数组后， 我们选出含有1最少的i，并且bad[i] == 0 ， 于是i中1的数量即为答案。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int sum[300005][20];void solve()&#123;    int n,c,k;    cin&gt;&gt;n&gt;&gt;c&gt;&gt;k;    string str;     cin&gt;&gt;str;str = &quot; &quot; + str;    for(int j = 0;j&lt;c;j++) sum[0][j] = 0;    for(int i = 1;i&lt;=n;i++)&#123;        for(int j = 0;j&lt;c;j++)&#123;            sum[i][j] = sum[i-1][j] + (str[i] == j + &#x27;A&#x27;);        &#125;    &#125;    vector&lt;bool&gt; bad((1&lt;&lt;c));    for(int i= 0;i&lt;=n-k;i++)&#123;        int msk = 0;            for(int j = 0;j&lt;c;j++)&#123;            if(sum[i+k][j] ==  sum[i][j] )&#123;                msk |= (1&lt;&lt;j);            &#125;        &#125;        bad[msk] = 1;    &#125;    bad[(1 &lt;&lt; (str.back() - &#x27;A&#x27;))^((1&lt;&lt;c)-1)] = 1;    for(int i =(1&lt;&lt;c)-1;i&gt;=0;i--)&#123;        for(int j=0;j&lt;c;j++)&#123;            bad[i] = bad[i] | bad[i | (1&lt;&lt;j)];        &#125;      &#125;    int res = INF;    for(int i = 0;i&lt;(1&lt;&lt;c);i++)&#123;        if(!bad[i])&#123;            int cnt = __builtin_popcount(i);            res = min(res,cnt);        &#125;    &#125;    cout&lt;&lt;res&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 962 (Div. 3)</title>
    <url>/9f8d409c8d9a/</url>
    <content><![CDATA[[题目链接https://codeforces.com/contest/1996](https://codeforces.com/contest/1996)
A. Legs题意一只鸡有两条腿，一只牛有四条腿，一共有n(n是偶数)条腿，问最少多少只动物。
思路全是牛的时候动物数量最多， 所以ans = \lceil \frac{n}{4} \rceil
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    cout&lt;&lt;(n+3)/4&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B. Scale题意有一个01数组，请你缩小k倍，然后输出它。
例如：
16 3000111000111000111111000111000111000
缩小完变为
0110
思路循环输出，每次跳k格即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;char mp[1005][1005];void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    rep(i,1,n)&#123;        rep(j,1,n) cin&gt;&gt;mp[i][j];    &#125;    for(int i =1;i&lt;=n;i+=k)&#123;        for(int j = 1;j&lt;=n;j+=k)&#123;            cout&lt;&lt;mp[i][j];        &#125;        puts(&quot;&quot;);    &#125;&#125;signed main()&#123;    // IO;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C. Sort题意给你两个字符串 a,b , 进行q次询问，每次询问l,r 。 对于每次询问，你可以进行一些次数操作，每次可以使得一个字符变为任意另一个字符， 问最少多少次操作，能够使得 sorted(a[l..r]) = sorted(b[l..r]) 
注意：每次询问的修改操作不影响之后的询问。
思路因为我们会对这两个子串进行排序操作，所以我们就只需要考虑子串中每个字符出现的次数即可。
我们定义两个子串的差异度为undefinedsum_{ch = a}^z |cnta[ch]-cntb[ch]|$ ,即每种字符在两个子串中数量的差的总和。
我们每次操作可以将一个字符变为另一个字符，因此会使得二者的差异度减少2 。
所以我们总共的操作次数就是差异度除以2。 即undefinedfrac{\sum_{ch = a}^z |cnta[ch]-cntb[ch]|}{2}$
于是我们需要解决的问题变为：如何更快地求出某一子串中所含有的字符数量： **前缀和** ，使用一个sum[N][26] 数组来记录每个字符出现的次数。于是对于某一子串a[l..r] ， 字符ch , 出现的次数为sum[r][ch-&#39;a&#39;] - sum[l-1][ch-&#39;a&#39;]
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int cnt1[200005][27];int cnt2[200005][27];void solve()&#123;    int n,q;    cin&gt;&gt;n&gt;&gt;q;    string a,b;    cin&gt;&gt;a&gt;&gt;b; a = &#x27; &#x27; + a; b = &#x27; &#x27; + b;    for(int i = 1;i&lt;=n;i++)&#123;        for(int j = 0;j&lt;26;j++)&#123;            cnt1[i][j] = cnt1[i-1][j] + (a[i] == &#x27;a&#x27; + j);            cnt2[i][j] = cnt2[i-1][j] + (b[i] == &#x27;a&#x27; + j);        &#125;    &#125;    while(q--)&#123;        int l, r;        cin&gt;&gt;l&gt;&gt;r;        int ans = 0;        for(int j = 0;j&lt;26;j++)&#123;            ans += abs((cnt1[r][j] - cnt1[l-1][j])-(cnt2[r][j] - cnt2[l-1][j]));        &#125;        cout&lt;&lt;ans/2&lt;&lt;&#x27;\n&#x27;;    &#125;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D. Fun题意给定两个数n,x , 求满足a+b+c\le x , ab + ac + bc \le n 的三元组undefineda,b,c)的个数。1\le n ,x \le 10^6$
注意：三元组是有序的，即undefined1,1,2),(2,1,1)$ 视为不同的三元组
思路如果暴力枚举，我们需要三重循环分别枚举a,b,c ，他们的取值为 1\le a,b,c \le x-2  ,此时的复杂度为O(x^3) ，显然是不行的。考虑根据两个条件节时， 我们枚举最外层变量为a， 即在a确定之后：

根据条件1： 一定有b \le x - a - c \le x - a - 1   ，于是b只需要枚举到x-a-1即可。
根据条件2：一定有a * b < n , 即b最大为undefinedlfloor \frac{n}{a} \rfloor$ 

二者取min，得到b的最大值。可以得出，此时枚举a和b的复杂度大概为nlnn , 那么我们需要O(1) 求出c的取值范围，在确定完a,b 的值后，可以得出1\le c \le min(x - a -b,\frac{ n - a*b}{a+b}) ,  而对于每个c，都会对答案贡献1，因此在确定完a和b后， 我们直接令答案加上min(x - a -b,\frac{ n - a*b}{a+b}) 即可。总体时间复杂度即为枚举a和b的复杂度O(nlnn)。 
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,x;    cin&gt;&gt;n&gt;&gt;x;    int ans =0;    rep(a,1,x)&#123;        rep(b,1,x)&#123;            if(a+b&gt;=x) break;            if(a*b&gt;=n) break;            int nn = n - a * b;            int c1 = (n-a*b) / (a+b);            int c2 = x - a - b;            ans += min(c1,c2);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
E. Decode题意给一个01串S，求对于每一对undefinedl,r), (1\le l\le r\le n),计算(x,y) ,(l\le x\le y \le r)这样的整数对的个数，要求S[x..y]$ 中0 和1的数量相同。
思路我们考虑逆向思维，找出每一个满足f_0(S[x..y]) = f_1(S[x..y]) 的undefinedx,y)对， 计算每个对的贡献（即为    在多少个子串S[l..r]中），将其加和即可。 如果我们确定一个(x,y)那么很容易算出， 它的贡献为x * (n-y+1)$  。
那么如何确定这些undefinedx,y)对呢，我们考虑前缀和，将字符`0`的贡献为-1， 字符1的贡献为`1` ，那么f_0(S[x..y]) = f_1(S[x..y])就等价于sum[y] = sum[x-1], 我们边枚举y边对这么一个sum数组进行桶计数。于是cnt[sum[y]]即表示在y之前，有多少个x满足sum[x-1] = sum[y],但是我们记录数量是不够的，我们还要考虑x的位置，即对于每个y，贡献为x_1*(n-y+1) + x_2*(n-y+1)+…+x_k*(n-y+1) = (x_1+x_2+…+x_k)*(n-y+1)，于是我们的桶数组每次应该令cnt[sum[x]] += i+1， 即记录为每个满足条件的x的和。 （注意每次加到cnt数组中的是i+1,不是i,因为i = x-1$）

注意sum[x] 可能是负数，我们进行桶计数是要进行偏移n处理
注意对答案加和的过程中取模

代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;const int mod = 1e9+7;void solve()&#123;    string str;    cin&gt;&gt;str;    int n = str.size();str = &#x27; &#x27; + str; // 将字符串变为下标从1开始    vector&lt;int&gt; cnt(2 * n + 5); // 开2*n大小的桶，因为sum[i]的取值为[-n,n]    vector&lt;int&gt; sum(n+5);    cnt[0+n] = 1;    int ans = 0;    for(int i = 1;i &lt;= n;i++)&#123;        int y = i;        sum[y] = sum[y-1];        if(str[y] == &#x27;0&#x27;) sum[y]--;        else sum[y] ++;        ans = (ans + cnt[sum[y]+n] * (n-y+1)%mod)%mod;        cnt[sum[y] + n] += i+1; // 这里要加一，因为我们存的是sum[x-1],那么对于    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
F. Bomb题意给两个长度为n的数组a,b , 你至多进行k(1\le k \le 10^9)次操作，每次操作如下：选择一个数i , 获得a[i] 枚金币，并令a[i] = max(0,a[i]-b[i])
问最多能获得多少金币  
思路我们先考虑O(k) 的朴素解法：  每次选择一个最大的a[i] ,选择完后使用堆（优先队列）更新最大值，重复选择k次即可。
但是上述代码会导致超时（因为k太大了）， 我们考虑二分搜索：
我们设f(x)表示令所有的a[i] 都减至a[i] < x ，所需要的操作次数。 显而易见，f(x) 是单调递减的。因此满足二分性。
我们找到这样一个l , 使得f(l) > k , f(l+1) \le k , 这样我们先令所有的a[i] 都减至小于 l ,此时相比k，会多进行f(l)-k 次操作， 因此会导致多获得一些金币，这里每次操作会使我们额外获得l的贡献，令最终的金币数量减去undefinedf(l)-k)*l$ 即为最终答案。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int n,k;int a[200005];int b[200005];bool check(int x)&#123;    int sum = 0;    for(int i = 1;i&lt;=n;i++)&#123;        if(a[i]&gt;=x)&#123;            sum += (a[i]-x)/b[i] + 1;        &#125;    &#125;    return sum &lt;= k;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;k;    rep(i,1,n) cin&gt;&gt;a[i];    rep(i,1,n) cin&gt;&gt;b[i];    int l =0; int r =1e9+5;    while(l&lt;r)&#123;        int mid = (l+r+1)&gt;&gt;1;        if(check(mid))&#123;            r = mid-1;        &#125;else&#123;            l = mid;        &#125;    &#125;    int ans = 0;    int s = 0;    for(int i = 1;i&lt;=n;i++)&#123;        if(a[i]&gt;=l)&#123;            int m = (a[i] - l)/b[i] + 1;            ans += (a[i] + a[i]-(m-1)*b[i])*m/2;            s += m;           &#125;    &#125;    ans -= 1LL * l * (s - k);    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 963 (Div. 2)</title>
    <url>/8f85cb476a13/</url>
    <content><![CDATA[[Codeforces Round 963 (Div. 2)](https://codeforces.com/contest/1993)
A. Question Marks题意有一场考试一共4*n 道题目，其中答案为A,B,C,D 的题目各n 道，  现在你有一份考试的结果，由字母A,B,C,D 组成，请问最多得到多少分。
思路每种选项最多答对n道题目，我们统计每个选项的出现次数 ，和n取较小值 ，将结果加起来即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII; void solve()&#123;    int n;    cin&gt;&gt;n;    string str;    cin&gt;&gt;str;    int cnt[150] = &#123;0&#125;;    for(auto &amp; p : str)&#123;        cnt[p] ++;    &#125;        int ans = 0;    for(int i = &#x27;A&#x27;;i&lt;=&#x27;D&#x27;;i++)&#123;        ans += min(cnt[i],n);    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B. Parity and Sum题意给你一个由n个正整数组成数组a ， 你每次操作可以选择两个下标 undefinedi,j), 满足a_i与a_j的奇偶性不同。将a_i和a_j中的较小值转换为a_i+a_j$ 。 
问最少需要操作几次才能够使得数组a中的所有的数奇偶性相同。
思路我们将奇数和偶数分开来， 奇数在数组odd中，偶数在数组even中 ， 那么我们每次操作即为从odd和even中各选择一个数， 最后目标为使odd数组为空或者even数组为空。
首先，如果odd数组初始为空，或者even初始数组为空，那么答案即为0 。
因为我们每次操作一定选择的是一个奇数和一个偶数，那么我们最终加和后的结果一定是奇数 ，于是每次操作只会使得奇数越来越多，偶数越来越少。
下面给出结论： 假设起初有cnt个偶数 ，那么需要的操作次数最少为cnt， 最多为cnt+1 。
我们假设选择的奇数为 x，偶数为y。 如果x < y 那么会让奇数x 变为另一个奇数x+y ； 如果x>y 那么会让偶数y变为奇数x+y 。即只有第二种操作才能令偶数的数量减少一个。 因此最少需要cnt次才能将所有的偶数变为奇数。
因此我们应该尽可能地保证每次选择的奇数比偶数要大，于是我们每次一定会选择目前最大的奇数mx , 如果在这种选择下仍然会出现奇数更小的情况，那么我们就一定无法在cnt次操作下完成目标了。 此时我们可以选择将mx和最大的偶数进行操作，得到的新的奇数一定比所有的偶数大，之后每次都选择这个奇数，便可以保证每次都满足奇数大于偶数了。 最终需要cnt+1次操作。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    vector&lt;int&gt; odd,even;    for(int i =1;i&lt;=n;i++)&#123;        int x;cin&gt;&gt;x;        if(x%2) odd.push_back(x);        else even.push_back(x);    &#125;    if((!odd.size()&amp;&amp;even.size())) &#123;cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;return ;&#125;    if((odd.size()&amp;&amp;!even.size())) &#123;cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;return ;&#125;    sort(odd.begin(),odd.end());    sort(even.begin(),even.end());    int sz = even.size();    int mx = odd.back();    queue&lt;int&gt; q;    for(auto p:even) q.push(p);    int ans = 0;    while(q.size())&#123;        if(mx &gt; q.front()) &#123;            ans++;            mx = mx + q.front();            q.pop();        &#125;else&#123;            ans ++;            mx = mx + q.front();        &#125;    &#125;    cout&lt;&lt;min(ans,sz+1)&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C. Light Switches题意有n个房间，每个房间都有一盏灯，起初所有的灯都是灭的，第i个房间会在a_i, a_i+k,a_i+2*k,... 的时间刻转换灯的状态，即在[a_i,a_i+k-1] , [a_i+2*k,a_i+3*k-1],... 区间内亮灯。
问最早在哪个时刻，能保证所有n盏灯都是亮着的。如果不存在某个时刻所有的灯都是亮着的，那么输出-1 .
思路题意即为将所有房间的亮灯区间取交集，然后取最小值。
我们可以对所有的房间按照a_i 从小到大进行排序 ，然后依次取交集，  因为每个区间都为2*k重复区间，所以每次取交集后一定也为2*k 重复区间，于是我们只需要使用undefinedl,r)来表示区间[l+j*2k,r+j*2k]$ 即可。
起初l = a[1], r = a[1]+k-1 ,之后我们遍历每个区间[l_i,r_i] , 如果当前遍历的区间与交集的初始区间[l,r] 相差距离超过2*k 便可以通过令l,r 都加上t个2*k（其中t = \frac{l_i - l}{2*k} ），来使得两个区间的左端点的距离不超过2*k ， 此时如果l_i > r 那么取交集一定为空，我们尝试让[l,r] 再向后移动一个2*k ，试图令[l_i,r_i ] 与[l+2k,r+2k]取交集。 （取交集即为l= max(l,l_i), r = min(r,r_i) ）
如果某次遍历时使得l>r 那么此时交集已经为空，直接输出-1即可。
如果遍历结束，那么最终的答案即为l 。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    vector&lt;int&gt;a(n+5);    rep(i,1,n) cin&gt;&gt;a[i];    sort(a.begin()+1,a.begin()+1+n);    int l = a[1];    int r = a[1] + k - 1;    for(int i=2;i&lt;=n;i++)&#123;        if(a[i] &lt;= r &amp;&amp; a[i] &gt;= l)&#123;            l = a[i];            &#125;                int t = (a[i] - l) / (2*k);        l += t * 2 * k;        r += t * 2 * k;        if(a[i] &gt; r)&#123;            l+=2*k;            r+=2*k;        &#125;        l = max(l,a[i]);        r = min(r,a[i]+k-1);        if(l &gt; r) &#123;            cout&lt;&lt;&quot;-1\n&quot;;            return ;        &#125;    &#125;    cout&lt;&lt;l&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D. Med-imize题意有一个长度为n的数组a_0,a_1,...,a_{n-1} (注意本题的数组下标从0开始) ， 以及一个整数k , 我们每次选择一个长度为k的子数组，将其从数组a中删除，直到数组的中的数组元素数量不大于k。
问最终数组a的中位数最大是多少。本题的中位数为对数组的元素排序后，第undefinedfrac{sz+1}{2}个元素，其中sz$为数组的长度。
思路我们可以二分答案来求最终的中位数 。于是问题变成了： 给定一个数mid ，能否存在一个最终数组a' ，使得a' 中的大于等于mid的数的数量，比小于mid的数的数量更多。
我们将满足a_i \ge mid 的元素设置为b_i = 1 , 否则就设置为b_i = -1 。 我们尽可能让最终选出的b' 数组的和尽可能大，最后判断是否大于0即可。
但是我们不能任意选择剩下的元素，最终一定会剩下m个元素(m =(n-1)\%k+1 )    ，并且最终剩下的数组a'_i \in \{a_{i\%k + t * k}\} 即选出的最终的下标为i的数的原始下标一定在i的同余集中。
很好证明这点： 假设我们选出了第3个数（即下标为2），那么之前一定进行过选择了2个数，然后又删除了几组数（每组一定为k个数），所以这个数的原始下标一定为t*k + i 。
我们用dp[i] 表示考虑前i个数，b[i]数组最大为多少，由于我们每次只能成组地删除元素，那么就代表了如果我们选择不要b[i] 这个元素，那么dp[i]=max(dp[i],dp[i-k]) , 而如果我们选择要这个元素，那么dp[i] = max(dp[i],dp[i-1]+b[i])  ， 最终比较dp[n-1]>0 是否成立即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;// 本题数据在数组中从下标0开始存储int a[500005];int b[500005];int dp[500005];int n,k;bool check(int mid)&#123;    for(int i = 0;i &lt; n;i++)&#123;        if(a[i] &gt;= mid) b[i] = 1;        else b[i] = -1;     &#125;    dp[0] = b[0];    for(int i = 1;i&lt;n;i++)&#123;        if(i%k == 0)&#123;            dp[i] = max(dp[i-k],b[i]);        &#125;else&#123;            dp[i] = dp[i-1] + b[i];            if(i &gt; k)                dp[i] = max(dp[i],dp[i-k]);        &#125;    &#125;    return dp[n-1] &gt; 0;&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;k;    rep(i,0,n-1) cin&gt;&gt;a[i];    int l,r;    l = 1;r = 1e9;    while(l&lt;r)&#123;        int mid = (l+r+1)&gt;&gt;1;        if(check(mid))&#123;            l = mid;        &#125;else&#123;            r = mid-1;        &#125;    &#125;    cout&lt;&lt;l&lt;&lt;&#x27;\n&#x27;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 986 (Div. 2)</title>
    <url>/c31164113f39/</url>
    <content><![CDATA[https://codeforces.com/contest/2028
A. Alice’s Adventures in “Chess”题意有一个无限大的地图，地图的原点有一个机器人， 即他起初在坐标undefined0,0)处，并且会不断重复一段指令，指令的长度为n$,指令只包含NESW字符，表示像对应的方向移动。
问机器人能否在某时刻到达坐标undefineda,b)$处。
需要注意的是1\le n,a,b \le 10
思路我们固然可以通过处理出一次循环所到达的位置，然后通过每次循环的偏移量来计算每个位置之后是否有可能到达目标。但是这样子虽然时间复杂度很好，但是程序写起来很麻烦。
我们注意到题目中给出的数据很小，因为机器人执行一套指令后，会移动固定的偏移量，于是在经过100轮移动后， 机器人对于x 轴（或y轴）上，只有可能移动了超过100格，或者原地不动。在此之后一定不可能到达a
我们直接暴力执行100套操作，一定会将所有可能到达(a,b)的状态都遇到。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,a,b;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;    string s;    cin&gt;&gt;s;    int x = 0;int y = 0;    for(int i = 1;i&lt;=100;i++)&#123;        for(auto ch : s)&#123;            if(ch == &#x27;N&#x27;) y++;            if(ch == &#x27;S&#x27;) y--;            if(ch == &#x27;E&#x27;) x++;            if(ch == &#x27;W&#x27;) x--;             if(x == a &amp;&amp; y == b)&#123;                cout&lt;&lt;&quot;YES\n&quot;;return ;            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;NO\n&quot;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B. Alice’s Adventures in Permuting题意有一个长度为n的数组a，由三个参数n,b,c决定 ，表示为a_i = b * (i-1) + c 。
每进行一次操作，会将a的最大值变为mex(a) 
问在进行几次后，a数组会变为[0,1,2,3,...,n-2,n-1] 。
若无法达到目标，输出undefined1$ 。
思路本题是讨论题，容易发现，在一般情况下，a数组需要的操作数，即为a数组中大于等于n的元素的数量。
下面列举特殊情况：

当b = 0  时，a数组初始为n个c ,此时
若c == n-1  \ or \ c == n- 2 ，那么需要操作n-1次。
若c \ge n 那么需要操作n次
若c < n - 2 ,那么无论如何都无法使得a变为目标数组，输出undefined1undefined


当b不等于0时
如果c \ge n ，那么需要n次操作
如果c < n ，那么需要n - \frac{n-1-c}{b} - 1



代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;#define endl &#x27;\n&#x27;void solve()&#123;    int n,b,c;    cin&gt;&gt;n&gt;&gt;b&gt;&gt;c;    if(b == 0)&#123;        if(c == n - 1 || c == n - 2)&#123;            cout&lt;&lt;n - 1&lt;&lt;endl;        &#125;else if(c &gt;= n) cout&lt;&lt;n&lt;&lt;endl;        else cout&lt;&lt;-1&lt;&lt;endl;        return ;    &#125;else if(c &gt;= n)&#123;        cout&lt;&lt;n&lt;&lt;endl;    &#125;else &#123;        int t = (n-1-c)/b;t++;        cout&lt;&lt;n-t&lt;&lt;endl;    &#125;&#125;signed main()&#123;    IO;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C. Alice’s Adventures in Cutting Cake题意给你一个长度为n的数组a , 你需要将数组分为m+1个连续的部分，并且要求如下：

至少有m个子数组满足：子数组的和大于等于v
另外那个数组的子数组的和尽可能大。

问条件2中描述的子数组，和最大是多少？
思路假设所有的数组都需要满足“子数组的和大于等于v” , 那么显然我们不断地添加元素，当元素的和大于等于v时，切分数组，就可以尽可能地满足条件。
但是现在其中有一个数组是可以不满足该条件的，那么将该数组分为m+1个子数组后，这m个子数组会被第m+1个子数组分开为两部分。
于是我们可以通过预处理数组的前后缀关系（例如前缀pre[i] 表示为从a_1到a_i 之间可以分成多少个大于等于v 的数组）
于是我们枚举第m+1的数组的左端点l ，在他左边有pre[l-1]个的子数组，于是我们就还需要m - x个子数组，二分寻找lst中的该值既可找到右端点r 。
最终的答案就是sum[r] - sum[l-1] 的最大值。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,m,v;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;v;    vector&lt;int&gt; a(n+5);    vector&lt;int&gt; pre(n+5);    vector&lt;int&gt; lst(n+5);    vector&lt;int&gt; sum(n+5);    for(int i = 1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        sum[i] = sum[i-1] + a[i];    &#125;    int tmp = 0;    for(int i = 1;i&lt;=n;i++)&#123;        tmp += a[i];        pre[i] = pre[i-1];        if(tmp &gt;= v)&#123;            tmp = 0;pre[i] ++;        &#125;    &#125;    tmp = 0;    for(int i = n;i&gt;=1;i--)&#123;        tmp += a[i];        lst[i] = lst[i+1];        if(tmp &gt;= v)&#123;            tmp = 0;lst[i] ++;        &#125;    &#125;    int ans = -1;    for(int r = 0;r&lt;=n+1;r++)&#123;        int need = m - lst[r];        int p = lower_bound(pre.begin(),pre.begin()+1+n,need) - pre.begin();        if(r-1 &gt;= p)            ans = max(ans,sum[r-1] - sum[p]);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return ;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D. Alice’s Adventures in Cards题意你在和q,k,j 三个人玩纸牌游戏， 其他三个人，每个人的手中都有1,2,...,n这n张牌，但是每个人对于牌的重要程度认识是不同的。
你认为当i > j 时，纸牌的重要程度i > j ,即编号越高越重要。
其他三人认为的重要程度由排列p^q,p^k,p^j 表示，数值越大的牌表示重要程度越大。
你只有一张纸牌1，你会根据三个人交换纸牌，你可以用a来交换b，当且仅当a < b\  \& \ p_a > p_b 。
问你能否根据以上规则来交换到纸牌n，若能则输出一种方案。
思路本题需要逆向处理，我们从n开始向前dp， 对每个玩家记录，能够和他交换的牌中，最小的p是多少。
当可以和某个玩家交换时，则更新三者的最小p值。
最终若能到达1那么就代表是有解的。同时我们记录dp的过程来找到具体的解决方案。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    vector&lt;vector&lt;int&gt; &gt; p(3,vector&lt;int&gt;(n+1));    string s = &quot;qkj&quot;;    rep(i,0,2) rep(j,1,n) cin&gt;&gt;p[i][j];    array&lt;int,3&gt; minp = &#123;n,n,n&#125;;    vector&lt;pair&lt;char,int&gt; &gt; sol(n+5,&#123;&#x27;?&#x27;,-1&#125;);    for(int i = n-1;i&gt;=1;i--)&#123;        int win = -1;        rep(j,0,2) if(p[j][i] &gt; p[j][minp[j]]) win = j;        if(win == -1) continue;        sol[i] = &#123;s[win],minp[win]&#125;;        rep(j,0,2) if(p[j][i] &lt; p[j][minp[j]]) minp[j] = i;    &#125;    if(sol[1].first == &#x27;?&#x27;)&#123;        cout&lt;&lt;&quot;NO\n&quot;;return ;    &#125;    cout&lt;&lt;&quot;YES\n&quot;;    vector&lt;pair&lt;char,int&gt; &gt; ans;    ans.push_back(sol[1]);    while(ans.back().second != -1)&#123;        ans.push_back(sol[ans.back().second]);    &#125;    ans.pop_back();    cout&lt;&lt;ans.size()&lt;&lt;&#x27;\n&#x27;;    for(auto &amp; [x,y]:ans)&#123;        cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&#x27;\n&#x27;;    &#125;&#125;signed main()&#123;    IO;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 155</title>
    <url>/26a716a7c57e/</url>
    <content><![CDATA[[Educational Codeforces Round 155 (Rated for Div. 2)](https://codeforces.com/contest/1879)
D. Sum of XOR Functions题意给出一个数列： a_1,a_2,...,a_n ，求undefinedsum _{l=1}^{n} \sum _{r=l}^{n}f(l,r) \cdot (r - l + 1),其中f(l,r) = a_l \oplus a_{l+1} \oplus … \oplus a_r$ 
答案对998244353取模.  （n \le 3\cdot 10 ^ 5） 
思路我们如果暴力枚举，我们的复杂度就太高了（纯暴力O(n^3) ,即使使用前缀来优化区间异或的操作，也需要 O(n^2)）。
因此我们需要考虑异或操作的特殊性。我们可以将a按每个二进制位差分，这样就得到了一个二维数组（设为v），数组的长度是数列中的数的个数，宽度是一个数的二进制位数。
例如样例 1，3，2 对应的v数组为:




V数组
1
3
2




undefineda_i &gt;&gt; 1) \&amp; 1$
0
1
1


undefineda_i &gt;&gt; 0) \&amp; 1$
1
1
0




然后我们就可以按每次一行的顺序来计算处理，最终将答案按权合并即可。
这样我们每次处理的数据就只有0 和 1，可以用如下方法来在O(n) 的时间内解决：
假设我们要处理的01数组为数组b，
设有如下变量：cnt0,cnt1,sum0,sum1,res, 从左向右依次检查每一个数（设下标为1~n）：
如果检查到第i个数 ，这时候的 cnt0 ,cnt1 分别表示以 b[i] 为结尾的，区间异或为0 /  为1 的区间 的数量; sum0，sum1 表示以b[i] 为结尾的区间异或 的 区间长度的和  , res表示 此时的 前i个数组成的所有异或1区间的 长度和（不止是以i为右边界的区间）翻译为数学公式即：    cnt0 =  \sum _{k = 1}^i 1,(f(k,i) = 0)
​    cnt1 =  \sum _{k = 1}^i 1,(f(k,i) = 1)
​    sum0 =  \sum _{k = 1}^i (i-k+1),(f(k,i) = 0)
​    sum1 =  \sum _{k = 1}^i (i-k+1),(f(k,i) = 0)
​    res = \sum _{l=1}^{i} \sum _{r=l}^{i}f(l,r) \cdot (r - l + 1) 
然后遍历i 从1 到n：进行状态转移：如果 b[i] = 1 : 
​    swap(cnt0,cnt1);swap(sum0,sum1); (原先异或为0的区间再异或1变为1，异或为1的区间再异或为0，效果就是交换cnt0和cnt1)
​    cnt0+=0;cnt1+=1; ((区间异或为1的段的数量加上1)
​    sum0+=cnt0;sum1+=cnt1;长度都增加了1，相当于总的长度增加了cnt0和cnt1
​    res += sum1 （最终答案加上 $sum1_i$）
如果b[i] = 0:
​    (原先的区间异或的值不会变)
​    cnt0+=1;cnt1+=0; (区间异或为0的段的数量加上1)
​    sum0+=cnt0;sum1+=cnt1; 度都增加了1，相当于总的长度增加了cnt0和cnt1
​    res += sum1 （最终答案加上 $sum1_i$）
最终将每行得到的res进行按权（第i行的权为(1]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 157 (Rated for Div. 2)</title>
    <url>/ab10feeb834a/</url>
    <content><![CDATA[[Dashboard - Educational Codeforces Round 157 (Rated for Div. 2) - Codeforces](https://codeforces.com/contest/1895)
C. Smilo and Monsters题意有n头怪物，每个怪物有各自的血量。每次操作可以

对一个怪物造成一点伤害，并令连击值x加一。

消耗所有的连击值x，选择一个生命值大于等于x的怪物，对他造成x点伤害，然后连击值降为0。


问最少多少操作能够杀死所有的怪物？
思路方案一、模拟
由于我们连击值越高，效益越大。所以先对怪物的血量由低到高排序，然后在血量较低的怪物身上使用普攻，然后当连击值和当前血量最高的怪物相等时，使用绝招杀死怪物。因此我们需要用l，r两个变量来记录当前普攻杀到了哪个怪物，以及大招该杀哪个怪物。
需要特判的是：可能普攻杀死一个最小的怪物时，连击值已经超过了最大血量怪物需要的连击值。这时候需要回退一些普攻操作。例如当前连击值为4，然后用6次普攻杀死了一个血量为6的小怪，但是另一只大怪的血量只有6，我们应该对小怪只造成2点普攻伤害，然后直接杀死大怪。（反例为 4 6 6 6 6）
还有就是杀死所有的小怪后，连击值不足以杀死大怪，这时候我们应该对大怪进行一些普攻，等连击值和大怪剩余血量相等时，直接使用大招杀死。
方案二、二分答案
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)void solve()&#123;	int n;	cin&gt;&gt;n;	vector&lt;int &gt; vec(n+5);//血量数组	int sum = 0;	for(int i = 1;i&lt;=n;i++)&#123;		scanf(&quot;%lld&quot;,&amp;vec[i]);		sum += vec[i];	&#125;	sort(vec.begin()+1,vec.begin()+1+n);	int x = 0;	int ans = 0;	for(int l = 1,r = n;l&lt;=r;)&#123;//l，r双指针		if(x + sum &gt;= 2 * vec[r])&#123;//如果杀死小怪能够获得足够的连击值			while(x &lt; vec[r])&#123;//杀死小怪,直到够杀死大怪				x += vec[l];				ans += vec[l];				sum -= vec[l];				l++;			&#125;			if(x != vec[r]) &#123;//如果普攻砍多了				l--;				vec[l] = x - vec[r];				ans -= vec[l];				sum += vec[l];			&#125;			x = 0;			ans++;			sum -= vec[r];			r--;		&#125;		else &#123;			while(l&lt;r)&#123;//不够的话，先普攻杀死其他所有的小怪				x += vec[l];				ans += vec[l];				l ++;			&#125;			int t = (vec[r] + x) / 2;//找到斩杀线			ans += vec[r] - t;			if(t != 0) ans++; 			break;		&#125;	&#125;	cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;	int T;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
D. XOR Construction给出n-1个数 a_1,a_2,...,a_{n-1} ，你需要构造出一个排列b。使得b_1 \oplus b_2 = a_1 , b_2 \oplus b_3 = a_2,...,b_{n-1} \oplus b_n = a_{n-1} 。
可以发现，只要我们知道了b1，就可以递推出b_2,b_3,...,b_n:
b_2 = b_1 \oplus a_1\\ b_3= b_2 \oplus a_2 = b_1 \oplus a_1 \oplus a_2 \\...
我们设F(x) 代表a的前x项的异或和。 那么b_i =b_1 \oplus  F(i-1)。
我们最终以此方法构造的b数组可能会不映射到0~n-1上，但一定可以保证b中的每个数都不同。因此我们需要判断是否存在b_i\ge n ，如果存在，那么这个b数组就不成立。如果我们遍历b_1为0~n-1， 对于每个b_1  产生的b数组进行判断，那么时间复杂度就会变为O(n * n) ，导致超时。
我们可以考虑使用字典树存储a的各个前缀和，然后通过遍历字典树来在log2n的复杂度下找到最大的b_i ,并进行合理性判断。这样我们的时间复杂度就降到了O(nlog2n)
代码#include&lt;bits/stdc++.h&gt;using namespace std;int nex[400005][2];//注意如果只开2e5+5的数组容量,会产生段错误int cnt = 0;int n;void ins(int x)&#123;//向字典树中插入一个数	int p = 0;	for(int i = 20;i&gt;=0;i--)&#123;		int t = (x &gt;&gt; i) &amp; 1;		if(!nex[p][t])&#123;			nex[p][t] = ++cnt;		&#125;		p = nex[p][t];	&#125;	return ;&#125;bool func(int x)&#123;//查找最大的b元素，并判断是否小于等于n-1	int ans = 0;	int p = 0;	for(int i = 20;i&gt;=0;i--)&#123;		int t = (x &gt;&gt; i) &amp; 1;		if(nex[p][t ^ 1])&#123;			ans += (1 &lt;&lt; i);			p = nex[p][t ^ 1];		&#125;else p = nex[p][t];	&#125;	return ans &lt; n;&#125;int main()&#123;	cin&gt;&gt;n;	vector&lt;int&gt; vec(n+5);	for(int i =1;i&lt;n;i++)&#123;//求前缀异或，以及插入进字典树中		cin&gt;&gt;vec[i];		vec[i] ^= vec[i-1];		ins(vec[i]);	&#125;	for(int i = 0;i&lt;n;i++)&#123;//遍历b1		if(func(i)) &#123;//如果成立			for(int j = 0;j&lt;n;j++)&#123;//输出b数组				cout&lt;&lt;(vec[j] ^ i)&lt;&lt;&quot; &quot;;			&#125;			break;		&#125;	&#125;	return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 157</title>
    <url>/990c826af7c6/</url>
    <content><![CDATA[[Dashboard - Educational Codeforces Round 157 (Rated for Div. 2) - Codeforces](https://codeforces.com/contest/1895)
C. Torn Lucky Ticket题意给出n个**长度不大于5**的字符串s_1，s_2，...，s_n（只由数字组成）， 你需要选择其中两个串undefinedi，j)（i和j可以相等，并且(i,j)与(j,i)视为两个不同的选择）,  令s = s_i + s_j$。 问有多少种选择，使得：

s的长度为偶数
s的前一半的数字的总和等于后一半的数字总和

1\le n \le 2*10^5
思路我们使用string类型的一维数组dat存储原始数据。 使用二维的vector数组vec（算上vector一共三维）存储处理后的数据。
vec[i][j] 中存储的元素表示长度为 i的字符串， 他的后缀s[j,i-1] 的数字的总和 减去 前缀s[0,j-1]的数字总和。
我们对所有的vector类型进行排序。以便于我们使用lower_bound和upper_bound 来在logn的复杂度下查找其中某个数的数量。
之后我们遍历所有的字符串s_i,  把他作为前半部分，我们考虑如下方法来寻找合适后半部分：
假设后半部分字符串为s_j ，前半部分的长度为len_i,后半部分为len_j。那么如果

len_i = len_j ，我们需要计算出s_i 中的数字和k，然后在长度为len_i的串中找总和为k的数量。也就是

upper_bound(vec[leni][0].begin(),vec[leni][0].end(),k) - lower_bound(vec[leni][0].begin(),vec[leni][0].end(),k)  `

len_i < len_j , 我们需要从后半部分的字符串中提取出一些前缀字符（最多两个），与前半部分拼接。因此要找的是
upper_bound(vec[lenj][t].begin(),vec[lenj][t].end(),k) - lower_bound(vec[lenj][t].begin(),vec[lenj][t].end(),k) 其中t = \frac{len_j - len_i}{2} 

len_i > len_j ，此时我们需要根据lenj的长度来计算前半部分的前缀减去后缀的值k，然后在vec[lenj][0] 中搜索k的数目。比如此时len_i = 5 ，而len_j = 3 ,那么k = s[0]+s[1]+s[2]+s[3]-s[4] 。而如果len_i=5,len_j = 1 ，那么k = s[0]+s[1]+s[2]-s[3]-s[4] 。 


代码#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)typedef pair&lt;int,int&gt; PII;vector&lt;int&gt; vec[7][7];//vecpre[i][j] 长度为i的串的j前缀// vector&lt;int&gt; vecend[7][7];const int MAXN = 2e5+5;string dat[MAXN];int t;int find(int len,int pre)&#123;	return upper_bound(vec[len][pre].begin(),vec[len][pre].end(),t) -\	lower_bound(vec[len][pre].begin(),vec[len][pre].end(),t);&#125;void solve()&#123;	int n;	cin&gt;&gt;n;	string str;	for(int i =1;i&lt;=n;i++)&#123;		cin&gt;&gt;str;		dat[i] = str;		int len = str.length();		int sum = 0;		for(int i = 0;i&lt;len;i++)&#123;			sum += str[i] - &#x27;0&#x27;;		&#125;		int t = 0;		vec[len][0].push_back(sum);		for(int i =0;i&lt;str.length()/2;i++)&#123;			t = t + str[i] - &#x27;0&#x27;;			vec[len][i+1].push_back(sum - 2 * t);		&#125;	&#125;	for(int i = 1;i&lt;=5;i++)&#123;		sort(vec[i][0].begin(),vec[i][0].end());		for(int j = 1;j&lt;=5;j++)&#123;			sort(vec[i][j].begin(),vec[i][j].end());		&#125;	&#125;	int ans = 0;	for(int i = 1;i&lt;=n;i++)&#123;		if(dat[i].length() == 1)&#123;			t = dat[i][0] - &#x27;0&#x27;;			ans += find(1,0);			ans += find(3,1);			ans += find(5,2);			&#125;		if(dat[i].length() == 3)&#123;			t = (dat[i][0] - &#x27;0&#x27;) + (dat[i][1] - &#x27;0&#x27;) + (dat[i][2] - &#x27;0&#x27;);			ans += find(3,0);			ans += find(5,1);			t -= 2 * (dat[i][2] - &#x27;0&#x27;);			ans += find(1,0);			&#125;		if(dat[i].length() == 5)&#123;			t = 0;			for(int j = 0;j&lt;5;j++) t += dat[i][j] - &#x27;0&#x27;;			ans += find(5,0);			t -= 2 * (dat[i][4] - &#x27;0&#x27;);			ans+= find(3,0);			t -= 2 * (dat[i][3] - &#x27;0&#x27;);			ans += find(1,0);			&#125;		if(dat[i].length() == 2)&#123;			t = dat[i][0] - &#x27;0&#x27; + dat[i][1] - &#x27;0&#x27;;			ans += find(2,0);			ans += find(4,1);		&#125;		if(dat[i].length() == 4)&#123;			t = 0;			for(int j = 0;j&lt;4;j++) t += dat[i][j] - &#x27;0&#x27;;			ans += find(4,0);			t -= (dat[i][3] - &#x27;0&#x27;) * 2;			ans += find(2,0);		&#125;	&#125;	cout&lt;&lt;ans;&#125;signed main()&#123;	int T;	T = 1;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 157</title>
    <url>/cb21718951db/</url>
    <content><![CDATA[[Educational Codeforces Round 161 (Rated for Div. 2)](https://codeforces.com/contest/1922)
C. Closest Cities题意有n个城市， 他们分别在坐标轴上的点a_1,a_2...,a_n  ，我们定义从城市i到城市j之间的花费的金币为：

如果 j是i的最近城市，那么花费1个金币
否则花费 |a_j - a_i| 个金币

现在给出一些询问，需要你回答从x_i号城市到 y_i号城市之间的花费的最少金币
思路首先我们知道：一个城市的最近城市 一定是和他相邻的两个城市中的一个。 
因此我们根据贪心思想可以知道， 如果我们要从第i个城市到第j个城市， 那么我们将中间的城市全部依次经过一遍是最优的（因为经过的话就有可能只花费1金币）
于是本题就转换为了区间和的问题，可以用前缀和来解决：
当x y时，同理使用倒序的前缀和（后缀和）即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	vector&lt;int&gt; vec(n+5);	vector&lt;int&gt; pre(n+5);	vector&lt;int&gt; last(n+5);	vector&lt;int&gt; sign(n+5);	vec[0] = -INF;	vec[n+1] = INF;	rep(i,1,n)&#123;		cin&gt;&gt;vec[i];	&#125;	rep(i,1,n)&#123;		if(vec[i] - vec[i-1] &lt; vec[i+1]-vec[i])&#123;			sign[i] = -1;		&#125;else sign[i] = 1;	&#125;	rep(i,2,n)&#123;		if(sign[i-1] == 1) pre[i] = 1;		else pre[i] = vec[i]-vec[i-1];		pre[i] += pre[i-1];	&#125;	per(i,n-1,1)&#123;		if(sign[i+1] == -1) last[i] = 1;		else last[i] = vec[i+1]-vec[i];		last[i] += last[i+1];	&#125;	int q;	cin&gt;&gt;q;	while(q--)&#123;		int u,v;		cin&gt;&gt;u&gt;&gt;v;		if(u &lt; v) &#123;			cout&lt;&lt;pre[v] - pre[u]&lt;&lt;&#x27;\n&#x27;;		&#125;else&#123;			cout&lt;&lt;last[v] - last[u]&lt;&lt;&#x27;\n&#x27;;		&#125;	&#125;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
D. Berserk Monsters题意有n个怪兽并排，给出一些怪兽的攻击力a和防御值d，下面进行n轮如下操作：
每一个怪兽会收到相邻的活着的怪兽攻击力之和的伤害，如果伤害大于自身的防御值d ，那么自己就会在这轮结束时死亡。
请你指出每轮有几只怪兽死亡
思路每轮过后怪兽的左右邻居都可能会改变， 所以这题适合用双链表来存储怪兽之间的相邻关系。
我们发现当一个怪兽死亡后，只有和他相邻的怪兽， 在下一轮才有可能死亡。（如果一个怪兽的两个邻居都没有死亡，并且自己也没有死亡，那么下一轮这个怪兽同样不会被这两个邻居杀死）
因此在第i+1的判断中， 只需要判断第i轮中死亡的怪兽的邻居们就好
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	vector&lt;int&gt; a(n+5);// 攻击力	vector&lt;int&gt; d(n+5);// 防御值	rep(i,1,n) cin&gt;&gt;a[i]; 	rep(i,1,n) cin&gt;&gt;d[i];	vector&lt;bool&gt; over(n+5); // 是否死亡	vector&lt;int&gt; next;// 下一轮需要判断哪些怪兽	vector&lt;int&gt; pre(n+5);// 左邻居	vector&lt;int&gt; nxt(n+5);// 右邻居	rep(i,1,n)&#123;		pre[i] = i-1;nxt[i] = i+1;// 设置左右邻居		next.push_back(i);	&#125;	rep(i,1,n)&#123;		vector&lt;int&gt; tmp; //用来临时存储下一轮需要处理的邻居		vector&lt;int&gt; pp; // 用来记录这轮死亡的怪兽		int ans = 0;		for(auto p : next)&#123; // 遍历所有本轮需要处理的怪兽			if(over[p]) continue; // 如果已经死了就continue			if(a[pre[p]] + a[nxt[p]] &gt; d[p])&#123; // 如果这个怪兽要死				over[p] = 1;				if(pre[p]!=0) tmp.push_back(pre[p]); // 有左邻居				if(nxt[p]!=n+1) tmp.push_back(nxt[p]);//有右邻居				ans ++;				pp.push_back(p);			&#125;		&#125;		for(auto p : pp)&#123; // 在双链表中删除本轮死亡的怪兽			pre[nxt[p]] = pre[p];			nxt[pre[p]] = nxt[p];		&#125;		cout&lt;&lt;ans&lt;&lt;&#x27; &#x27;;		next = tmp;	&#125;	puts(&quot;&quot;);	return ;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 157</title>
    <url>/32c1801cbe6c/</url>
    <content><![CDATA[[Educational Codeforces Round 168 (Rated for Div. 2)](https://codeforces.com/contest/1997)
A. Strong Password题意给你一个只含有小写字母的字符串S， 它的价值为：

第一个字母的价值为2。
之后每个字母，如果和上一个字母相同，价值为1，否则价值为2。

你现在需要向S中插入一个任意字符，使得插入后的字符的代价尽可能大。输出插入字符后的字符串。
思路如果存在两个相邻相同字母， 那么我们就在他们中间插入一个不同的字母，会使得总的代价加三。
如果上述条件不成立， 我们就在最后一个字符的后面加上一个不同的字母，使得总的代价加二。 
代码 #include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    string str;    cin&gt;&gt;str;    rep(i,1,str.size()-1)&#123;        if(str[i] ==str[i-1])&#123;            char ch = &#x27;b&#x27;;            if(str[i] == &#x27;b&#x27;) ch = &#x27;a&#x27;;            rep(j,0,i-1) cout&lt;&lt;str[j];            cout&lt;&lt;ch;            rep(j,i,str.size()-1) cout&lt;&lt;str[j];            puts(&quot;&quot;);            return ;          &#125;    &#125;    cout&lt;&lt;str;    if(str.back() == &#x27;a&#x27;) cout&lt;&lt;&#x27;b&#x27;;    else cout&lt;&lt;&#x27;a&#x27;;    cout&lt;&lt;endl;    return ;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B. Make Three Regions题意有一个2行n列的表格， 其中一些部分被涂为黑色，剩余白色部分是连通的。
![img](https://espresso.codeforces.com/6dfed67a1987c8a2482463d6e5c922180d7df9bf.png)
![img](https://espresso.codeforces.com/f8b4790e686eb03a7df05efbf9d8588b3c4d3a14.png)
如上图中将第一行第三列的格子染为黑色后 ，白色连通块被分为了三部分（红色、绿色、蓝色区域）
问有多少个白色格子满足：如果将该白色格子填为黑色，那么剩下的白色格子会组成三个连通块。
思路当且仅当 **“某一行的白块的两边都是黑块，并且在另一行对应位置为连续三个白块”**时，会满足条件。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;    cin&gt;&gt;n;    string a,b;    cin&gt;&gt;a&gt;&gt;b;    a = &#x27;.&#x27; + a + &#x27;.&#x27;;    b = &#x27;.&#x27; + b + &#x27;.&#x27;;    int ans = 0;    rep(i,1,n)&#123;        if(a[i] == &#x27;.&#x27; &amp;&amp; a[i-1] == &#x27;x&#x27; &amp;&amp; a[i+1]==&#x27;x&#x27; &amp;&amp; b[i] == &#x27;.&#x27; &amp;&amp; b[i-1] == &#x27;.&#x27; &amp;&amp; b[i+1] == &#x27;.&#x27;)&#123;            ans ++;        &#125;        if(b[i] == &#x27;.&#x27; &amp;&amp; b[i-1] == &#x27;x&#x27; &amp;&amp; b[i+1]==&#x27;x&#x27; &amp;&amp; a[i] == &#x27;.&#x27;  &amp;&amp; a[i-1] == &#x27;.&#x27; &amp;&amp; a[i+1] == &#x27;.&#x27;)&#123;            ans ++;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C. Even Positions题意给你一个字符串，只包含( , ) ,_ 三种字符，请你将_ 都填为(或)， 使得字符串为“正则括号序列”（即互相匹配的括号对）
定义一个“正则括号序列”的代价为，所有互相匹配的括号对的距离的总和。如(())()之中， (__)__ 代价为4-1 = 3，_()___ 和____() 的代价均为1， 总字符串的代价为3+1+1 = 5
你需要使得构造的正则括号序列的代价尽可能小，输出可能的最小代价。
保证在字符串的长度为偶数，并且在奇数位为(或) ， 在偶数位均为 _ 。
思路按照正常方法（即栈的方法）进行括号匹配，在遇到_ 时，我们考虑，如果前面还有没有配对的左括号，那么我们应该在此处填写右括号，使它尽早配对，尽可能减少产生的代价。
代码 #include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n;cin&gt;&gt;n;    string str;    cin&gt;&gt;str;    stack&lt;int&gt; st;    st.push(0);    int ans = 0;    for(int i = 1;i&lt;str.size();i++)&#123;        if(str[i] == &#x27;_&#x27;)&#123;            if(st.size() == 0) &#123;                st.push(i);                continue;            &#125;else&#123;                ans += i - st.top();                st.pop();            &#125;        &#125;else if(str[i] == &#x27;(&#x27;)&#123;            st.push(i);        &#125;else&#123;            ans += i - st.top();            st.pop();        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D. Maximize the Root题意给你一棵树，每个节点都有一个初始值，然后你需要进行任意次如下操作：

选择一个非叶子节点u（并且保证该节点的所有子孙节点的值都大于0）
将节点u的所有子孙节点（即以该节点为子树的所有非根节点）的值减去1
令节点u 的值加一

问在你进行一定次数操作后，根节点的值最大为多少
思路考虑树形DP，我们对一个节点操作时，只关心在子孙节点中的最小值是多少。那么设dp[i] 表示在进行一定次数操作后，以i 号节点为根的子树，最小值最大是多少。
如果一个节点是叶子节点，由于无法进行任何操作，那么他的权值是自己的值本身。
对于一个非叶子节点u，我们对他的所有子节点v_1,v_2,...,v_k的dp值取min，得到以u为根的所有子孙节点的最小值t_u (不包括u) , 于是我们考虑最大化min(t_u,a_u)，我们将t_u和u本身的权值a_u进行比较 ， 如果 t_u  a_u 那么我们便可以进行undefinedfrac{t_u - a_u}{2}次操作，来最大化min(t_u,a_u)$ 。
总的dp传递式为dp[u] = MAX(t_u,\frac{t_u+a[u]}{2}) ,其中t_u = MIN_{v \in son(u)}dp[v]
于是我们进行搜索，并维护dp数组， 最终得到了每一个节点的以该节点为根的子树中，所有节点的最小值的最大情况 ， 我们只关心根节点的孩子节点（即高度为1的节点）的dp值， 对他们取min后，即为最终能在根节点进行的操作数， 于是最终的答案为a[root] + MIN_{v \in son(root)} dp[v]
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int a[200005];vector&lt;int&gt; sons[200005];void dfs(int x)&#123;    int mn = INF;    if(sons[x].empty()) return ;    for(auto v : sons[x])&#123;        dfs(v);        mn = min(mn,a[v]);    &#125;    if(a[x] &gt; mn)&#123;        a[x] = mn;        return ;    &#125;    int ope = (mn - a[x])/2;    a[x] += ope;    return ;&#125;void solve()&#123;    int n;    cin&gt;&gt;n;    rep(i,1,n)&#123;        a[i] = 0;sons[i].clear();    &#125;    rep(i,1,n) cin&gt;&gt;a[i];    rep(i,2,n)&#123;        int fa;cin&gt;&gt;fa;        sons[fa].push_back(i);    &#125;    for(auto v : sons[1])&#123;        dfs(v);    &#125;    int mn = INF;    for(auto v : sons[1])&#123;        mn = min(mn,a[v]);    &#125;    cout&lt;&lt;a[1]+mn&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Pinely Round 4 (Div. 1 + Div. 2)</title>
    <url>/925ab40b6aec/</url>
    <content><![CDATA[[Pinely Round 4 (Div. 1 + Div. 2)](https://codeforces.com/contest/1991)
A. Maximize the Last Element题意给一个长度为n的数组 ,  (n为奇数) ， 每次你可以删除数组中相邻的两个数，直到数组剩下一个数，问数组最终剩下的那个数最大为多少。
思路可以发现， 我们最终只有可能留下奇数位的元素a_1,a_3,...,a_n  ，对其取max即可。
证明： 整个数组中有undefinedfrac{n+1}{2}个奇数数位，\frac{n-1}{2}个偶数数位， 即奇数下标一定比偶数多一个， 而对于每次删除操作，一定会删除一个奇数下标的元素和一个偶数下标的元素（因为二者相邻）， 并且不会改变其他下标的奇偶性， 因此进行\frac{n-1}{2}轮删除后， 奇数下标只剩1$ 个，而偶数下标剩0个。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	int ans = 0;	for(int i = 1;i&lt;=n;i+=2)&#123;		int num;cin&gt;&gt;num; ans = max(ans,num);	&#125;	cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
B. AND Reconstruction题意给你一个长度为n-1 的数组b，请你构造一个长度为n的数组a，满足a[i] \& a[i+1] = b[i] , 其中undefined&amp;$表示按位与。
若构造不出合法的数组a  ,输出-1
思路我们既然要构造a数组，那么就考虑a[i] 受到b的哪些元素影响，可以发现a[i] 只和b[i-1] ,b[i] 有关， 并且b[i-1],b[i] 中为1的数位，在a[i] 中都应该是1，  所以我们让a[i] = b[i-1] | b[i] 就可以得到最终的a[i]数组， 然后我们再按顺序判断一下对于所有的b[i]是否都满足a[i]\&a[i+1] = b[i] (1\le i \le n-1) 
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	vector&lt;int&gt;a(n+5),b(n+5);		for(int i = 1;i&lt;n;i++)&#123;		cin&gt;&gt;b[i];	&#125;	for(int i = 1;i&lt;=n;i++)&#123;		a[i] = b[i-1] | b[i];	&#125;	for(int i = 1;i&lt;n;i++)&#123;		if((a[i] &amp; a[i+1])!= b[i]) &#123;cout&lt;&lt;-1&lt;&lt;endl;return ;&#125;	&#125;	for(int i = 1;i&lt;=n;i++)&#123;		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;	&#125;	puts(&quot;&quot;);&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
C. Absolute Zero题意给你一个长度为n的数组a，a_1,a_2,...,a_n , （0\le a[i] \le 10^9） 你要进行至多40次操作（无需令操作数最少），  每次操作选择一个数x， 并令所有的a_i,(1\le i\le n) 变为|a_i - x | , 其中的|v| 表示v 的绝对值。 
在进行完一些操作之后，让整个a数组全部变为0。 如果无法实现， 输出-1。
思路首先考虑不成立的情况， 如果我们令数组中所有的元素都同时减去一个偶数，那么他们的奇偶性都会保持不变； 相反如果同时减去一个奇数，那么他们的奇偶性都会变化。 而我们最终要求所有的数都是0，即都是偶数。于是我们就可以发现，**如果数组a中同时含有奇数以及偶数，那么就无法让a全部变为0。** 
接下来我们考虑如何解决这道题。最多40次使我们很容易想到按位处理。
起初所有的a[i] 都满足a[i] \le 10^9 <  2^{30} , 所以我们第一次操作选择2^{29} ，便可以让所有的数都满足0\le a[i] \le 2^{29} , 
再接着我们第二次操作选择2^{28} ，  于是所有的数都满足了0\le a[i] \le 2^{28} 
不断重复如上选择，直到最后选择了2^0  。
我们不断如上选择会不断缩小a数组元素的取值范围。使得最终都变为0 。
需要特殊注意的是，此时如果a数组原本为奇数数组，那么所有的数都变为了0 。 但如果a数组是偶数数组，那么最终还要在选择一次0.
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	vector&lt;int&gt; a(n+5);	rep(i,1,n)&#123;		cin&gt;&gt;a[i];	&#125;	int odd=0,even=0;    //特判是否能够成立	rep(i,1,n)&#123;		if(a[i]%2) odd=1;		else even=1;	&#125;	if(odd&amp;&amp;even)&#123; // 如果同时有奇数和偶数，就不能		cout&lt;&lt;-1&lt;&lt;endl;		return ;	&#125;	vector&lt;int&gt; ans;//存储答案	for(int i=29;i&gt;=0;i--) ans.push_back(1&lt;&lt;i);    if(even) ans.push_back(1);	cout&lt;&lt;ans.size()&lt;&lt;endl;	for(auto p : ans)&#123;		cout&lt;&lt;p&lt;&lt;&#x27; &#x27;;	&#125;puts(&quot;&quot;);&#125; signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
D. Prime XOR Coloring题意给你一个无向图，图中有n个节点，编号从1到n。  如果u \oplus v 是一个质数 （u \oplus v表示u和v进行按位异或） ，那么u和v之间有一条边相连。 请你给这n个节点染色，使得不存在两个相邻的节点有相同的颜色。
思路先给出结论，所有的节点最多只需要4种颜色。
因为节点1,3,4,6 所以他们四个的颜色必须不同，我们为他们四个分配四种颜色。
于是当n6 时，我们令a[i] = i\%4+1 , 这样就保证了任意两个相同颜色的节点的差一定是4的倍数，那么他们的异或就一定不是质数。也就满足了题意。。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;cin&gt;&gt;n;	if(n == 1)&#123;		cout&lt;&lt;&quot;1\n1\n&quot;;return ;	&#125;	if(n == 2)&#123;		cout&lt;&lt;&quot;2\n1 2\n&quot;;return ;	&#125;	if(n == 3)&#123;		cout&lt;&lt;&quot;2\n1 2 2\n&quot;;return ;	&#125;	if(n == 4)&#123;		cout&lt;&lt;&quot;3\n1 2 2 3\n&quot;;return ;	&#125;	if(n==5)&#123;		cout&lt;&lt;&quot;3\n1 2 2 3 3\n&quot;;return ;	&#125;	vector&lt;int&gt; color(n+5);	for(int i = 1;i&lt;=4;i++)&#123;		color[i] = i;	&#125;	for(int i = 5;i&lt;=n;i++)&#123;		int t = i ^ 2;		if(i%2)&#123;			color[i] = 1;			if(t &lt;= i) color[i] = 4 - color[t];		&#125;else &#123;			color[i] = 2;			if(t &lt;= i) color[i] = 6 - color[t];		&#125;	&#125;w	cout&lt;&lt;&quot;4\n&quot;;	for(int i = 1;i&lt;=n;i++)&#123;		cout&lt;&lt;color[i]&lt;&lt;&#x27; &#x27;;	&#125;	puts(&quot;&quot;);&#125;signed main()&#123;	int T = 1;	cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>XCPC模板</title>
    <url>/b5a224851012/</url>
    <content><![CDATA[线段树struct Info&#123;    LL sum = 0;&#125;; struct Tag&#123;    LL add = 0;&#125;; Info operator+(const Info &amp;a, const Info &amp;b)&#123;    return &#123;a.sum + b.sum&#125;;&#125; void apply(Info &amp;x, Tag &amp;a, Tag f)&#123;    if (f.add)&#123;        a.add += f.add;        x.sum += f.add;    &#125;&#125; template&lt;class Info, class Tag&gt;struct LazySegmentTree&#123;    int n;    vector&lt;Info&gt; info;    vector&lt;Tag&gt; tag;     LazySegmentTree() &#123;&#125;     LazySegmentTree(int n, Info _init = Info())&#123;        init(vector&lt;Info&gt;(n, _init));    &#125;     LazySegmentTree(const vector&lt;Info&gt; &amp;_init)&#123;        init(_init);    &#125;     void init(const vector&lt;Info&gt; &amp;_init)&#123;        n = (int)_init.size();        info.assign((n &lt;&lt; 2) + 1, Info());        tag.assign((n &lt;&lt; 2) + 1, Tag());        function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r)&#123;            if (l == r)&#123;                info[p] = _init[l - 1];                return;            &#125;            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m + 1, r);            pull(p);        &#125;;        build(1, 1, n);    &#125;        void pull(int p)&#123;        info[p] = info[2 * p] + info[2 * p + 1];    &#125;        void apply(int p, const Tag &amp;v)&#123;        ::apply(info[p], tag[p], v);    &#125;        void push(int p)&#123;        apply(2 * p, tag[p]);        apply(2 * p + 1, tag[p]);        tag[p] = Tag();    &#125;        void modify(int p, int l, int r, int x, const Info &amp;v)&#123;        if (l == r)&#123;            info[p] = v;            return;        &#125;        int m = (l + r) / 2;        push(p);        if (x &lt;= m)&#123;            modify(2 * p, l, m, x, v);        &#125;         else&#123;            modify(2 * p + 1, m + 1, r, x, v);        &#125;        pull(p);    &#125;        void modify(int p, const Info &amp;v)&#123;        modify(1, 1, n, p, v);    &#125;        Info query(int p, int l, int r, int x, int y)&#123;        if (l &gt; y || r &lt; x)&#123;            return Info();        &#125;        if (l &gt;= x &amp;&amp; r &lt;= y)&#123;            return info[p];        &#125;        int m = (l + r) / 2;        push(p);        return query(2 * p, l, m, x, y) + query(2 * p + 1, m + 1, r, x, y);    &#125;        Info query(int l, int r)&#123;        return query(1, 1, n, l, r);    &#125;        void modify(int p, int l, int r, int x, int y, const Tag &amp;v)&#123;        if (l &gt; y || r &lt; x)&#123;            return;        &#125;        if (l &gt;= x &amp;&amp; r &lt;= y)&#123;            apply(p, v);            return;        &#125;        int m = (l + r) / 2;        push(p);        modify(2 * p, l, m, x, y, v);        modify(2 * p + 1, m + 1, r, x, y, v);        pull(p);    &#125;        void modify(int l, int r, const Tag &amp;v)&#123;        return modify(1, 1, n, l, r, v);    &#125;&#125;;
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习数学原理笔记</title>
    <url>/887930e5b441/</url>
    <content><![CDATA[可能会出现公式加载错误的情况，可以直接下载[pdf版本](https://lsk404.github.io/files/RLnote.pdf)。
强化学习数学原理第一章基本概念
grid-world example ： 一个机器人走网格的经典例子，机器人尽量避免进入forbidden grid、尽量减少拐弯、不要走出边界、……

state: 状态，表示为一个节点，在grid-world中可以表示为一个格子（也可以添加其他信息到状态，如速度等）

state space：状态空间，所有状态的集合。

action：行动，能够使得状态变化的动作。（如向上/下/左/右移动，等）

action space：行动的集合，通常依赖于当前的状态。

state transition：状态转移，从一个状态移动到另一个状态。
  s_5 \overset{a_1}{\rightarrow} s_6 表示从状态s_5 经过动作a_1 到达状态 a_6

state transition probability: 状态转移的条件概率。（例如：p(s_2|s_1,a_2) = 0.8 代表在状态s_1，行动a_2 下，s_2的概率是0.8)

Policy: 策略，用箭头来表示。表示在某个状态更倾向于走哪个action
  undefinedpi(a_1|s_1)=0 ,\pi(a_2|s_1)=1,\pi(a_3|s_1)=0 ,\pi(a_4|s_1)=0表示在状态s_1有1的概率进行行动a_2。显然\sum_{i=1}^k \pi(a_i|s_1) = 1$

reward: 他是一个实数，代表我们的奖励，如果reward>0,则代表希望它发生，reward]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>强化学习</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>codeTONround6</title>
    <url>/f1a11c2d28d4/</url>
    <content><![CDATA[[CodeTON Round 6 (Div. 1 + Div. 2, Rated, Prizes!)](https://codeforces.com/contest/1870)
（2023年9月18日晚）
C. Colorful Table题意给出n个数a_1 ,a_2,...,a_n ，以及一个数k，所有数满足 1\le a_i \le k ,数组b是一个nxn的二维数组，其中 b_{i,j} = min(a_i,a_j) ,对于每一个数 1 \le x \le k ，求出面积最小的矩阵，使得矩阵中涵盖了b数组中的所有的x，输出矩阵的两边之和（例如矩阵为3x3就输出6（6=3+3），矩阵为2x5就输出7（7=2+5））。
思路例如a数组为（k = 4）：




1
2
3
4
1









那么b数组为：




b[i,j]
a_1 = 1
a_2 = 2
a_3 = 3
a_4 = 4
a_5 = 1




a_1 = 1
1
1
1
1
1


a_2 = 2
1
2
2
2
1


a_3 = 3
1
2
3
3
1


a_4 = 4
1
2
3
4
1


a_5 = 1
1
1
1
1
1




这样就可以得出我们应该输出
10，6，4，2
我们可以按照a_i由大到小地填充b表格，每次填充a_i对应的行和列，并且直接覆盖之前填充好的数据，最终就能得出b数组。
![CodeTON Round 6 (Div. 1 + Div. 2, Rated, Prizes!)](C:\Users\ACMLAB\AppData\Roaming\Typora\typora-user-images\CodeTON Round 6_1.png)
可以发现，大数会被更小的数”蚕食“以3为例，起初3占满了所有行和列，但由于有更小的数1和2，在填充1和2时，1，2数字所在的行列（1,2,5)都被覆盖掉了。导致只剩下第3，4行存在3。因此面积最小应该为2x2 ，输出4。
由此推广出来，一个数x会这些行留下自己的身影：i,(x \le a_i), 因此对于任何一个数x，我们只需要找到 区间[l,r] 使得对于任意的 a_i >= x 都有l \le i \le r 。 也就是 [l,r]涵盖了所有的大于等于x的数，此时这个最小矩阵的边长就是undefinedr-l+1),需要输出2*(l-r+1)$ 。
特判：当一个数在a中不存在时，需要输出0。
代码#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    int t ;    cin&gt;&gt;t;    while(t--)&#123;        int n,k;        scanf(&quot;%d %d&quot;,&amp;n,&amp;k);        vector&lt;bool&gt; isok(k+5);//记录某个数是否出现过，请注意这里的数组大小应该是k而不是n         vector&lt;int&gt; v(n+5);//原始数据        vector&lt;int&gt; qz(n+5);//前缀, qz[i]表示前i个数中的最大值        vector&lt;int&gt; hz(n+5);//后缀，hz[i]表示后i个数中的最大值        for(int i = 1;i&lt;=n;i++)&#123;            scanf(&quot;%d&quot;,&amp;v[i]);            isok[v[i]] = true;        &#125;        qz[0] = hz[n+1] = 0;        for(int i = 1;i&lt;=n;i++)&#123;            qz[i] = max(qz[i-1],v[i]);        &#125;        for(int i = n;i&gt;=1;i--)&#123;            hz[i] = max(hz[i+1],v[i]);        &#125;        int l = 1,r = n;        for(int i = 1;i&lt;=k;i++)&#123;            if(!isok[i]) &#123;cout&lt;&lt;0&lt;&lt;&quot; &quot;;continue;&#125;            while(qz[l]&lt;i) l++;//跳过所有小于i的值            while(hz[r]&lt;i) r--;            cout&lt;&lt;(r-l+1)*2&lt;&lt;&quot; &quot;;        &#125;        puts(&quot;&quot;);    &#125;    return 0;&#125;
D - Prefix Purchase题意给出一个n个数的数组a. 起初 a_1 = a_2 =...= a_n = 0 ,再给出一个n个数的数组c, 现在你手上有k个金币，可以进行如下操作任意次：从数组c中选择一个数c_i ，花费 c_i个金币，使得数组a的前i项加一，即 a_j+=1,(1\le j \le i)  
问如何操作才能使得最终的数组a 的字典序尽可能大。  
思路首先我们知道，选择越靠后，他的“价值”就越高。因此如果存在 c_i \ge c_j 且 i < j ，那么选择c_j 就一定优于 c_i ,因此我们可以将这种情况下的c_i 的值改为c_j 。在这种操作之后，我们会得到一个单调递增的c数组。 之后进行如下操作首先尽可能地购买c_1  ，此时可能手上剩余一些钱（设为left），由于越靠后”价值“越高，所以我们可以继续花费left来升级（升级指的就是 将一部分c_i 变为c_{i+1} ， 显而易见，我们应当尽可能地花费剩余的钱去升级。因此有如下递推式 a_i = min(a_{i-1},\frac{left}{c_i - c_{i-1}}) 。
最终得到的a数组就是我们所需要的a数组
代码#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void solve()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    vector&lt;int&gt; c(n+5);//c数组    for(int i = 1;i&lt;=n;i++)&#123;        scanf(&quot;%d&quot;,&amp;c[i]);    &#125;    int k;    scanf(&quot;%d&quot;,&amp;k);//k    //对c数组进行预处理    int mn = 1e9;    for(int i = n;i&gt;=1;i--)&#123;        mn = min(mn,c[i]);        c[i] = mn;    &#125;    vector&lt;int&gt; a(n+5);//a数组    a[1] = k / c[1];    int left = k % c[1];    for(int i = 2;i&lt;=n;i++)&#123;//递推        int cha = c[i] - c[i-1];        if(cha == 0)&#123;            a[i] = a[i-1];            continue;        &#125;        a[i] = min(a[i-1],left/cha);        left -= cha * a[i];    &#125;    for(int i = 1;i&lt;=n;i++)&#123;        printf(&quot;%d%c&quot;,a[i],&quot; \n&quot;[i==n]);    &#125;&#125;int main()&#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基础语法</title>
    <url>/887d60201e7d/</url>
    <content><![CDATA[Markdown语法安装离线编辑软件TyporaTypora下载。[官网](https://typoraio.cn/)下载后去github上下载破解器https://github.com/WittonBell/typoraCracker
在线协同编辑器CodiMD在线协同编辑markdown http://120.26.48.253:3000/( 搭建在我的服务器上，所以一年后(2025/3/20)就寄了)
常用语法
中间空出一行(相当于按了两次回车)则新起一段

使用#加一个空格来表示标题


# 一号标题## 二号标题### ...###### 六号标题

代码块，使用反引号(在键盘左上角)

一个反引号是段内代码段内代码 ，常用作关键字标记。 或者用来阻止解析公式undefinedabcundefined
代码块:每边三个反引号(在键盘的左上角，tab的上面)，中间包裹住的行就是代码块的部分。
这是一个代码块代码块可以偶很多行代码块还可以选择代码语言来标记高亮
在代码块(并非段内代码)的第一个三反引号的后面跟上代码语言，可以实现对应的高亮
#include&lt;iostream&gt;using namespace std;int main()&#123;    return 0;&#125;

数学公式

一边一个dollar符号undefined表示行内数学公式a \le \frac{b}{2} , \sum_{i=2}^n i, 渲染出来是这样子的a \le \frac{b}{2} , \sum _{i=2}^n i 。这种数学公式可以插入在行中。
每边两个dollar符号undefinedundefined ,这些dollar符号中间的行会被认为是数学公式

a \le \frac{b}{2} , \sum _{i=2}^n i
标号 。只需要打出1. 然后空格再回车。之后会自动生成2. 3. 等等。如果不想要继续标号了，可以用shift+tab快捷键
1. 第一点2. 第二点3. 第三点

第一点

第二点

第三点


插入链接,使用 中括号与圆括号的组合[]() 来实现链接. 中括号中写上显示的内容，圆括号中写上URL地址。


[点我去百度](https://www.baidu.com/)

插入图片，类似[]()组合,但是要在中括号前加上一个英文感叹号. ![]() 就会将圆括号中的图片URL显示出来

![这是一张图片](https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png)

表格,不太好描述,看例子吧

| a    | 1    | 1    || ---- | ---- | ---- || b    | 4    | 5    || c    | 1    | 4    || d    | 1    | 9    |
显示效果




a
1
1




b
4
5


c
1
4


d
1
9




美化文章的小效果一边两个星号* ,表示的是**粗体字** 
让三个减号—-独占一段(独占一段意味着它的上一行都是空行,下一行可以不是空行，但最好是)。可以起到分隔线的作用

上面有一条分割线
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql远程连接</title>
    <url>/a726c975d078/</url>
    <content><![CDATA[搞了一天的mysql远程连接， 也算是踩过坑了，这里记录一下
如果你的mysql无法被远程连接，那么请依次检查如下条件：
1. 服务器的防火墙（安全组）放行端口如果mysql服务在云服务器上运行， 那么请检查云服务器是否将端口3306开放。 如果没有开放请设置为通行状态。。这里不同的云服务器厂商的截图不同，我这里给出华为云的安全组设置
华为云：![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e44f593c14434d7e87359c45016de270.png#pic_center)
2. 启动mysql的远程连接服务在命令台中使用mysql -uroot 进入你的mysql数据库。mysql -uroot 选择mysql库use mysql检查user表中的host和User信息。select host,User from user;如果你的root字段对应的host是localhost，那么代表root账户只能本地登录。+-----------+------------------+| host      | User             |+-----------+------------------+| localhost | root             || localhost | debian-sys-maint || localhost | mysql.infoschema || localhost | mysql.session    || localhost | mysql.sys        |+-----------+------------------+
可以将host字段更改为%表示允许所有ip登录root账号。
update user  set host = &#x27;%&#x27; where user = &#x27;root&#x27;;   
更改后使用查表命令检查一下select host,User from user;更改后应该为如下：+-----------+------------------+| host      | User             |+-----------+------------------+| %         | root             || localhost | debian-sys-maint || localhost | mysql.infoschema || localhost | mysql.session    || localhost | mysql.sys        |+-----------+------------------+
3. 更改密码验证方式如果mysql版本是5.7或更低，无需考虑本条。
在mysql版本8.0版本后， 使用sha2方式来验证密码。 就导致我们不能正确连接。需要设置为允许密码连接。ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp知识点总结</title>
    <url>/0a85d83dfe8a/</url>
    <content><![CDATA[0. 杂类cin/cout提速使用ios::sync_with_stdio(false);加速输入输出速度
**&lt;&lt;的优先级**运算符&lt;&lt;和&gt;&gt; 的优先级比表达式中有的运算符要高，有时候要加上括号
cout&lt;&lt;(a&lt;b)&lt;&lt;endl;
**字符函数库cctype**判断一个字符ch是什么类型的：
isalpha(ch);//字母isdight(ch);//数字isspace(ch);//空白（不止是空格）ispunct(ch);//标点
比直接判断ASCII码更加容易使用（有的字符格式没有用ASCII码存就只能这么判断）
文件输入输出IO包含库文件fstream后可以进行文件的读写
创建ofstream对象和ifstream对象来分别对文件进行写和读用法和cout cin类似；
使用ofstream对象中的open()方法可以打开一个文件
表达式顺序点当到达顺序点时，会结算所有副作用（比如自增自减）
一个完整表达式的末尾是一个顺序点（完整表达式代表这个表达式不是其他表达式的子表达式）
逻辑运算符||和&amp;&amp;也是顺序点
函数内联函数内联函数在声明和定义的时候都需要加上inline，并且和普通的函数不同，内联函数的定义必须在被调用之前
内联函数在声明和定义的时候都需要加上inline，并且和普通的函数不同，内联函数的定义必须在被调用之前
尽可能地使用const使用const能够**避免无意中修改数据的编程错误**
使用const**使函数能够处理const和非const实参**，否则将只能接受非const数据
使用consti引用能够**使函数正确生成并使用临时变量**
提升可读性字符串/字符指针作函数形参在函数头的形参定义中使用char p[]，和char *p往往有相同作用，
但是当只希望实参**传入字符串**时候使用char p[],希望传入一个**字符指针**时使用char *p比较好
4.复合类型4.1字符串字面量4.1.1其他形式的字符串字面量在字符串的前面加上L u 和U等（分别表示widechar，char16，char32）
在字符串的前面加上L u 和U等（分别表示widechar，char16，char32）
wchar_t str1[] = L&quot;w_char string&quot;;char16_t str2[] = u&quot;char16_t string&quot;;char32_t str3[] = U&quot;char32_t string&quot;;
4.1.2原始字符串一般的原始字符串的格式为R&quot;(...)&quot; 。诸如\n等转义字符会被解释为两个字符\和n  
cout&lt;&lt;R&quot;(this is a &quot;raw&quot; string \n)&quot;&lt;&lt;std::endl;// this is a &quot;raw&quot; string \n
可以通过在双引号”和括号(之间加入任意字符，这样只有遇见与之相同的字符时才会代表整个字符串的结束：（当字符串中出现小括号时使用）
cout&lt;&lt;R&quot;+*(this is a string()())+*&quot;&lt;&lt;std::endl;//this is a string()()
4.2指针和自由存储空间*****运算符 被称为**间接值（indirect value）** 或**解除引用（derefencing）**运算符。
指针用于在运行阶段分配未命名的内存以存储值。
int * p = new int;
4.2.1自由储存空间使用int a; 生成的变量会被存储在**栈**（stack）中
而使用new生成的数据对象则会被储存在**堆**（heap）或称**自由存储区**（free store）中
使用delete来释放内存
int * p = new int;*p = 3;delete p;
这样不会删除p指针本身，只会释放p指针指向的地址
4.2.2动态数组int * psome = new int [10];delete [] psome;
假设有数组 arr[10];那么 **arr**和**&amp;arr**的值是相同的，但是表达的意义不一样，**arr**表示首元素的地址，**&amp;arr**表示整个数组的地址可以这样定义一个指向数组本身的指针：（p是 short[10]类型的指针）
short arr[10];short (*p)[10] = &amp;arr;
使用cout打印时，如果使用的变量是数组名，数组是字符数组，则打印字符（串），是其他类型数组（如int数组，则打印首地址）
int ins[10] = &#123;1,2,3,4,5&#125;;char chs[10] = &quot;12345&quot;;std::cout&lt;&lt;ins&lt;&lt;endl;//0x61fdf0std::cout&lt;&lt;chs&lt;&lt;endl;//12345
如果需要打印数组的首地址，那么可以对指针进行类型转换
std::cout&lt;&lt;(int*)chs&lt;&lt;endl;
4.2.3指针和const常量指针const int* ps = &amp;a;
指针常量int * const finger = &amp;b;
区别在于，**const的位置不同。**
当const位于*前面时候，不能通过ps修改a的值，但是可以修改ps所指向的地址（可以改为ps=&amp;b）
当const位于*后面时，则恰恰相反， 可以通过ps修改a的值，但是不能更换ps指向的地址。
4.3数组的替代品vector/array模板类 **vector**，可以实现可变数组的效果，内部使用new和delete动态分配内存
需要包含文件 &lt;vector&gt;
vector&lt;int&gt; vi;//创建一个0长的int类型数组int n = 5;vector&lt;double&gt; vd(n);//创建double类型数组
模板类 **array（c11）**
对于长度固定的数组，使用array类比vector更佳
array&lt;int,5&gt; ai;//长度为5的int类型数组array&lt;double,4&gt; ad = &#123;1.0,2.5,3.3,4&#125;;//长度为4的double类型数组
7.函数7.1函数和二维数组数组名被视为数组的首地址：
比如一个二维数组data和函数sum
int data[10][20];int total = sum(data,3);
那么函数的原型应该为
int sum(int (*arr2)[4],int size);int sum(int arr2[][4],int size);//可读性更强
arr2是指向一个**由4个int组成的数组**的指针(所以他是个数组指针)
7.2函数指针7.2.1获取函数的地址只使用函数名（后面不加参数）就相当于**函数的地址**
比如对于函数think(a),那么think就代表了这个函数的地址
process1(think);process2(think());
对于第一行代码，process1以think的地址为实参进行传递
第二行代码，则会先运行think()函数，然后将他的返回值传递给process2
7.2.2声明指向函数的指针double (*pf)(int);
pf表示一个**特征标**为int，**返回值**为double的函数指针 。
必须用括号括住（\*pf）, 如果不带括号会变成声明一个函数。
将一个函数指针指向函数时，必须保证二者**的特征标和返回值都相同**
7.2.3使用函数指针在第8行中，(*pf)(5)也可以替换为pf(5),但是前者给出了提示：代码正在使用函数指针
double pam(int);double (*pf)(int);pf=pam;double x = pam(4);double y = (*pf)(5);
7.2.4深入探讨函数指针1.对于以下**特征标**，他们看似不同，实则是相同的
const double * f1(const double ar[],int n);const double * f2(const double [],int n);const double * f3(const double *,int n);
在**函数原型**中，可以省去标识符，因此 const double ar[]可以简化为const double []
2.由**函数指针**组成的数组
const double* (*pa[3])(const double* ,int)=&#123;f1,f2,f3&#125;;
需要注意的是[3]的位置，**pa**是一个包含三个元素的数组，所以首先要使用**pa[3]**，然后由于**[]**的优先级高于*的优先级，所以**不需要加括号**，所以 ***pa[3]**是一个包含三个指针的数组，之后小括号括住，左右两边分别加上返回值和特征标
(C11)这里不能使用自动类型auto来自动获取pa的类型（因为**auto只能用于单值初始化，不能用于初始化列表**），但是可以在已经声明pa之后，使用自动类型来初始化同样的指针数组：
auto pb = pa；
8.函数探幽8.1内联函数内联函数**比常规函数运行更快**，但是会**占用更多的内存**，如果程序在10个不同的地方调用了内联函数，那么就会产生10个副本。
**内联函数不能递归!!!**
程序员请求函数声明为内联函数时，编译器不一定会满足需求，**当编译器认为函数过大或者注意到函数调用了他自己时，不会将他作为内联函数** 。
8.2引用变量8.2.1将引用作为函数参数将引用作为函数参数成为按引用传递，按引用传递允许被调用的函数能够访问调用函数中的变量
相对于按值传递（需要拷贝整份数据），按引用传递可以提高效率，节省空间，并且避免了使用指针
8.3默认参数8.3.1声明和定义带默认参数的函数注意**只有在函数声明时需要提供默认参数，函数定义时和没有默认参数时完全相同**
并且**带参数的形参必须在不带参数的形参之后**
8.3.2调用带默认参数的函数int func(int a=1,int b=2,int c=3);int func(int a,int b,int c)&#123;    return a+b+c;&#125;
优先使用实参，实参数量不足时使用默认参数
func();//func(1,2,3)func(11);//func(11,2,3)func(22,33);//func(22,33,3)func(444,555,666);//func(444,555,666)
8.4函数重载函数重载让你能够使用多个同名的函数，只要他们的特征标的种类和顺序不完全相同
8.4.1注意事项注意，编译器在检查特征标时，将类型引用和类型本身视为同一个特征标
int func1(int a)&#123;return 1;&#125;int func1(int &amp;a)&#123;return 2;&#125;//会导致二义性
如果传入一个int类型的实参，那么会由于二义性导致编译失败
8.4.2重载引用参数类设计和STL经常使用引用参数，因此知道不同引用类型的重载很有用，比如下面三个原型
void sink(double &amp; r1);void sank(const double &amp; r2);void sunk(double &amp;&amp; r3);
左值引用参数r1与可修改的左值参数(如double)匹配
const左值引用参数r2与可修改的左值参数、const左值参数和右值参数（如两个double值的和）匹配
右值引用参数r3与右值匹配。
注意到r1和r3匹配的参数都与r2匹配
所以如果重载这三个函数，会调用最合适的版本：
void stove(double &amp; r1);void stove(const double &amp; r2);void stove(double &amp;&amp; r3);
这让我们能够根据参数是左值，const还是右值来定制函数的行为
stove(x);//调用stove(double &amp; r1);stove(pi);//调用stove(const double * r2);stove(x+pi);//调用stove(double &amp;&amp; r3);
如果没用定义函数stove(double &amp;&amp;),stove(x+pi)则会调用函数stove(double &amp;)
8.4.3何时使用函数模板只有当函数基本上执行相同任务，但使用不同形式的数据时进行函数重载
8.5函数模板如果需要将同一种算法应用于不同类型的函数，使用模板来节省需要编写的代码量，比并且提高代码的重用性
8.5.1声明和定义函数模板在C++98之前，用关键字class来替代typename创建模板，如果不考虑向下兼容性，那么最好使用typename来创建模板
模板并不创建任何函数，只是在**告诉编译器如何定义函数**，当需要用来交换int的函数时，编译器将按照模板来创建相应的函数，同样需要用来交换double的函数时，则会再创建另一个函数
注意：函数模板并不能缩短可执行程序，最终的代码不会包含任何模板，使用模板的好处是可以使定义更简单，更可靠
通常将模板放在头文件中
void Swap(AnyType &amp;a,AnyType &amp;b)&#123;    AnyType temp;    temp a;    a = b;    b = temp;&#125;
8.5.2重载的模板template &lt;typename T&gt;void Swap(T &amp;a,T &amp;b)&#123;cout&lt;&lt;1&lt;&lt;endl;&#125;template &lt;typename T&gt;void Swap(T *a,T *b,int n)&#123;cout&lt;&lt;2&lt;&lt;endl;&#125;int main()&#123;   int x=2,y=3;   int arrx[]=&#123;2&#125;;   int arry[]=&#123;3&#125;;   int num=4;   Swap(x,y);   Swap(arrx,arry);   Swap(arrx,arry,num);&#125;
第10行代码传入了两个int类型的参数，使用第一个模板
11行传入两个int*类型的参数，但是因为只有两个参数，不符合第二个模板，所以仍然使用第一个模板
12行传入两个int*类型的参数和一个int类型的参数，使用第二个模板
8.5.2模板的局限性同一个模板在接收不同的数据类型时会用相同的代码去执行，但有时候某些运算是不适用于所有数据类型的，
如下面代码
#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt;T Max(T a,T b)&#123;   return a&gt;b?a:b;&#125;
当数据类型是地址时，模板中的&gt;变得不再适用。
有时会出现意想不到的结果。比如运算符*在处理int，double等类型时，表示乘法，而如果数据类型是一个指针，那么将会变成解引用的意思
8.5.3显式具体化当编译器找到与函数调用匹配的具体化定义的时候，将使用该定义，而不再寻找模板
对于给定的函数名，可以有非模板函数，模板函数和显示具体化模板函数以及它们的重载版本
显示具体化的原型和定义应该以template&lt;&gt;打头，并通过名称来指出类型
具体化优先于常规模板，非模板函数又优先于具体化和常规模板
class job&#123;&#125;;void Swap(job &amp;,job &amp;);//非模板函数template&lt;typename T&gt;//模板函数void Swap(T &amp;,T &amp;);template &lt;&gt; void Swap&lt;job&gt;(job &amp;,job &amp;);//显示具体化模板函数
是可选的，因为后面的参数类型已经表明了这是job的一个具体化。所以可以省去不写
8.5.4具体化和实例化最初，，编译器只能通过隐式实例化来使用模板生成函数定义，但现在C++还允许显式实例化，这意味着可以直接命令编译器创建特定的实例，如Swap()，语法是，用&lt;&gt;声明所需的种类，然后在声明前加上关键字templat
template void Swap&lt;int&gt;(int,int);//显示实例化
还有一种叫显示具体化，声明如下
template &lt;&gt; void Swap&lt;int&gt;(int,int);//显示具体化
显示具体化的意思是“不要使用Swap()模板来生成函数定义，而应该使用专门为int类型显式地定义的函数定义”。这些原型必须又自己的函数定义，显式具体化声明在关键字template后面包含一个&lt;&gt;，而显式具体化没有
警告：**在同一文件（或者转换单元）中，同时使用同一种类型的显式实例和显式具体化将出错**
**创建自定义选择：**在有些情况下，可以通过编写合适的函数调用来引导编译器做出自己希望的选择。
在main函数中，17行调用#2，18行调用double类型的#1，19行为int类型的#1，20为int类型的#1（哪怕传入的是double类型的参数）
#include&lt;iostream&gt;template&lt;typename T&gt;T lesser(T a,T b)&#123;//#1	return a&lt;b?a:b;&#125;int lesser(int a,int b)&#123;//#2	a = a&lt;0?-a:a;	b=b&lt;0?-b:b;	return a&lt;b?a:b;&#125;int main()&#123;	using namespace std;	int m = 20;	int n = -30;	double x = -15.5;	double y = 25.9;	cout&lt;&lt;lesser(m,n)&lt;&lt;endl;	cout&lt;&lt;lesser(x,y)&lt;&lt;endl;	cout&lt;&lt;lesser&lt;&gt;(m,n)&lt;&lt;endl;	cout&lt;&lt;lesser&lt;int&gt;(x,y)&lt;&lt;endl;	return 0;&#125;
9.内存模型和名称空间9.1单独编译**不要将函数定义或者变量声明放在头文件里面**，否则当两个以上的文件包含该头文件的时候，除非函数是内联的，否则将会出错
**不要使用include来包含源文件代码，这样做会导致多重声明**
翻译单元（一般为一个文件为一个翻译单元）
9.2存储持续性，作用域和链接性c++使用了三种（c++11之后是4种）方案来存储数据，区别在于数据保存在内存中的时间
**自动存储持续性**：在函数中声明的变量（包括函数参数），在程序开始执行函数或者代码块的时候被创建，执行完函数或者代码块的时候被释放 。
**静态存储持续性**：在函数外定义的变量和使用关键字static定义的变量都为静态的，他们在程序的整个运行过程中都存在
**线程存储持续性（c++11）**：变量使用**thread_local**声明的，那么他的生命周期就和他所属的线程一样长**（并行编程）**
**动态存储持续性**：用new运算符分配的内存会一直存在，直到程序使用delete运算符来释放掉或者程序结束。这种内存也称为动态内存（free store）或者堆（heap）
9.2.1作用域和链接**作用域描述了名称在文件（翻译单元）中多大范围可见**，**链接性描述了名称如何在不同的单元间共享**
链接性为外部的名称可以在文件之间共享，里娜姬恶行为内部的名称只能由一个文件中的函数共享，自动变量的名称没有链接性，他们不能共享。
在名称空间中声明的变量的作用域为整个名称空间（全局作用域就是名称空间作用域的特例）
9.2.2自动存储持续性在函数中创建的变量默认为自动类型变量，
**auto关键字：**在**c++11之前**可以使用auto在定义时标明这是个自动类型的变量（由于只能用于默认是自动的变量，所以没有实际作用，只用来提醒），**在C++11之后，**auto变为一种类型，用来自动判断变量应为什么类型
int (*p)[10];//一个数组指针auto p2=p;//和p类型一样的数组指针
register寄存器变量
使用register定义的变量是寄存器变量，他会**建议**编译器使用CPU寄存器来存储自动变量，在C++11中，失去了这种提示作用，register只能用来标明这是个自动类型的变量（虽然这个变量本身就是自动类型的）
9.2.3静态持续变量static定义的函数是静态的，存储在静态存储区，有两个主要用法：1.在函数中定义变量时加上static，来改变这个变量的生存周期
#include&lt;iostream&gt;using namespace std;void add()&#123;static int sum;sum++;//每当调用这个函数的时候，sum继承上一次的值，而不是重新开始&#125;int main()&#123;add();//执行完之后sum为1（但是在main函数中不可见）add();//sum为2return 0;&#125;
2.在全局区定义变量时加上static，会将链接性从外部改为内部，即其他文件（翻译单元）不可见。
 #include&lt;iostream&gt; using namespace std;int global;//链接性为外部，所有编译的文件都可见static int one_file;//链接性为内部，只有本文件可见 int main()&#123;	add();//执行完之后sum为1（但是在main函数中不可见）	add();//sum为2	return 0; &#125;
9.2.4静态持续性，外部链接性**单定义规则**
C++有两种变量声明：一种是**定义声明（defining declaration）**或 称**定义（definition）**；另一种是**引用声明（referencing declaration）**或称**声明（declaration）**。
**一个变量可以有多个声明，但只能有一个定义。**
使用关键字extern来进行**引用声明**，（只声明不引用）不进行初始化。否则就会定义。
由于单定义规则，所以只需要在一个文件包含该变量的定义，在其他所有文件中用extern声明他。
tips:如果在定义时对一个变量进行了初始化，那么即使加上extern那么这也是一个定义而不是声明
9.2.5静态持续性，内部链接性如果一个文件中，同时有外部静态变量和static修饰的内部静态变量，那么内部静态变量会将外部静态变量隐藏
//file1int i1 = 5;//file2int i1 = 6;//不被允许，违反了单定义规则static int i1 = 7;//允许，会隐藏掉file1中的i1
9.2.6静态存储持续性，无链接性也就是静态局部变量。（在函数中使用static定义的变量）
9.2.7说明符和限定符存储说明符：auto（在C++11中已经不再是说明符），register（C++11中无实际作用），static，extern，thread_local（C++11新增，用于多线程中），mutable（与const对应，含义大致相反）

**cv-限定符：const，volatile**

const表示代码无法改变该值，volatile表示即使代码没有对内存单元进行修改，它的值仍然可能会改变，主要用来提醒编译器不要对该变量进行编译优化，直接存取该地址的值，以免出错。一般用在1）并行设备的硬件寄存器中。2）中断服务程序中修改的供其他程序检测的变量，需要加volatile3）多任务下各任务间共享的标志。4）存储器映射的硬件寄存器。

**multable**

它表示，即使结构体或者类的变量被定义为const，但其中某个被multable修饰的成员变量仍然是可以修改的。

**const！！**

对于一个全局变量，使用const修饰后会将他的链接性从外部变为内部（就像加了static一样）。这样方便将const的变量定义放在头文件中，此时内部链接性会保证不会违反单一定义原则。
如果想要让一个常量的链接性为外部，那么可以在加上extern，但只需要对一个文件中的const变量进行初始化
const int one_file = 1;extern const int all_files = 3;
9.2.8函数和链接性函数也有链接性，，但是比变量可选择的范围要小，由于C++不允许在函数中定义另一个函数，所以函数的存储性都是静态的。在默认情况下函数的链接性为外部的。也可以使用static将一个函数的链接性转换为内部的。在函数的声明和定义中都需要有static关键字
9.2.9语言链接性链接程序要求每一个函数都有自己的符号名，在C++中存在重载，所以会存在相同名字的函数，但是相同函数名的重载函数也有不同的符号名。C++将重载函数名字转换为符号名的过程叫做C++语言链接性。
可以用函数原型来指出使用什么约定。
extern &quot;C&quot; void spiff(int);//使用C的语言链接约定extern void spoff(int);//使用C++的语言链接约定extern &quot;C++&quot; void spaff(int);//使用C++的语言链接约定
9.3名称空间名称空间可以是全局的，也可以位于另一个名称空间之中，但不能位于代码块之中。
在默认情况下，名称空间的链接性是外部的，除非他引用了变量。
9.3.1using声明和using编译指令使用using声明会将名称添加到局部声明区域内，会和其他局部变量一样，将覆盖同名的全局变量
using编译指令会将整个名称空间的所有名称都可用。
namespace aaa&#123;	int a;	int b;&#125;using aaa::a;//using声明using namespace aaa;//using编译指令
**安全性比较：**
using声明只会引入一个变量，当出现同名时，会导致报错提醒。更安全
using编译指令则会全部导入变量名字，如果遇到同名则会跳过导入（局部版本隐藏掉名字空间版本）不会报错，这样可能会出现意想不到的结果
所以在导入名字时，最好使用using声明(using std::cout)或者作用域解析运算符（std::cout）
10.对象和类10.1抽象和类对于一个类型的确定，需要完成三项工作：
1.决定数据对象需要的内存数量
2.决定如何解释内存的位
3.决定可使用数据对象执行的操作或方法
对于内置类型，有关操作隐藏在编译器中，对于用户自定义类型，需要自己定义这些内容。
10.1.1访问控制类提供了三种访问控制，用来表示成员变量或者成员函数能够怎样被访问（默认为private）
**private**（私有）：只能通过公有成员函数或者友元函数来访问对象的私有成员
**protected**（保护）：允许本类和本类的派生类访问。
**public**（公有）允许任意访问。
类设计应该尽可能将公有接口和实现细节分开，（数据隐藏），这让类在被使用时无需关心内部实现，只需注重如何使用接口。
10.1.2类成员函数注意：成员函数如果在类的声明中就被定义，那么这个函数会自动成为内联函数，而如果在类内声明，类外定义，就是普通的函数。
class person1&#123;private:	int height;	int age;public:	int getheight();	int getage() &#123;return age;&#125;//内联函数&#125;;int person1::getheight()&#123; return height;&#125;//非内联函数
10.2类的构造函数和析构函数10.2.1构造函数的使用构造函数相对于其他成员函数有以下特点：1.没有返回值（也不写void）2.名称和类名一样3.在实例化对象时自动调用
class person&#123;private:	int height;	int age;public:	person(int height1,int age1)&#123;height=height1;age=age1;&#125;&#125;;
在构造函数中可以使用初始化列表来初始化数据成员，并且需要注意的是，**这些项目被初始化的顺序是他们被声明的顺序而不是在他们在初始化列表中的顺序**
初始化列表为在函数头后面跟冒号，然后以**项目1 (形参1)**的形式表示将形参1赋值给项目1，并且各单元之间用逗号分隔开
person(int height1,int age1):age(age1),height(height1)&#123;&#125;
调用构造函数的两种方法：1.**显式调用：**person p1 = person(1,2)2.**隐式调用**person p1(1,2);
10.2.2析构函数在对象被释放的时候，会自动调用析构函数，
通常不应该在代码中显示地调用析构函数
使用~加类名来定义析构函数。
当构造函数中用到new来分配空间时，析构函数需要使用delete来释放空间
class person&#123;public:   person()&#123;name = new char[30];&#125;   ~person()&#123;delete[] name;&#125;private:   char* name;   int age;&#125;;
10.2.3const成员函数在函数的括号后面加上const的函数是const成员函数，这样的函数不被允许修改他所调用的对象。
public:   void show() const&#123;//const成员函数      cout&lt;&lt;height&lt;&lt;&quot; &quot;&lt;&lt;age&lt;&lt;endl;   &#125;
就像尽可能将const引用和指针用作函数形参那样，当一个成员函数不需要修改对象的值时，就应该让他成为const成员函数。
10.2.4其他上文提到了两种实例化对象并初始化的方法，下面说一下他们之间细节上的区别
1.显式调用：
person p1 = person(1,2)
2.隐式调用
person p1(1,2);
对于第一种调用方法，编译器可以有两种处理情况。一是和第二种隐式调用一样直接生成p1并调用构造函数。二是可能会先生成临时变量，再把这个临时变量赋值给p1，再删除掉临时变量（可能会立刻删除，也可能会等一段时间再删除），删除对象的时候会调用析构函数
再再注意：第一种调用方法可能会不产生临时对象，也可能会产生（编译器决定），但这只是在实例化对象的时候，如果是给对象赋值，那么就肯定会产生临时对象。
person p1(1,2);//不会产生临时变量person p2 = person(1,2);//可能会产生临时变量，可能不会p1 = person(1,2);//一定会产生临时变量
如果既可以通过初始化，也可以通过赋值的方式来设置对象的值，那么最好使用初始化的方式，因为这样可以提升效率
10.3this指针所有成员函数（包括构造函数和析构函数，不包括静态成员函数）都内置了一个this指针，this指针指向用来调用函数的成员函数的对象。
对于常成员函数（即在函数括号后面加上const）本质上是将this指针用const修饰。
如果一个方法要引用整个调用对象，那么可以使用*this**作为调用对象的别名**来完成前面方法的定义，（*this是调用对象的一个引用而不是一个副本）
const person &amp; comage(const person &amp; p1) const&#123;//compare age  if(p1.age&gt;this-&gt;age) return p1;  else return *this;&#125;
10.4对象数组在声明对象数组的时候，和声明一般数据类型的数组相同。直接使用中括号，
person pp[10];//声明和定义对象数组
如果没有给定参数，会自动调用默认构造函数。
可以使用构造函数来对数组进行初始化。
person pp[10]&#123;  person(1,2),  person(2,3),  person(4,4),&#125;;//声明和定义对象数组
上文中的三个构造函数会分别用来初始化pp[0],pp[1],pp[2].之后的元素会使用默认构造函数来初始化。
初始化队型数组的方案是，先使用默认构造函数创建数组元素，用花括号中的构造函数创建临时对象，再将临时对象复制到响应的元素中，所以所以，**想要创建对象数组，就必须有默认构造函数**
10.5类作用域在类内定义的名称的作用域是整个类，作用域为整个类的名称只在该类中是已知的。
在其他情况下使用类中的名称时，需要根据上下文使用**直接成员运算符（.）、间接成员运算符（-&gt;）、或者作用域解析运算符（::）**等
10.5.1作用域为类的常量有时候需要在类中定义一个常量。在C++11之前下面这样写是无法通过编译的。而在C++11之后也最好不要这么写
class person&#123;private:    const int allowage = 18;    ...
可以使用两种其他方法来实现，
1.使用枚举类型
class person&#123;private:   enum &#123;allowage = 18&#125;;   ...
这之中的pi只是一个符号常量，在编译的时候遇到allowage会用18来替换,并且只用用于整数常数（因为枚举类型不允许存在小数）
2.使用static修饰的const成员常量
class person&#123;private:   static const int allowage = 18;   ...
上面两种方式创建的成员常量都是公共的，**不属于任何对象**，所以即使他的访问权限是public，也不能使用成员运算符（.和-&gt;)来引用常量。而应该用作用域解析符
10.5.2作用域内枚举（C++11）传统的枚举不允许在不同的枚举中使用相同的关键字。如下代码在c++11之前是不被允许的。如下面的代码；
enum egg&#123;Small,Medium,Large&#125;;enum shirt&#123;Small,Large,Super_Large&#125;;//C++11之前不允许这么写，因为Small和Large存在二义性
在C++11之后，可以令枚举的作用域为类（结构stuct也可以），用法是在enum和枚举名称的中间加上class关键字（或者stuct）
//C++11之后允许这么写enum class egg&#123;Small,Medium,Large&#125;;enum class shirt&#123;Small,Large,Super_Large&#125;;
但是如果一个enum被定义为类枚举类型。那么就不能作为右值赋给int类型。
egg egg1 = egg::Large;//可以~int temp = egg::Large;//不可以！
但在必要的时候可以进行显式转换
int temp = int(egg::Large);
11.使用类11.1运算符重载11.1.1运算符重载的使用为了让对象操作更加美观，可以对运算符进行重载，C++允许将运算符䗏扩展到用户定义的类型当中。比如通过重载来让+（加号运算符）能够对两个对象进行相加。
运算符函数的格式如下：
operatorop(argument-list)
其中括号前的两个字母op应该被替换为一个运算符，括号内写参数列表。 例如：operator+()重载了加号运算符
实例：
class Time&#123;//定义一个时间类，用h，m，s来表示时间public:   Time(int h = 0,int m = 0,int s = 0)&#123;hour = h;minute=m;second = s;&#125;   Time operator+(Time &amp; t)&#123;      int sum = t.hour*3600+t.minute*60+t.second+this-&gt;hour*3600+this-&gt;minute*60+this-&gt;second;      return Time(sum/3600,(sum%3600)%60,sum%60);   &#125;    ...
在上面的代码中应该注意的是，**返回的不能是一个对象的引用，**而应该是一个对象，因为在函数中创建的对象在函数结束时就会被释放，引用也就无法起作用。
11.1.2注意事项1。**重载的运算符函数所接受的参数数量必须和运算符本身的操作数一一对应**，（比如加法运算符有两个值，那么参数就必须是两个）
2.如果运算符重载函数**作为成员函数，那么传入的参数需要减少一个**，因为对象本身（*this）始终会作为第一个参数。
3.重载的运算符函数不能所有操作数都是基本类型，**必须包含一个自定义类型**（编译不会通过，为了防止随意重载导致的严重后果）
4.不能重载以下运算符：
sizeof(sizeof运算符）.(一个点，成员运算符) .*(一个点一个星，成员指针运算符)::( 作用域解析运算符）?:(一个问号一个冒号，条件运算符)typeid( 一个RTTI运算符）const_cast(强制类型转换运算符）dynamic_castreinterpret_caststatic_cast
5.以下运算符必须通过成员函数重载：




=(赋值运算符)




（）（左右括号，函数调用运算符）


[]（左右中括号，下标运算符）


-&gt;（通过指针访问类成员的运算符）




11.2友元友元有三种，**友元类，友元函数，友元成员函数。**
让函数成为类的友元，可以让他拥有和成员函数一样的访问权限
11.2.1为什么要使用友元函数在为类重载二元运算符的时候经常需要用到友元
比如想要重载加号运算符，使其左操作数是一个int类型，右操作数是Time类
1.对于重载运算符**成员函数**，第一个参数必须是对象本身，所以无法实现目的。
2.对于一个**非成员函数**的运算符重载函数，则又没有类的访问权限，编写起来复杂
通过友元函数可以解决上述问题：
class Time&#123;//定义一个时间类，用h，m，s来表示时间public:   Time(int h = 0,int m = 0,int s = 0)&#123;hour = h;minute=m;second = s;&#125;   friend Time operator+(int num,Time t);   friend Time operator+(Time t,int num);   ...
友元函数不是成员函数，所以不能用成员运算符来调用。
友元函数需要访问哪个类的成员，就成为哪个类友元函数，而其他的参数类则没必要成为友元函数。比如下面的&lt;&lt;重载
friend ostream operator&lt;&lt;(ostream &amp; os,Time &amp; t);   
只需要成为Time的友元即可，不需要成为ostream的友元，因此也就不需要修改ostream的内容。
注意：返回值应该是ostream，而不是引用
*拓展：当一个ostream引用作为参数时（在上文指的是os），默认是cout对象的引用。其他的ostream对象还有cerr（表示将输出发送到标准错误流）
11.3类的自动转换和强制类型转换先定义一个类作为示例：
class weight&#123;public:   weight()&#123;&#125;   weight(int ia)&#123;w = ia;&#125;   weight(double da)&#123;w = da;&#125;private:   double w;&#125;;
11.3.1赋值运算符的自动转换对于上面的weight类，有三个构造函数，分别对应了无参，有int参，有double参三种类型。
那么下面这种赋值方法是被允许的
int main()&#123;   weight wei;   wei = 12;   return 0;&#125;
这种被成为自动类型转换，这样会先生用适合的构造函数来生成一个临时对象，然后将这个临时对象赋值给wei，在上例中调用的是weight(int)构造函数（因为12是int类型的）
有时候这种自动转换会引起一些问题，所以可以在函数的声明中使用了关键字**explicit**，那么将不支持使用这个函数进行自动类型转换
class weight&#123;public:   explicit weight(int ia)&#123;w = ia;&#125;   ...
当构造函数中没有与赋值运算符右值（上文中是12）匹配的参数类型（即没有weight(int)）,那么会寻找*勉强合适*的构造函数（如weight(double)），然后通过将改变右值的类型(将12的类型改为double)来适配构造函数
但进行这种赋值的前提是1.**使用的函数没有被explicit修饰**。2**.不存在二义性**（比如同时有构造函数weight(double)和weight(float)，那么12就不知道要转换成double还是float）
11.3.2强制类型转换可以通过显式地调用构造函数来进行强制类型转换
wei = weight(12);wei = (weight)12;
11.3.3转换函数上面讲到通过含有一个参数的构造函数可以将**其他**类型转换为**类**类型，那么如果要把**类**类型转换为**其他**类型，就需要用到转换函数
格式为：**operator typeName()**
需要注意的是：**1.****转换函数必须是类方法。2.转换函数不能指定返回类型。3.转换函数不能有参数。**
operator double() const &#123;return double(w);&#125;operator int() const &#123;return int(w);&#125;
**警惕二义性：**
如果同时定义了转换为int和double（或其他）的转换函数，又使用了如cout等支持多种数据类型的函数，那么会产生二义性导致编译失败。
可以使用**显式转换来避免二义性**
class weight&#123;public:   operator double() const &#123;return double(w);&#125;   operator int() const &#123;return int(w);&#125;   ...int main()&#123;   weight wei(12);//构造函数省去了   cout&lt;&lt;(double)wei;//显式转换函数   return 0;&#125;
**避免隐式转换的危害：**
像基本类型转换为类类型一样，同样可以使用explicit修饰转换函数来禁用隐式转换
explicit operator double() const &#123;return double(w);&#125;
也可以使用一个非转换函数来替代转换函数（因为非转换函数不支持隐式转换）
operator int() const &#123;return int(w);&#125;int weight_to_int()&#123;return (int)w;&#125;//用这一行来替代上一行
12.类和动态内存分配在类构造函数中使用new运算符在程序运行的时候分配所需要的内存空间
12.1动态内存和类如果将new应用于类，即在构造函数中用new来为变量分配空间。那么就必须要用到析构函数，并且析构函数中应该有对应的delete来释放new申请的空间
12.1.1静态成员变量静态成员变量对于一个类，只会生成一个副本，不会随着对象数量的增多而增多。
注意：静态变量不能在类声明中初始化，对于多文件编程，初始化应该在类方法文件中，而不是类声明文件中。（例外：如果这个静态成员变量是cosnt整数类型或者枚举型，那么可以在类声明中初始化）
12.1.2特殊成员变量C++会自动提供以下成员函数
**默认构造函数**，如果没有定义构造函数
**默认析构函数**，如果没有定义
**复制构造函数**，如果没有定义（也称拷贝构造函数）
**赋值运算符**，如果没有定义
**地址运算符，**如果没有定义
如果一个类用到了new[].delete[]等，那么要警惕这些自动生成的成员函数造成的影响。（可能会导致构造函数中new[]和析构函数中delete[] 的调用次数不匹配）
12.2.3复制构造函数何时使用复制构造函数
1.按值传递对象
2.函数返回对象
3.生成临时对象
深拷贝和浅拷贝（深复制和浅复制）
默认复制函数会进行浅复制（指一个对象一个对象地进行复制），这样有时候会出错（比如将一个指针赋值给另一个指针，或者将一个地址赋值给另一个地址）
深拷贝需要程序员自己编写，区别在于为指针所指的内容分配额外空间来获得一份副本
12.2.4赋值运算符将一个已有的对象赋值给另一个对象的时候会使用重载的赋值运算符
初始化对象的时候不一样会使用赋值运算符（但总是会调用复制构造函数）
相比复制构造函数，赋值运算符函数与之类似，区别在于
1.由于目标对象可能已经引用了以前分配的数据，所以需要先使用delete[]来释放这些数据
2.函数应当避免自身赋值给自身，否则会导致delete[]删除掉内容
3.函数应该返回一个指向调用类型的引用
4.由于赋值运算符不生成新的对象，所以如果有一个静态变量存储了对象的数量，那么这个静态变量不需要自增。
12.2.5关于临时对象的const问题在一些函数的进行时，可能创建临时变量(比如重载后的赋值运算符）,而临时变量是自带const（无法被修改的），所以如果一个临时变量作为了一个函数的引用参数，那么这个引用参数需要加上const。（因为只有带const的引用才能够同时调用带const类型的变量或者不带const的变量，而不带const的引用只能调用不带const的变量。
所以**如果不需要通过一个引用或指针来改变他指向的数据，那么一定要加上const**
12.2.6一个关于内存分配的类实例这个自定义类有基本的存储字符串的功能，并且会用new运算符自动分配合适的内存给字符串。用sum静态成员变量来记录目前实例化的对象数量，
但没有对中括号运算符[],比较运算符&lt;,&gt;,&lt;=,&gt;=,==以及加号运算符+进行重载
#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class mystring&#123;public:   static int sum;   static int getsum() &#123;return sum;&#125;   int getlen() const &#123;return len;&#125;//不需要修改对象数据的函数记得加const   char* getstr()&#123;return str;&#125;   //默认构造函数和带参构造函数   mystring(const char* str1=&quot;test&quot;)&#123;len=strlen(str1);str = new char[len];strcpy(this-&gt;str,str1);sum++;&#125;//不需要更改数据的形参记得加const   //复制构造函数   mystring(const mystring &amp; str1);//参数列表中类引用需要加const   //赋值运算符的重载函数   mystring &amp; operator=(const mystring &amp; str1);//加const哦   //析构函数   ~mystring()&#123;delete[] str;str = nullptr;sum--;&#125;private:   char* str;   int len;&#125;;int mystring::sum = 0;//复制构造函数的定义mystring::mystring(const mystring &amp; str1)&#123;   this-&gt;len = str1.getlen();   this-&gt;str = new char[len];   strcpy(this-&gt;str,str1.str);   sum++;&#125;//赋值运算符重载函数的定义mystring &amp; mystring::operator=(const mystring &amp; str1)&#123;   if(str1.str==this-&gt;str) return *this;//避免将对象赋给自身   delete[] str;//释放str原先所指的空间   this-&gt;len = str1.getlen();   this-&gt;str = new char[len];   strcpy(this-&gt;str,str1.str);   return *this;&#125;  int main()&#123;   &#123;      mystring str1 = &quot;1111&quot;;//测试赋值运算符，const char*向mystring类转换的构造函数      cout&lt;&lt;mystring::getsum()&lt;&lt;endl;      mystring str2 = str1;//复制构造函数      cout&lt;&lt;mystring::getsum()&lt;&lt;endl;      cout&lt;&lt;str2.getstr()&lt;&lt;endl;   &#125;//代码块结束了，删除所有的对象   cout&lt;&lt;mystring::getsum()&lt;&lt;endl;   return 0;&#125;
12.3返回const对象12.3.1返回指向const对象的引用返回引用不会调用复制构造函数，所以运行效率更快
返回的引用必须在调用函数中有定义，否则会导致引用找不到目标。
如果一个引用是const引用，那么返回时也应该加const
12.3.2返回指向非const的引用在以下两种情况，需要使用返回非const对象的引用，1.重载赋值运算符。2.重载于cout一起使用的&lt;&lt;
第一种这么做能提高效率，第二种则必须这么做
对于第二种情况，如果不返回 ostream &amp; 即 ostream的引用，而是返回ostream本身话，会尝试嗲用ostream的复制构造函数，而ostream类没有公有的复制构造函数。
12.3.3返回对象当被返回的对是调用函数的局部变量时，由于在调用函数的作用域种没有该变量，所以必须返回对象而不是返回对象的引用
12.3.3返回const对象对于+加号重载运算符：则需要返回对象，而不是对象的引用。
然而返回的这个对象是可以作为左值被使用的。然而一般+加号运算符作用结果是不能作为左值的。所以可以通过返回一个const修饰的对象来禁止这种行为
//mystring是一个类，str1,str2,str3都是这个类实例化的对象mystring str1;mystring str2;mystring str3;str1 = str1+str2;//第一种使用方法str2+str1 - st3;//第二种方法
如果加号重载运算符返回的是一个const对象类型，那么就只能够使用第一种方法，而不能使用第二种方法
12.4使用指向对象的指针如果一个指针指向了一个对象，那么同样可以使用解除引用运算符（*）来获取他指向的对象
12.4.1使用new为对象分配内存我们可以使用new为对象分配内存（并选择使用哪种构造函数），然后用一个指针来指向这个对象所在的内存
mystring* pstr = new mystring(&quot;666&quot;);
在上文的例子中，先new为这个对象分配内存空间，然后调用构造函数，为对象中的字符串666使用new分配一个空间
当使用delete（注意对象是单个变量，所以不是使用delete[]）删除对象的时候，**并不会删除在对象内所分配的空间**（在这里指的是新建的用来存储666的空间，这一步会交给自定义的析构函数来完成）
12.4.2定位new运算符和对象定位new运算符能够在分配内存的时候指定内存的位置。
C++prime plus P372
13.类继承使用类继承来更好地扩展和修改类
13.1基类与派生类13.1.1派生一个类被继承的类叫基类，由基类派生出来的类叫派生类。
下面是一个基类和他的派生类的代码示例
class Base&#123;public:	Base(const string &amp; str = &quot;&quot;) :str1(str) &#123;&#125;//构造函数	void Basefunc()&#123;cout&lt;&lt;&quot;this is Basefunc()&quot;;&#125;private:	string str1;&#125;;class Ps: public Base&#123;public:	Ps(const int &amp; dat = 0,const string &amp;str = &quot;0&quot;): data(dat),Base(str) &#123;&#125;//构造函数	void Psfunc()&#123;cout&lt;&lt;&quot;this is Psfunc()&quot;;&#125;private:	int data;&#125;;
上面代码中，基类是**Base**类，派生类是**Ps**类。在**Ps**的构造函数中使用Base的构造函数来构造继承的Base类的部分。
表明**Base**是**Ps**的一个公有继承。使用公有派生，**基类的公有成员将成为派生类的公有成员，基类的私有部分也将成为派生类的一部分，但只能够通过基类的公有和保护方法来询问。**
在继承的时候：派生类需要有自己的构造函数派生类可以根据需要添加额外的成员或者函数
**注意：**构造函数必须给新成员和记衡的成员提供数据。
13.1.2访问权限在创建派生类对象的时候，会先创建基类对象，嗲用基类构造函数。（如果初始化列表中没有调用基类构造函数，那么会自动调用默认构造函数）所以下面两行代码等效
//代码一Ps(const int &amp; dat = 0,const string &amp;str = &quot;0&quot;): data(dat),Base() &#123;&#125;//构造函数//代码2Ps(const int &amp; dat = 0,const string &amp;str = &quot;0&quot;): data(dat) &#123;&#125;//构造函数
在实例化派生类对象时**，先调用基类构造函数，再调用派生类构造函数**在销毁派生类对象时，**先调用派生类对象的析构函数，然后是基类对象的析构函数**
13.1.3派生类和基类之间的关系1.派生类能够使用基类中的 **公有（public**）以及**保护（protected）**类型的成员
2.基类指针可以在不进行显式类型转换的情况下指向派生类对象，基类引用可以不进行显式类型转换的情况下引用派生类对象。但是基类指针或者引用**只能用于调用基类方法。**
Ps p1(0,&quot;111&quot;);Base &amp; b1 = p1;//基类引用指向派生类对象b1.Basefunc();//基类引用调用基类方法
一个函数需要基类对象作为形参时，可以填入一个派生类对象实参
因此可以用派生类对象来给接类对象复制，因为会自动调用**隐式重载赋值运算符函数**。
const Base &amp; operator=(const Base &amp; b1) &#123;str1 = b1.str1;return b1;&#125;
13.2继承:is-a关系继承分为 公有继承（public）保护继承（protected）私有继承（private）
**公有继承建立的是is-a关系**

公有继承不能建立has-a关系

公有继承不能建立is-like-a关系

公有继承不建立is-implemented-as-a（作为…来实现）关系
公有继承不建立uses-a关系

**私有继承或者包含建立has-a关系**
13.3多态公有继承13.3.1使用虚方法1.在派生类中重新定义基类的方法，**如果派生类和基类中存在特征标相同的函数，派生类会优先调用自己定义的方法。**2.使用**虚方法virtual**
#include&lt;iostream&gt;using namespace std;class Base&#123;public:	Base(const string &amp; str = &quot;&quot;) :str1(str) &#123;&#125;//构造函数	virtual void func1()&#123;cout&lt;&lt;&quot;Base&quot;&lt;&lt;endl;&#125;//虚方法	virtual ~Base()&#123;&#125;;//虚析构函数private:	string str1;&#125;;class Ps: public Base&#123;public:	Ps(const int &amp; dat = 0,const string &amp;str = &quot;&quot;): data(dat),Base(str) &#123;&#125;//构造函数	virtual void func1()&#123;cout&lt;&lt;&quot;Ps&quot;&lt;&lt;endl;&#125;//这行的virtual可以省略private:	int data;&#125;;int main()&#123;	Base b1(&quot;111&quot;);	Ps p1(1,&quot;222&quot;);	Base &amp; b = p1;	b.func1();//调用Ps的函数	return 0;&#125;
13.3.2一些注意事项一、如果想要定义一个虚方法（虚函数），需要在基类的声明前加上virtual（如果定义和声明是分开的，那么定义前面不需要加），在派生类中的函数声明里可以不加virtual（会自动补上）
二、如果一个**基类引用** 引用了 **派生类对象**，并且通过引用试图使用一个 **在基类和派生类中都被定义的函数** ，那么1.如果这个函数**是虚函数，则调用引用变量所引用的对象的类型所定义函数**2.如果这个函数**不是虚函数，则调用引用变量本身类型的函数**
在上文中，b是Base类型的引用，他所指向的是Ps类型的对象，调用函数func1()，那么如果func1被定义为虚函数，则使用Ps类中的定义，如果不是虚函数，则使用Base类中的定义
三、使用**虚析构函数**能够确保释放派生对象的时候，优先调用基类虚构函数，从而确保正确的析构顺序。
13.3.3虚方法应用：基类指针数组因为使用的是公有继承模型，所以可以使用基类指针（Base*）来指向基类对象（Base）或者派生类对象（Ps），当通过基类指针调用虚方法时，会根据它所致的对象类型（基类或者派生类1或者派生类2等等）来动态选择要用哪个方法，这样可以通过创建一个**基类指针数组**，来同时管理基类和它的派生类。
13.4静态联编和动态联编将源代码中的函数调用解释为执行特定函数的过程称为**联编**
在编译过程中进行联编成为**静态联编（早期联编）**在程序执行时进行的联编（虚函数）称为**动态联编（晚期联编）**
13.4.1指针和引用的类型的兼容性基类的引用或者指针可以引用派生类对象，不需要进行显式类型转换将派生类引用或指针转换为基类引用或指针被称为**向上强制转换（upcasting），**这种转换是可传递的。
相反，将基类指针或者引用转换为派生列指针或引用称为**向下强制转换（downcasting）**,如果不使用显式类型转化，则这种转换时不允许的，因为is-a关系是不可逆的。
13.4.2虚函数的工作原理编译器处理虚函数的方法：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址的指针，这种数组称为”虚函数表“（virtual function table，vbtl）虚函数表中存储了为类对象进行声明的虚函数的地址。如果派生类提供了虚函数的新的定义，那么虚函数表会保存新函数的地址，如果没有重新定义虚函数，则保存原本的地址，如果定义了新的虚函数，那么这个函数地址也会被i坦加进去。（注意：不论类中包含的虚函数是一个还是十个，都只需在对象中添加一个隐藏的地址成员，指向虚函数表）
在使用虚函数时，在内存和执行速度方面都会有一些成本：1.每个对象都将增大，增大两位存储地址的空间2.对于每个类，编译器都将创建一个虚函数地址表（数组）3.对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址
13.4.3有关虚函数的注意事项在基类方法的声明中使用关键字**virtual**可使该方法在**基类以及所有的派生类**中事虚的如果定义的类将被用作基类。则应该将那些**要在派生类中重新定义类方法**声明为虚的
1.构造函数构造函数**不能是**虚函数
2.析构函数析构函数**应当是**虚函数，除非类不做基类，比如employee是基类，singer是派生类，并添加了一个char * 成员，指向new分配的内存，当singer对象过期的时候，必须调用~singer()析构函数来释放内存，因此需要虚析构函数如果使用默认的静态联编，delete语句会调用~Employee()析构函数，这会释放Singer对象中的Employee部分指向的内存，但不会释放新的类成员指向的内存。如果使用动态联编，delete会先调用~singer()析构函数，然后调用~Employee()析构函数。这意味着**，即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应该提供虚析构函数**
即使一个类不做基类来使用，定义为虚析构函数也是可以的，只是会牺牲一些效率。
3.友元友元不能是虚函数，因为友元不是类成员，如果因为这个原因引起了设计问题，可以通过**让友元函数使用虚成员函数来解决**
4.没有重新定义如果派生类没有重新定义，那将使用最新的虚函数，例外情况是基类版本是隐藏的
5.重新定义将隐藏方法
class Base&#123;public:	virtual void show(int a) const;//...&#125;;class Ps : public Base&#123;public:	virtual void show() const;&#125;;int main()&#123;	Ps p1;	p1.show();//合法	p1.show(2);//不合法&#125;
由于在Ps类中重新定义了虚函数show，所以隐藏了Base类中定义的**所有**show函数，这导致带参的show函数版本被隐藏，无法通过Ps对象来调用。
由此引出两条经验规则：1.如果重新定义继承的方法，应该确保与原先的原型完全一致，但如果返回类型是基类引用或者指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变（covariance of return type） 因为允许返回类型随类型的变化而变化（注意：这种变化只适用于返回值，不适用于参数）2.如果基类声明被重载了，那么应该在派生类中重新定义所有重载基类版本如果只需要重新定义其中部分函数，但还是需要将不需要修改的函数重新定义一下（void Ps::show() const {Base::show();}
13.5访问控制：protectedprotected权限和private类似，**在类外只能用公有类成员来访问protected部分中的类成员**，但区别是**派生类的成员可以直接访问基类的protected成员**，但不能直接访问基类的私有成员
对于下面的代码：
class Base&#123;private:	void resetB(double data)&#123;dat1 = data;&#125;protected:	double dat1;//...&#125;;class Ps: public Base&#123;public:	void resetP(double data)&#123; dat1 = data;&#125;&#125;
虽然dat1是Base中的保护成员，本意希望只通过resetB()来更改dat1的数据，但是通过派生类Ps中的公有成员resetP()间接访问了受保护的dat1成员，这使得dat1似乎成为了公有变量
因此**最好对类数据成员采用私有访问控制，不要使用保护访问控制，同时通过基类方法使得派生类能够访问基类数据**
13.6抽象基类如果两个类有一些共性，可以把他们的共性抽象成一个基类，然后由这个基类来派生出这两个类。这样就可以使用基类指针数组来同时管理这两个类。
这个基类可以**只指明所需要的函数，而将函数的具体实现交给它的派生类**
C++使用纯虚函数来实现这种基类纯虚函数声明时要在函数头后面加上 =0
class BaseEllipse&#123;public:	virtual double area() const  = 0;//area()是一个纯虚函数&#125;;class circle:public BaseEllipse&#123;public:	//...	double area()const &#123; return 3.1415*r*r;&#125;//纯虚函数在派生类中的实现private:	double r;//半径	int x,y;//坐标&#125;;class Ellipse:public BaseEllipse&#123;public:	//...	double area()const &#123;return 3.1415*A*B;&#125;//纯虚函数在派生类中的实现private:	int A;//半长轴	int B;//半短轴	int x,y;//坐标&#125;;
**如果一个类中包含了纯虚函数，那么就不能创建该类的对象**，因此这种类只能用作基类
在基类中的纯虚函数一般只需要声明而不需要定义，但在基类中给出纯虚函数的定义也是可以的。
double BaseEllipse::area() const &#123; return 0.0; &#125;
包含纯虚函数的类不能被实例化，这种类叫做**抽象基类**
可以被实例化的类叫做**具体(concrete)类**
13.7继承和动态内存分配13.7.1 情况一:派生类不使用newclass BaseDMA&#123;//使用了动态内存分配的基类private:	char * label;	int rating;public:	BaseDMA(const char* l = &quot;null&quot;,int t = 0);	BaseDMA(const BaseDMA &amp; bs);	virtual ~BaseDMA();	BaseDMA &amp; operator=(const BaseDMA * bs);&#125;;class lacksDMA:public BaseDMA&#123;private:	char color[40];//使用数组public:	//...&#125;;
（上面的代码只给出了函数的声明，没有给出定义）上面的代码中派生类lacksDMA中没有用new来分配内存，在基类中使用new来动态分配内存。那么就**不需要**为派生类lacksDMA定**义显式析构函数，复制构造函数和赋值运算符**
13.7.2 情况二:派生类使用newclass hasDMA:public BaseDMA&#123;private:	char* color;//使用new分配内存	~hasDMA();	hasDMA(const char* c = &quot;null&quot;);	hasDMA(const hasDMA &amp; hs);	hasDMA &amp; operator=(const hasDMA * hs);public:	//...&#125;;
在这种情况下，必须为派生类定义显式析构函数，复制构造函数和复制运算符。
**析构函数：**hasDMA的析构函数负责释放color管理的内存，然后以来baseDMA的析构函数来释放掉label管理的内存
//析构函数BaseDMA::~BaseDMA()&#123;	delete [] label;&#125;hasDMA::~hasDMA()&#123;	delete [] color;&#125;
hasDMA复制构造函数只能访问hasDMA的数据，因此他必须调用baseDMA复制构造函数来处理共享的baseDMA数据。（也就是初始化成员列表中的**BaseDMA(hs)**）在上面的代码中，成员初始化列表将一个hasDMA的引用出啊等你给了BaseDMA复制构造函数，，这用到了**类继承中可以向上强制传递**的性质。会将hs中的BaseDMA部分传递给BaseDMA的复制构造函数。
//复制构造函数hasDMA::hasDMA(const hasDMA &amp; hs):BaseDMA(hs)&#123;	color = new char[std::strlen(hs.color)+1];	std::strcpy(color,hs.color);&#125;
赋值运算符和复制构造函数的代码类似，区别在于需要**判断自己等于自己的情况**，以及需要**在函数块中调用BaseDMA的=运算符**
//赋值运算符hasDMA &amp; hasDMA::operator=(const hasDMA &amp; hs)&#123;	if(this == &amp;hs) return *this;//防止误删自己	BaseDMA::operator=(hs);	delete[] color;	color = new char[std::strlen(hs.color)+1];	std::strcpy(color,hs.color);	return *this;&#125;
总之当基类和派生类都采用动态内存分配的时候，派生类的析构函数，复制构造函数，赋值运算符**都必须使用相应的基类方法来处理基类元素**
13.8类设计回顾13.8.1要遵循is-a关系表示is-a关系的方法之一是，无需进行显式类型转换，基类指针就可以指向派生类指针，积累引用可以引用派生类对象。
13.8.2什么不能被继承构造函数，析构函数，赋值运算符不能被继承
13.8.3赋值运算符可以将派生类对象赋值给基类对象但如果相反，想要将基类对象赋值给派生类对象，会有一些前提：一、包含了这样的构造函数，即对将基类对象转换为派生类对象机型了定义，则可以将基类对象昂赋给派生对象二、如果派生类定义了用于将基类对象赋给派生对象的赋值运算符，则可以这样做三、如果上述两个条件都不满足，那么就不能将基类对象赋值给派生对象，除非使用显式强制类型转换。
13.8.4私有成员与保护成员使用私有数据成员比使用保护数据成员更好，但保护方法很有用
13.8.5虚方法1.如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的，这样可以启用动态联编
2.如果不希望基类中的方法被重新定义，则不要声明为虚函数，虽然当这个类被继承的时候仍然可以重新定义，但是这能起到提示作用
3.不适当的代码会阻止动态联编比如下面两个函数（其中Base是基类，Ps是派生类。二者有虚函数View();分别使用show和inadequate两个函数来调用View函数）
void show(const Base &amp; rba)&#123;	ba.View();&#125;void inadequate(Base ba)&#123;	p.View();&#125;//主函数中调用过程Ps t;show(t);inadequate(t);
第一个函数按引用传递对象，第二个函数按值传递对象，传递的是派生类Ps的对象t。
1.在show中，由于Base类的引用可以引用Ps类的对象，所以rba所引用的仍然是一个Ps类对象。由于虚方法的特性，ba.View()调用的是Ps版本的View()函数
2.在inadequate中，传递的实参是Ps类的对象，会先转换成Base类对象再传递给形参p，所以ba是一个Base类对象，因此ba,View()是Base版本的View函数
14.C++中的代码重用has-a关系通常可以用以下两种方法来实现：
一是一个类中的数据成员可以是另一个类的对象，这种方法被称为**包含（containment）、组合（composition）**或**层次化（layering）**。
另一种方法是使用私有继承或保护继承。
14.1包含对象成员的类在下面的代码中，student类包含了string类和score类的对象成员，是is-a关系
class score&#123;public:	score(int c= 0,int m = 0,int e = 0):Chinese(c),Math(m),English(e)&#123;&#125;private:	int Chinese;	int Math;	int English;&#125;;class student&#123;public:	student(string n=“”,int c=0,int m=0,int e=0):name(n),sco(c,m,e)&#123;&#125;private:	score sco;	string name;&#125;;
14.2私有继承使用私有继承，基类的公有方法将称为派生类的私有方法，
派生类不继承基类的接口，这种不完全继承是has-a关系的一部分。
私有继承提供的特性和包含相同：**获得实现，但不获得接口**，所以私有继承可以用来实现has-a关系
在继承时，private是默认的，因此不写明继承方法时，默认为私有继承
14.2.1初始化基类组件class student:private score&#123;public:	student(string n,int c,int m,int e):name(n),score(c,m,e)&#123;&#125;private:	string name;&#125;;
和包含的区别在：对于继承类，新版本的构造函数将使用成员初始化列语法，使用类名而不是成员名来表示构造函数（在上面的代码体现在score(c,m,e)而不是sco(e,m,e)）
14.2.2访问基类的函数使用类名和作用域解析运算符来调用基类的方法。比如假设基类score中有成员函数sum()，那么在派生类中可以通过score::sum()来调用。
14.2.3访问基类对象通过**强制类型转换**，将派生类转换为基类，从而来访问基类内部的数据成员
//派生类调用基类成员const score student::Score() const&#123;		return (const score &amp;) *this;	&#125;
14.2.4访问基类友元函数不能用类名加作用域运算符的形式来调用友元函数，因为友元函数不是类成员函数。但是可以通过显式地转换为基类来调用正确的函数
假设基类中有如下&lt;&lt;友元函数，用来输出三个科目的分数
friend ostream &amp; operator&lt;&lt;(ostream &amp; os,const score &amp; sco)&#123;//友元函数		os&lt;&lt;&quot;Chinese:&quot;&lt;&lt;sco.Chinese&lt;&lt;&quot; Math:&quot;&lt;&lt;sco.Math&lt;&lt;&quot; English&quot;&lt;&lt;sco.English&lt;&lt;endl;		return os;	&#125;
主函数可以这样写来调用基类中的友元函数（这里为调用基类中的&lt;&lt;友元函数）
student stu(&quot;小李&quot;,100,100,100);cout&lt;&lt;(const score &amp;)stu;
14.3保护继承保护继承是私有继承的变体，使用保护继承的时候**基类的公有成员和保护成员变为派生类的保护成员**，和私有继承一样，和积累的接口在派生类中可以直接使用，但是在继承层次结构之外不可使用
14.4多重继承14.4.1虚基类虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象
在类声明中使用关键字virtual使得基类被用作虚基类（virtual和public的次序关系随意），这样就可以避免重复继承。
比如有基类worker，派生出了类singer和dancer。之后又由singer和dancer派生出star。那么需要在继承worker的时候加上virtual关键字
class worker&#123;public:	worker(string name = &quot;null&quot;):name(name)&#123;&#125;	worker(const worker&amp; wk)&#123;this-&gt;name = wk.name;&#125;	string getname() &#123;return name;&#125;	void setname(string name)&#123;this-&gt;name = name;&#125;private:	string name;&#125;;class dancer:virtual public worker&#123;public:	dancer()&#123;&#125;	dancer(const worker&amp; wk,int ddat = 0):worker(wk),ddat(ddat)&#123;&#125;private:	int	ddat;&#125;;class singer:virtual public worker&#123;public:	singer()&#123;&#125;	singer(const worker&amp; wk,int sdat = 0):worker(wk),sdat(sdat)&#123;&#125;private:	int sdat;&#125;;class star:public dancer,public singer&#123;public:	star()&#123;&#125;	star(const worker&amp; wk,int ddat = 0,int sdat = 0,int age = 0) :worker(wk),dancer(wk,ddat),singer(wk,sdat),age(age)&#123;&#125;private:	int age;&#125;;int main()&#123;	worker w1(&quot;abc&quot;);	star s(w1,1,1);	cout&lt;&lt;s.getname();	return 0;&#125;
为了避免通过不同的途径给基类的成员赋值，虚**函数禁止了信息通过中间类自动传递给基类**。因此无法通过原本的方法来定义构造函数，在上例中无法在star类中获取name然后将name信息传递给worker。这样会传递失败，然后worker部分**会调用默认构造函数。**因此在star的构造函数的初始化成员列表**必须直接使用work的某个构造函数来构造work**（如果work不是虚基类，这样是不合法的），就似乎是star直接继承了worker一样。
如果不希望只使用虚基类的默认构造函数，那么必须显式地调用改虚基类的某个构造函数
14.4.2使用哪个成员函数？在单继承中如果没有重新定义基类中的成员函数，调用时会使用基类的定义，而在**多继承中，调用基类成员函数可能会导致二义性。**
1.可以使用作用域运算符来选择使用哪个版本的成员函数。例如s为star的对象。使用**s.singer::show()**来调用singer版本的show()函数
2.更好的方法是重新定义这个函数，然后在这个函数中选择调用哪个版本的函数例如给出star中show()的定义**void star::show(){singer::show()}**
分析两种方法可以得到：**第一种方法有一定的安全隐患，而第二种方法则会只显示singer部分的成员，而无法显示dancer部分的成员**第二种方法的补救措施是**分别调用singer::show()和dancer::show()**。 但这又会导致**重复调用了worker::show()**。补救措施的完善方法是：将模块化数据，让singer::data()只显示专属于singer 的部分，dancer同理。在star::work()部分则分别调用singer::data(),dancer::data(),worker::data(),并额外显示专属于star的部分。
总之，在祖先相同时，使用多重继承必须使用虚基类，并且修改构造函数初始化列表的规则。
14.4.3混合使用虚基类和非虚基类如果有类B被用作C和D的虚基类，X和Y的非虚基类。然后CDXY都用于M的基类，那么M会从CD中继承一个B类子对象，从X和Y中分别继承一个B类子对象。因此它包含了三个B类子对象。
14.4.4虚基类和支配入股哦一个类从不同的类那里继承了两个或多个成员（数据或方法）那么使用改成员名的时候，入股哦么有类名进行限定，会导致二义性，如果使用的是虚基类，就**不一定**会导致二义性，这时，如果某个名称**优先于**其他所有名称，那么使用它的时候即使没有限定符也不会导致二义性。优先性的判断规则是：**派生类中的名称优先于直接或间接祖先类中的相同名称**
14.4类模板通过模板类可以用来实现容器类**container class**(如STL中的stack和queue等容器)，容器类设计用来存储其他对象或者数据结构。
**本节比较难懂，且代码都很长，做好心理准备**
14.4.1定义类模板和定义模板函数类似，模板类以下面的代码开头template&lt;class Type&gt;
这里的Type 不必是一个类，而只是表明这是一个通用的类型说明符。可以用不太容易混淆的**typename**关键字来替换掉class。
下面是一个模板类的声明和定义
//stacktp.h#ifndef STACKTP_H_#define STACKTP_H_template &lt;typename Type&gt;class Stack&#123;private:	static const int MAX = 10;	Type items[MAX];	int top;public:	Stack();	bool isempty();	bool isfull();	bool push(const Type &amp; item);	bool pop(Type &amp; item);&#125;;//模板类中函数的定义template&lt;typename Type&gt;Stack&lt;Type&gt;::Stack()&#123;	top = 0;&#125;template&lt;typename Type&gt;bool Stack&lt;Type&gt;::isempty()&#123;	return top == 0;&#125;template&lt;typename Type&gt;bool Stack&lt;Type&gt;::isfull()&#123;	return top == MAX;&#125;template&lt;typename Type&gt;bool Stack&lt;Type&gt;::push(const Type &amp; item)&#123;    if(top &lt; MAX)&#123;        items[top++] = item;        return true;    &#125;    else         return false;&#125;template&lt;typename Type&gt;bool Stack&lt;Type&gt;::pop(Type &amp; item)&#123;    if(top &gt; 0)&#123;        item = items[--top];        return true;    &#125;    else         return false;&#125;#endif
模板类声明和普通类基本相同，区别在于1.最前面要加上模板声明template以及把之后的数据类型替换为Type。2.在使用类限定符的时候应该从**Stack;:** 改为**Stack::**
模板必须和特定的模板实例化请求一起使用，为此，最简单的方法是**将所有模板信息放在一个头文件中**
**使用模板类：**在上例中可以通过Stack s;来创建一个参数为int的Stack类
14.4.2模板的具体化类模板和函数模板很相似，因此可以又隐式实例化，显式实例化和显式具体化，它们统称为具体化（**specialization**）
1.隐式实例化（implicit instantiation）定义好一个类模板后，在创建某对象的时候，会自动进行这个参数类型的类进行隐式实例化，在这之前不会生成类的隐式实例化。比如在创建**Stack s1;**的时候会创建参数类型为int 的Stack类对象s1。这时候就对Stack进行了隐式实例化
2.显式实例化（explicit instantiation）顾名思义就是我们直接要求进行的实例化，这时，虽然没有创建或提及类对象，编译器也会生成类声明（包括方法定义）所用到的语句为**template class Stack;**
3.显式具体化（explicit specialization）有时候我们想要这个模板在某个参数的时候给出不同的定义，这时候就需要对这个参数类型的类进行特殊的定义**template &lt;&gt; class Stack{…};**这行代码的特点在于前缀template &lt;&gt;
4.部分具体化（partial specialization）C++还允许部分具体化，即部分限制模板的通用性，例如:假设有类模板**template class Array{…}**我们可以使用**template class Array{…}**对所有模板参数为**第一个任意，第二个为int**的模板类进行重新定义。这和显式具体化类似，区别在于只给出了部分模板参数的具体化，而其他的模板参数（上例中的Type1）仍然为待定状态。
14.4.3成员模板模板可用作结构、类胡总和模板类的成员。下面的示例代码为一个模板类，它将另一个模板类和模板韩素作为它的成员。试着去理解这段代码
#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt;class beta&#123;private:	template&lt;typename V&gt; //模板类作为成员	class hold&#123;	private:		V val;	public:		hold(V v = 0) : val(v) &#123;&#125;		void show() const &#123;cout&lt;&lt; val&lt;&lt;endl;&#125;		V Value() const&#123;return val;&#125;	&#125;;	hold &lt;T&gt; q;	hold&lt;int&gt; n;public:	beta(T t,int i):q(t),n(i) &#123;&#125;	template&lt;typename U&gt;//模板成员函数	U blab(U u,T t)&#123;return (n.Value() + q.Value()) * u / t;&#125;	void Show() const &#123;q.show();n.show();&#125;&#125;;int main()&#123;	beta&lt;double&gt; guy(3.5,3);	cout&lt;&lt;&quot;T was set to double n&quot;;	guy.Show();	cout&lt;&lt;&quot;V was set to T,which is double, then V was set to int n&quot;;	cout&lt;&lt;guy.blab(10,2.3)&lt;&lt;endl;	cout&lt;&lt;&quot;U was set to int n&quot;;	cout&lt;&lt; guy.blab(10.0,2.3) &lt;&lt; endl;	cout&lt;&lt; &quot;U was set to double n&quot;;	cout&lt;&lt;&quot;Donen&quot;;	return 0;&#125;
**类定义过程：**hold模板是在私有部分声明的，因此只能在beta类中访问它，beta类使用hold模板声明了两个数据成员：hold&lt;T&gt; q;hold&lt;int&gt; n;n是基于int类型的hold对象，q成员是基于T类型的hold对象。
**使用过程：****1.创建模板类对象**在main中创建guy的时候，模板参数为T是double类型，gay中的q是T类型的（也就是double）类型的hold对象，n是int类型的hold对象。**2.调用模板类对象中的模板函数（此时模板类的各个模板参数已经确定）**之后调用guy. blab(10,2.3)的时候，传入的第一个参数是int类型的，所以blab是参数列表为(int,double)，返回值为int的函数。而之后在调用guy.blab(10.0,2.3)的时候，又创建了参数列表为(double,double)，返回值为double的函数。需要注意的是，因为blab的第二个参数在生成guy的时候已经确定了是double(T为double),所以不管调用函数的时候传入的是什么类型的参数，都会转换为double类型的参数进行处理。
14.4.4将模板用作另一模板的模板参数模板可以包含**类型参数(如typename T)**和**非类型参数（如int n）**，模板还可以包含**本身就是模板的参数**
#include&lt;iostream&gt;#include&quot;stacktp.h&quot;using namespace std;template &lt; template &lt;typename T&gt; class Thing &gt;class Crab&#123;private:	Thing&lt;int&gt; s1;	Thing&lt;double&gt; s2;public:	Crab() &#123;&#125;	bool push(int a, double x)&#123;return s1.push(a) &amp;&amp; s2.push(x);&#125;	bool pop(int &amp; a, double &amp; x )&#123;return s1.pop(a) &amp;&amp; s2.pop(x);&#125;&#125;;int main()&#123;	Crab&lt;Stack&gt; nebula;	int ni;	double nb;	cout&lt;&lt;&quot;Enter int double pairs, such as 4 3.5(0 0 to end):n&quot;;	while(cin&gt;&gt;ni&gt;&gt;nb &amp;&amp; ni&gt;0 &amp;&amp; nb &gt; 0)&#123;//输入并判断输入是否河狸		if(!nebula.push(ni,nb))&#123;			break;		&#125;	&#125;	while(nebula.pop(ni,nb))&#123;		cout&lt;&lt;ni&lt;&lt;&quot;,&quot;&lt;&lt;nb&lt;&lt;endl;	&#125;	cout&lt;&lt;&quot;Done.n&quot;;	return 0;&#125;
上面的代码中用到了14.4.1中的代码段作为头文件，用来提供一个模板。与此同时又创建了**参数为一个模板的**新的模板。这个模板类包含了一个int类型的模板和double类型的模板。用来同时调用二者的push函数和pop函数。在主函数调用中，我们**传入的参数模板必须包含有push函数和pop函数接口**，因此Stack作为参数是合适的。之后在主函数中以Stack为参数实例化了相关的类和对象（nebula是对象）。然后就可以用这个nebula对象来存储数据了。
14.4.5模板类和友元模板类声明也可以有友元，模板的友元分为三类：**1.非模板友元****2.约束（bound）模板友元**，即友元的类型取决于类被实例化时的类型**3.非约束（unbound）模板友元**，即友元的所有具体化都是类的每一个具体化的友元

模板类的非模板友元函数

//frnd2tmp.cpp//1.模板类的非模板友元函数#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class HasFriend&#123;private:    T item;    static int ct;//朋友数public:    HasFriend(const T &amp; i) : item(i) &#123;ct++;&#125;    ~HasFriend()&#123;ct--;&#125;    friend void counts();//显示数量    friend void reports(HasFriend&lt;T&gt; &amp;);//显示这个对象的item信息&#125;;template&lt;typename T&gt;int HasFriend&lt;T&gt;:: ct = 0;//为每个实例化的静态函数赋初值void counts()&#123;    cout&lt;&lt;&quot;int count: &quot;&lt;&lt; HasFriend&lt;int&gt;::ct&lt;&lt;&quot;;&quot;;    cout&lt;&lt;&quot;double count: &quot;&lt;&lt;HasFriend&lt;double&gt;::ct&lt;&lt;&quot;;&quot;&lt;&lt;endl;&#125;//需要对带模板参的友元函数进行具体化void reports(HasFriend&lt;int&gt; &amp; hf)&#123;    cout&lt;&lt;&quot;HasFriend&lt;int&gt;:&quot;&lt;&lt;hf.item&lt;&lt;endl;&#125;void reports(HasFriend&lt;double&gt; &amp; hf)&#123;    cout&lt;&lt;&quot;HasFriend&lt;int&gt;:&quot;&lt;&lt;hf.item&lt;&lt;endl;&#125;int main()&#123;    cout&lt;&lt;&quot;No objects declared: &quot;;    counts();    HasFriend&lt;int&gt; hfi1(10);//has friend int    cout&lt;&lt;&quot;After hfi1 declared: &quot;;    counts();    HasFriend&lt;int&gt; hfi2(20);    cout&lt;&lt;&quot;After hfi2 declared: &quot;;    counts();    HasFriend&lt;double&gt; hfdb(10.5);    cout&lt;&lt;&quot;After hfdb declared: &quot;;    counts();    reports(hfi1);    reports(hfi2);    reports(hfdb);    return 0;&#125;
有的编译器会对使用非模板友元发出警告。警告内容为：
![img](data:image/png;base64,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)
friend void reports(HasFriend&lt;T&gt; &amp;);
上面中的counts友元函数是所有实例化的友元，例如它同时是HasFriend 和HasFriend的友元counts通过以下方式来访问HasFriend对象**1.访问全局对象2.通过全局指针访问非全局对象3.创建自己的对象4.访问独立于对象的模板类的静态数据成员**
如果要为友元函数提供模板类参数，那么应该这样声明；friend void report(HasFriend**&lt;T&gt;** &amp;);
重点在于参数中的&lt;T&gt;，这是**不可省的**，这样，带HasFriend&lt;int&gt;参数的**report友元函数**将会是HasFriend&lt;int&gt;类的友元，它会和带HasFriend&lt;double&gt;参数的**report**友元函数组成重载
2.模板类的约束模板友元函数可以修改前一个代码示例，使友元函数本身成为模板，没具体地说，为约束模板友元做准备，来使**类的每一个具体化都获得与友元匹配的具体化，**这比非模板友元复杂一些**首先，在类定义的前面声明每个模板函数**template &lt;typename T&gt; void counts();template &lt;typename T&gt; void report(T &amp; );**然后在函数中再次将模板声明为友元**
template &lt;typename T&gt;class HasFriendT&#123;…friend void counts&lt;TT&gt;();friend void report&lt;&gt;(HasFriendT&lt;TT&gt; &amp;);&#125;
在声明中&lt;&gt;指出这是**模板具体化**
3.模板类的非约束模板友元函数在**类内**创建非约束友元函数，每个函数具体化都是每个类具体化的友元
class ManyFriend&#123;      //…      template &lt; typename C,typename D&gt; friend void show2(C &amp;,D &amp;);&#125;;
在友元函数中的模板参数可以和类模板中的模板参数不同
14.4.6模板别名可以用**typedef**为模板具体化指定别名
typedef std::array&lt;double,12&gt; arrd;typedef std::array&lt;std::string,12&gt; arrst;typedef std::array&lt;int,12&gt; arri;
C++11之后能够**使用模板提供一系列别名**
template&lt;typename T&gt;using arrtype = std::array&lt;T,12&gt;
15.友元、异常、其他16.string类和标准模板库17.输入、输出和文件17.1C++输入输出概述C++的输入输出依赖于iostream和fstream内定义的的一系列类。
17.1.1流和缓冲区通过使用流，C++ 程序处理输入输出的方式将独立于其去向
管理输入包含两步：1.将流和输入去向的程序关联起来2.将流和文件连接起来管理输出同理
通常通过缓冲区可以高效地处理输入和输出在输出时，程序会首先填满缓冲区，然后把整块数据传输给硬盘，并清空缓冲区，以备下一批输出使用，这被称为刷新缓冲区（flushing the buffer）
17.1.2流、缓冲区和iostream文件在程序中包含iostream文件将自动创建8个流对象（4个用于窄字符流，四个用于宽字符流）
分别为**cin 、cout、cerr、clog的**窄字符和宽字符版本
17.1.3重定向通过输入重定向&lt;和输出重定向&gt;，可以使用改变输入和输出流的连接目标.(默认为键盘和显示器)
对标准输出重定向并不会影响到cerr或clog。因此如果使用其中一个对象来打印错误信息，程序会在屏幕上显示错误信息。
17.2使用cout来进行输出C++将输出看作字节流，很多数据都是以数值类型存储的，因此ostream流最重要的任务之一就是将数值类型（int或double等）转换成以文本形式表示的字符流
17.2.1重载的&lt;&lt;运算符&lt;&lt;默认是按位左移运算符，但是被ostream重新定义为了为了输出，**&lt;&lt;**叫做**插入运算符，**插入运算符的重载使之能够识别C++中所有的基本类型。
**拼接输出：cout&lt;&lt;“ABC“**返回的是**cout对象**（的引用），因此这个表达式本身可以再使用&lt;&lt;运算符，这就实现了拼接的效果。可以通过cout&lt;&lt;“ABC”&lt;&lt;‘d’&lt;&lt;endl来不断拼接想要输出的内容。
17.2.2其他ostream方法除了各种operator&lt;&lt;()函数外，ostream类还提供了put()和write()方法，前者用于显示字符，后者用于显示字符串
cout.put(&#x27;a&#x27;);//打印字符acout.put(&#x27;b&#x27;).put(&#x27;c&#x27;);//put()方法返回ostream类，因此可以拼接cout.put(66).put(66.7);//都会转换为ASCII码为66的字符，即B

put方法用来输出一个字符
put方法返回ostream对象，因此可以拼接
数值类型（int,double)会转换成字符类型再打印

const char * state1 = &quot;test1&quot;;const char * state2 = &quot;ABCDEFG&quot;;cout.write(state1,strlen(state1)).write(state2,strlen(state2));cout.write(state1,10);//设定的打印字符数量大于字符串字符数，溢出打印，不仅打印了test1，还多打印了ABCD

**cout.write()**有两个参数，第一个表示要打印的内容，第二个表示要打印多少字符
**cout.write()**返回值是**ostream类型**的对象，所以可以拼接
**write()方法检测到空字符也不会停止，因此如果要打印的字符比字符串长就会导致溢出**（例子中虽然指定的是打印state1，但是由于溢出了4个字符，所以还打印 了state2中的前四个字符

17.2.3刷新输出缓冲区通常缓冲区为512字节或它的整数倍，在屏幕输出的时候不必填满缓冲区也可以刷新，如将换行符发送到缓冲区后，将刷新缓冲区。1.在即将输入的时候会刷新输出缓冲区2.控制符endl也会刷新缓冲区3.控制符flush4.控制符也是函数，因此可以使用语句**flush(cout)**来刷新输出缓冲区
17.2.4用cout进行格式化]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>python配置cuda</title>
    <url>/b4bdaa4b4566/</url>
    <content><![CDATA[使用pytorch进行深度学习的时候，往往想用GPU进行运算来提高速度。于是搜索便知道了CUDA。
下面给出一个自检的建议：

检查cuda的版本是否适配自己的GPU。

打开NVDIA控制面板，点击左下角“系统信息”，然后就可以看到NVDIA GPU的详细信息，其中就包含了CUDA的版本。在官网安装合适版本的cuda-toolkit。
![image-20240827162727766](C:\Users\lsk\AppData\Roaming\Typora\typora-user-images\image-20240827162727766.png)

安装了cuda，但是命令行输入nvcc -V 报错显示没有nvcc 

这时候可能没有将CUDA添加到环境变量。检查系统变量中是否包含了CUDA_PATH ,以及CUDA_PATH_Vx.x  , 以及PATH中是否包含了cuda的bin目录。
![image-20240827162641803](C:\Users\lsk\AppData\Roaming\Typora\typora-user-images\image-20240827162641803.png)

在命令行输入nvcc -V 可以正常运行，但是在python中使用print(torch.cuda.is_available()) 显示的是False。 这时候考虑torch安装错误。

（直接使用pip install torch 会安装cpu版本的torch，导致无法使用cuda）
卸载原先的torch，pip uninstall torch
然后在PyTorch官网找到正确版本进行下载安装。我的CUDA版本是12.6，PyTorch官网的最新版本支持CUDA12.4 安装命令如下：
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124
![image-20240827162529085](C:\Users\lsk\AppData\Roaming\Typora\typora-user-images\image-20240827162529085.png)
此时在python中再运行print(torch.cuda.is_available())就会显示True了。
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>十六届蓝桥杯模拟赛1题解</title>
    <url>/c836153aa73d/</url>
    <content><![CDATA[1. 填空题1题意问2024有多少个质因数
思路法一：枚举所有的因数然后判断是否为质数
法二：使用唯一分解定理（质因数分解定理）
代码唯一分解定理：
#include&lt;bits/stdc++.h&gt; // bits/stdc++.h是万能库，会包含所有可能用到的函数using namespace std;int main()&#123;    int n = 2024;    int cnt = 0;    for(int i =2;i&lt;=n;i++)&#123;        if(n%i == 0)&#123;            cnt++;            while(n%i==0)&#123;                n/=i;            &#125;            cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;        &#125;    &#125;    return 0;&#125;/*输出2 311 123 1代表2024 = pow(2,3) * pow(11,1) * pow(23,1)*/
2. 填空题2题意问n进行多少次整数根号后会得到1。
思路循环即可
代码#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n = 2024;    int cnt = 0;    while(n != 1)&#123;        n = (int)sqrt(n);        cnt++;    &#125;    cout&lt;&lt;cnt;    return 0;&#125;
3. 填空题3题意问大于等于2024的第一个立方数是多少。
思路枚举立方数即可
代码#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    for(int i = 1;i&lt;=15;i++)&#123;        cout&lt;&lt;i*i*i&lt;&lt;endl;    &#125;    return 0;&#125;/*182764125216343512729100013311728219727443375*/
可以发现比2024大的立方数是2197 ，相减得到2197-2024 = 173
4. 填空题4题意问1901 年1月1日到 2024年12月31日之间有多少个好日期。
思路枚举所有天数即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;int mon[13] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;bool isLeap(int y)&#123;    return (y%4==0 &amp;&amp; y%100!=0) || y%400==0;&#125;int main()&#123;    int xq = 2;//星期    int y = 1901,m = 1,d = 1;    int cnt = 0;    while(y != 2024 || m != 12 || d != 31)&#123;        xq++;        if(xq == 8) xq = 1;        d++;        if(isLeap(y)) mon[2] = 29;        else mon[2] = 28;        if(d &gt; mon[m]) d = 1, m++;        if(m &gt; 12) m = 1, y++;        if(xq == 1 &amp;&amp; d % 10 == 1) cnt ++;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;    //输出762    return 0;&#125;
5. 填空题5题意给出一个长度为30的数组a，找到一个整数V，使得V对这30个数异或后，平方和最小。
求最小的平方和。
思路我们发现所有的数都不超过2^{14} = 16384   ,也就是说我们可以将所有的数用14位的二进制数来表示出来。
我们直接令V等于[0,2^{14})中的每个数，然后各自求出一个答案后取最小值即可。 
代码#include&lt;bits/stdc++.h&gt;using namespace std;int nums[] = &#123;9226,4690,4873,1285,4624,1596,6982,590,8806,121,8399,8526,5426,64, 9655,7705,3929,3588,7397,8020,1311,5676,3469,2325,1226,8203,9524,3648,5278,8647&#125;;int main()&#123;    int mx = pow(2,14);    long long ans = 0x3f3f3f3f3f3f3f3f;    for(int v = 0;v&lt;mx;v++)&#123;        long long sum = 0;        for(int i = 0;i&lt;30;i++)&#123;            int t = v ^ nums[i];            sum += t * t;        &#125;        ans = min(ans,sum);    &#125;    cout&lt;&lt;ans&lt;&lt;endl; // 1070293541    return 0;&#125;
6. 停车场题意每15分钟收费2元，不足15分钟不收费，问总停车时间n分钟，收费多少元
思路很容易发现ans = 2 * \lfloor \frac{n}{15} \rfloor ，其中undefinedlfloor x \rfloor$ 代表x的向下取整。
代码#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;    cin&gt;&gt;n;    cout&lt;&lt; n / 15 * 2;    return 0;&#125;
7. 数的操作题意有一个整数n， 每次操作让整数的非0位减少1.问多好此操作这个数会变为0
思路每个位数互相独立，所以我们进行数位分离，然后取最大值即可
代码#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    long long n;    cin&gt;&gt;n;    long long ans = 0;    while(n)&#123;        ans = max(ans,n%10);        n /= 10;    &#125;    return 0;&#125;
8. 减法式子题意给你一个减法式子，请你处理一下然后输出结果
思路模拟题，先读入字符串，因为两个数都是非负数，所以只需要找到字符串的减号，然后提取出左右两个子串即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    cin&gt;&gt;s;    int p = 0;    while(s[p] != &#x27;-&#x27;) p ++;    string s1 = s.substr(0, p);    string s2 = s.substr(p+1, 100);    int n1 = stoi(s1);    int n2 = stoi(s2);    cout&lt;&lt;n1-n2;    return 0;&#125;
9. 子数组的和题意对于一个长度为n的数组a , 找到一个p，使得a[p] + a[p+2] + a[p+4] + ... + a[p + 2*k-2] 最大。
思路我们对数组按照下标的奇偶分为两个数组，然后分别求两个数组的长度为k的子数组求和问题 即可。
**思路一**：前缀和思想，我们求出sum数组，其中sum[i] = \sum_{j=1}^i a[j] ，递推式为sum[i] = sum[i-1] + a[i]
然后我们枚举所有的l \in [1,n-k+1] ,找到sum[l+k-1] - sum[l-1]的最大值即可。
**思路二** ： 滑动窗口，我们先求出s = \sum_{i = 1}^k a[i] ，然后每次让子数组向右移动一次，即s = s + a[i+k]; s = s - s[i] 然后不断求s的最大值即可。
**注意int会超出范围导致无法拿满分！！！！**
代码#include&lt;bits/stdc++.h&gt;using namespace std;long long sum1[10005];int t1 = 0;long long sum2[100005];int t2 = 0;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i =1;i&lt;=n;i++)&#123;        int x ;cin&gt;&gt;x;        if(i % 2 == 1) &#123;            t1 ++;            sum1[t1] = sum1[t1-1] + x;        &#125;else &#123;            t2 ++;            sum2[t2] = sum2[t2-1] + x;        &#125;    &#125;    int k;cin&gt;&gt;k;    long long ans = 0;    for(int i = 1;i&lt;=t1-k+1;i++)&#123;        ans = max(ans,sum1[i+k-1]-sum1[i-1]);    &#125;    for(int i = 1;i&lt;=t2-k+1;i++)&#123;        ans = max(ans,sum2[i+k-1]-sum2[i-1]);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;
10. 对勾子序列题意给你一个数组，请你找到其中一个子序列，满足前一部分单调递减，后一部分单调递增。
思路本题考查了动态规划的经典问题： 单调递增子序列。
我们对数组进行一次求单调递增子序列，以及求单调递减子序列，然后枚举分界点，找到最大的答案即可。
如何求最长上升子序列？
我们设dp数组：dp[i] 表示以i结尾的子序列，最长的上升子序列的长度是多少，我们发现他要么从前面某个dp值转移过来，即dp[i] = dp[p] + 1 \ \& a[i] > a[p] ，要么自己作为子序列的开始,即dp[i] = 1 。于是每个dp值通过枚举前面的所有的值就可以得到。总分时间复杂度为o(n^2)
最长下降子序列同理，只需要稍微更改条件即可。
在我们求出最长上升子序列数组dp1 ，和最长下降子序列数组dp2 之后，最终答案就是dp1[i] + dp2[i] - 1的最大值了。

另：最长上升子序列问题可以通过优化来O(nlogn)实现，感兴趣者可以自行了解，本文不多赘述
代码#include&lt;bits/stdc++.h&gt;using namespace std;int a[1005];int dp1[1005];int dp2[1005];int main()&#123;    int n;    cin&gt;&gt;n;    for(int i = 1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    for(int i = 1;i&lt;=n;i++)&#123;        dp1[i] = 1;        for(int j = 1;j&lt;i;j++)&#123;            if(a[j]&lt;a[i])&#123;                dp1[i] = max(dp1[i],dp1[j]+1);            &#125;        &#125;    &#125;    for(int i = 1;i&lt;=n;i++)&#123;        dp2[i] = 1;        for(int j = 1;j&lt;i;j++)&#123;            if(a[j]&gt;a[i])&#123;                dp2[i] = max(dp2[i],dp2[j]+1);            &#125;        &#125;    &#125;    int ans = 0;    for(int i = 1;i&lt;=n;i++)&#123;        ans = max(ans,dp1[i]+dp2[i]-1);    &#125;    cout&lt;&lt;ans;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>python</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>十六届蓝桥杯模拟赛3题解</title>
    <url>/27d697c28fe4/</url>
    <content><![CDATA[第16届蓝桥杯模拟赛3 python组
*思路和答案不保证正确*
1.填空如果一个数 p 是个质数，同时又是整数 a 的约数，则 p 称为 a 的一个质因数。
请问， 2024 的最大的质因数是多少？
因为是填空题，所以直接枚举2023~2 ，第一个即是质数也是2024的因数的数就是答案。
def isprime(x):    for i in range(2,int(x ** 0.5)+1):        if(x % i == 0):            return False    return Truefor i in range(2023,1,-1):    if(2024 % i == 0 and isprime(i)):        print(i)# 23# 11# 2
2.填空对于两个整数 a, b，既是 a 的整数倍又是 b 的整数倍的数称为 a 和 b 的公倍数。公倍数中最小的正整数称为 a 和 b 的最小公倍数。
请问， 2024 和 1024 的最小公倍数是多少？
经典求lcm: lcm(a,b) = \frac{a * b}{ gcd(a* b)}
def gcd(x,y):    if(y == 0): return x    return gcd(y,x % y)def lcm(x,y):    return x * y // gcd(x,y)print(lcm(2024,1024))## 259072
(python3.9版本以后的math库中含有lcm函数可以直接调用)
import mathprint(math.lcm(2024,1024))## 259072
3.填空如果一个数 p 是个质数，同时又是整数 a 的约数，则 p 称为 a 的一个质因数。
请问， 2024 的所有质因数的和是多少？
第一个填空使用的代码已经计算出了2024的质因数为：23,11,8,4,2 ，加到一起就可以了
def isprime(x):    for i in range(2,int(x ** 0.5)+1):        if(x % i == 0):            return False    return Trues = 0for i in range(2023,1,-1):    if(2024 % i == 0 and isprime(i)):        s = s + iprint(s)## 36
4.填空请问，在不超过 2024 的数中，最大的质数是多少？
枚举2023~2，找到第一个质数
def isprime(x):    for i in range(2,int(x ** 0.5)+1):        if(x % i == 0):            return False    return Trues = 0for i in range(2023,1,-1):    if(isprime(i)):        print(i)        break## 2017
5.填空如果两个整数 a, b 除了 1 以外，没有其它的公约数，则称整数 a 与 b 互质。
请问，与 2024 互质的数中（包括1），第 2024 小的数是多少？
while循环从1开始找满足gcd(x,2024) == 1 的数，找第2024个
def gcd(x,y):    if(y == 0): return x    return gcd(y,x % y)cnt = 0p = 0while(cnt &lt; 2024):    p += 1    if(gcd(p,2024) == 1):        cnt += 1print(p)## 4655
6.填空对于字符串 S=ANQNANBNQNANQNQNBNINQNQNANQNINANQNANBNQNANQNQNBNBNQNQNANQNINANQNANBNQNANQNQNBNINQNQNANQNINBNQNANBNQN ，请找到 S 的一个长度不超过 10 的子串 A，使得（A的长度）乘以（A在S中出现的次数）最大。
请问这个子串是什么？（如果有多个满足条件的，请回答字典序最小的）。
字符串不长，直接枚举所有长度不超过10的子串，然后将他们的出现次数记录在字典中，然后在字典中找答案就好
s = &quot;ANQNANBNQNANQNQNBNINQNQNANQNINANQNANBNQNANQNQNBNBNQNQNANQNINANQNANBNQNANQNQNBNINQNQNANQNINBNQNANBNQN&quot;dic = &#123;&#125;for length in range(1,11):    for i in range(0,len(s) - length):        dic[s[i:i+length]] = dic.get(s[i:i+length],0) + 1ansstr = &quot;&quot;ansnum = 0for s,cnt in dic.items():    num = cnt * len(s)    if(num &gt; ansnum) or (num == ansnum and s &lt; ansstr):        ansstr = s        ansnum = numprint(ansstr)# NQN
7.填空如果一个字符串中只包含字符 0 和字符 1，则称为一个 01 串（包含全为 0 的串和全为 1 的串）。
请问有多少个长度为 24 的 01 串，满足任意 5 个连续的位置中不超过 3 个位置的值为 1 。
长度为24的01串总共有2^{24} 个，大约1.7*10^7 , 可以花点时间暴力枚举所有的字符串（反正是填空题）
import timedef check(x):    lst = []    for i in range(0,24):        if(x &amp; ( 1 &lt;&lt; i)):            lst.append(i)    if(len(lst)&lt;=2):        return True    for i in range(len(lst)-2):        if(lst[i+2] - lst[i]&lt;= 4):            return False    return Trueans = 0tik = time.time()for x in range(1&lt;&lt;24):    # 这些01串可以用0~(2**24-1)的二进制数表示    if(check(x)):        ans += 1tok = time.time()print(tok-tik) # 花了25.859452724456787秒运行程序print(ans) # 最终答案是162165
也可以使用dfs来解决本题：
import timelis = [] # 存储当前数的1的位置ans = 0def dfs(step):    global ans    if(step == 25):        ans += 1        return     if(len(lis) &lt; 2 or step - lis[-2] &gt; 4):        lis.append(step) # 选1        dfs(step + 1)         lis.pop() # 还原现场    dfs(step + 1) # 选0tic = time.time()dfs(1)tok = time.time()print(tok - tic)# 花了0.04025077819824219秒运行程序print(ans) # 最终答案是162165
8. 玉米地题意【问题描述】小蓝种了一块玉米地，玉米地长 n 米，宽 m 米，每平方米产玉米 a 千克。请问小蓝的玉米地一共能产多少千克玉米？
【输入格式】输入三行。第一行包含一个正整数 n ，第二行包含一个正整数 m ，第三行包含一个正整数 a 。
【输出格式】输出一行，包含一个整数，表示答案。
【样例输入】2024900
【样例输出】432000
【评测用例规模与约定】对于所有评测用例，1 &lt;= n &lt;= 1000, 1 &lt;= m &lt;= 1000, 1 &lt;= a &lt;= 2000。
思路直接输出n*m*a 
n = int(input())m = int(input())a = int(input())print(n * m * a)
9.再创新高题意【问题描述】小蓝有一个数组 a[1], a[2], …, a[n]， 一个“再创新高”的位置是指一个位置 p ，a[p] 的值比之前每个位置的值都大。
请求出小蓝的数组中有多少个再创新高的位置。
【输入格式】输入的第一行包含一个整数 n 。
第二行包含 n 个整数，相邻数之间使用一个空格分隔，依次表示 a[1], a[2], …, a[n] 。
【输出格式】输出一行，包含一个整数，表示答案。
【样例输入】81 2 3 4 5 6 6 6
【样例输出】6
【样例输入】93 2 1 6 5 4 9 8 7
【样例输出】3
【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n &lt;= 100，0 &lt;= a[i] &lt;= 1000。
对于 60% 的评测用例，1 &lt;= n &lt;= 1000，0 &lt;= a[i] &lt;= 1000。
对于所有评测用例，1 &lt;= n &lt;= 10000，0 &lt;= a[i] &lt;= 1000000。
思路枚举数组，不断记录max值，每当max更新就让答案加一
n = int(input())lst = list(map(int,input().split()))mx = -1ans = 0for x in lst:    if(x &gt; mx):        ans += 1        mx = xprint(ans)
10.四个字符串拼接题意【问题描述】给定四个字符串 a, b, c, d，请将这四个字符串按照任意顺序依次连接拼成一个字符串。
请问拼成的字符串字典序最小是多少？
【输入格式】输入四行，每行包含一个字符串。
【输出格式】输出一行包含一个字符串，表示答案。
【样例输入】LANLANQIAOBEI
【样例输出】BEILANLANQIAO
【评测用例规模与约定】对于所有评测用例，输入的字符串非空串，由大写字母组成，长度不超过 1000 。
思路四个字符串拼接只有A_4^4 种可能，直接枚举所有可能的情况，找到最小的字符串即可。
将四个字符串装入一个列表中，然后使用itertools库中的permutations函数来生成所有可能的排列
import itertoolslst = []for i in range(4):    s = input()    lst.append(s)per = itertools.permutations(lst) # 生成一个包含所有排列情况的可迭代对象ans = &quot;&quot;.join(lst) # 拼接列表中的字符串for i in per:    ans = min(ans,&quot;&quot;.join(i))print(ans)
更好的解法如果字符串数量增多，全排列的数量会大大增长导致我们无法枚举所有的可能。我们可以考虑直接找到最优的字符串。
我们假设字符串目前拼接顺序如下S1,a,b,S2 ，其中a,b 是单元字符串，而S1,S2则分别表示其他字符串拼接后的串。现在我们考虑交换a和b的位置能否使得整个字符串的字典序更小：
显而易见当a+b&lt;b+a时，a在前时字典序更小，b+a&lt;a+b 时交换a和b的位置能够使得最终的字符串字典序更小。 （此处的+ 表示字符串的拼接，&gt; , &lt; 表示字典序比较）
于是我们按照上述的比较规则对这个字符串数组进行排序，最终的顺序就是答案
from functools import cmp_to_keylst = []for i in range(4):    s = input()    lst.append(s)def cmp(s1,s2): # 比较函数    if(s1+s2 &lt; s2+s1):        return -1 # -1表示不需要交换位置    elif(s1+s2 &gt; s2+s1):        return 1 # 1表示需要交换位置    else :        return 0lst.sort(key = cmp_to_key(cmp))print(&quot;&quot;.join(lst))
11.领取礼物题意【问题描述】蓝桥村正在给村民们发放礼物。礼物通过一个礼物发放机完成。
村民们在机器前排着队领取礼物。
每个礼物有一个价值 v[i] ，有的高，有的低。每位村民有自己对于礼物的期望值 e[i] 。
礼物发放机每次会显示一个礼物，如果礼物的价值大于等于村民的期望值，村民就会高兴地把礼物拿走，并离开礼物发放机。如果礼物的价值比村民的期望值低，村民会让这个礼物取消，并让礼物发放机显示下一个礼物，并重新检查是否满足期望。村民会重复让礼物发放机显示下⼀个礼物，直到礼物发放机没有更多可以显示的礼物或礼物的价值大于等于自己的期望值。
如果礼物发放机中的所有礼物都显示完了，那么还没领到礼物的村民就无法领取礼物了。
如果所有的村民都领到了礼物，而礼物发放机还有礼物显示，村民们也不会再领取礼物。
现在，小蓝知道了每位村民的期望值，也知道了礼物发放机上礼物的显示顺序，请问总共有多少村民拿到了礼物？
【输入格式】输入的第一行包含一个整数 n ，表示村民的个数。
第二行包含 n 个整数，相邻数之间使用一个空格分隔，依次表示排队的每位村民的期望值 e[i] 。
第三行包含一个整数 m ，表示礼物发放机会显示的礼物个数。
第四行包含 m 个整数，相邻数之间使用一个空格分隔，依次表示礼物发放机显示的礼物的价值 v[i] 。
【输出格式】输出一行，包含一个整数，表示答案。
【样例输入】66 5 5 3 6 099 9 8 2 4 4 3 5 3
【样例输出】4
【样例说明】前 4 位村民依次取到了第 1, 2, 3, 5 件礼物。后面的礼物未能满足第 5 位村民。
【评测用例规模与约定】对于 30% 的评测用例，1 &lt;= n, m &lt;= 20 ， 0 &lt;= e[i], v[i] &lt;= 100 。
对于 60% 的评测用例，1 &lt;= n, m &lt;= 300 ， 0 &lt;= e[i], v[i] &lt;= 10000 。
对于所有评测用例，1 &lt;= n, m &lt;= 10000 ， 0 &lt;= e[i], v[i] &lt;= 1000000 。
思路模拟礼物分发的过程即可
使用for循环按顺序枚举每个村民，对于每个村民使用while循环来查找符合的礼物。
当所有村民都领到礼物，或者所有的礼物都分发完就结束循环
n = int(input())villager = list(map(int,input().split()))m = int(input())gift = list(map(int,input().split()))p = 0 # 现在分发到哪个礼物了ans = 0for x in villager:    while(p &lt; len(gift) and gift[p] &lt; x):        p += 1    if(p == len(gift)):# 如果所有礼物都发完了        break    ans += 1 # 有合适的礼物给他    p += 1print(ans)
12. 十字矩阵题意【问题描述】小蓝有一个 n 行 m 列的矩阵 a[i][j]，他想着矩阵中找出一个“十”字形状的区域，使得区域内的值的和最大。
一个“十”字形状的区域可以由两个行号r1 、 r2 和两个列号 c1 、 c2 表示。“十”字的区域内包括第 r1 行到 r2 行的所有元素，以及第 c1 列到 c2 列的所有元素，既不在这几行也不在这几列的元素不在区域内。
为了保证是一个“十”字的形状，必须满足 1 < r1 ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>python</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/a0bd89e96c0d/</url>
    <content><![CDATA[单调栈指的是一个栈，栈内的元素是单调的。
单调递增栈：从栈底到栈顶元素依次**从大到小**。
单调递减栈：从栈底到栈顶元素依次**从小到大**。
建立一个单调栈例：如果要维护一个递增单调栈（也就是栈顶的元素最小），那么元素要入栈时，如果为**空栈**或者**栈顶元素比入栈元素大**，就入栈，否则就依次将栈顶元素出栈，直到满足条件。
伪代码：
stack&lt;int&gt; s1;//一般需要在数组中添加一个结束标识符    for(遍历数组)&#123;        if(栈为空||栈顶元素大于当前元素)&#123;            入栈;        &#125;else&#123;            while(栈不为空&amp;&amp;栈顶元素小于当前元素)&#123;                栈顶元素出栈;                更新结果;            &#125;            当前元素入栈;        &#125;    &#125;
应用1.视野总和： 有n个人在排队，他们身高各不相同，都向右看，能看到比自己个子矮的人的头顶，直到下一个比自己更高的人。
**输入：**n个数表示n个人的身高**输出：**所有人能看到的头顶总和
例：输入： 4 3 7 1输出：2(个子为4的人能看见个子为3的人，7能看见1)
思路：本质就是找到下一个比自己个子高的人，然后计算相隔的距离(也就是中间有几个人)，再加和。可以通过构建单调递增栈来解决。当遇到下一个比自己高的人时就开始处理数据。
const int INT_INF = 0x3F3F3F3F;int fieldSum(vector&lt;int&gt;&amp; v)&#123;    v.push_back(INT_INF);    stack&lt;int&gt; st;    int sum = 0;    for(int i = 0;i&lt;v.size();i++)&#123;        if(st.empty() || v[i]&lt;st.top())&#123;//如果空栈或者将要入栈的元素更小            st.push(v[i]);        &#125;else &#123;            while(!(st.empty() || v[i]&lt;st.top()))&#123;                int top = st.top();                st.pop();                sum += (i - top - 1);//处理数据            &#125;            st.push(v[i]);        &#125;    &#125;    return sum;&#125;
2.柱形图中的最大矩形面积链接：https://ac.nowcoder.com/acm/contest/22669/Q
柱状图是有一些宽度相等的矩形下端对齐以后横向排列的图形，但是小A的柱状图却不是一个规范的柱状图，**它的每个矩形下端的宽度可以是不相同的一些整数**，分别为a[i]a[i]a[i],每个矩形的高度是h[i]h[i]h[i],现在小A只想知道，在这个图形里面包含的最大矩形面积是多少
 输入描述:
一行一个整数N，表示长方形的个数接下来一行N个整数表示每个长方形的宽度接下来一行N个整数表示每个长方形的高度
输出描述:
一行一个整数，表示最大的矩形面积
输入
71 1 1 1 1 1 12 1 4 5 1 3 3
输出
#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; pii;//pair int int(pii)typedef long long int ll;const int INF = 0x3f3f3f3f;//无限大ll maxSqu(vector&lt;pii&gt; vec)&#123;    vec.push_back(make_pair(-1*INF,0));//在数组最后插入一个结束标识符，保证运行的时候能处理掉所有的数据    stack&lt;pii&gt; st;    ll max = -1*INF;//存储结果    for(int i  = 0;i&lt;vec.size();i++)&#123;//遍历数组        if(st.empty() || st.top().first&lt;= vec[i].first)&#123;//如果符合条件就入栈            st.push(vec[i]);        &#125;else&#123;//不符合条件就依次出栈直到可以入栈            int wid = 0;//用来表示现在宽度是多少            while(!st.empty() &amp;&amp; st.top().first &gt; vec[i].first)&#123;//出栈                pii top = st.top();                st.pop();                wid+=top.second;                ll res = ll(wid)*top.first;                max = max&gt;res?max:res;            &#125;            //下面这两行很关键，用来实现向左拓展矩形(通过将栈顶元素的宽度改成它以及它左边比它高的矩形的宽度的和)            st.push(vec[i]);            st.top().second += wid;        &#125;    &#125;    return max;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    vector&lt;pii&gt; v(n);    for(int i = 0;i&lt;n;i++)&#123;        cin&gt;&gt;v[i].second;    &#125;    for(int i = 0;i&lt;n;i++)&#123;        cin&gt;&gt;v[i].first;    &#125;    cout&lt;&lt;maxSqu(v);    return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>招新赛题解</title>
    <url>/c065df36a63a/</url>
    <content><![CDATA[注意事项请注意！：

题解仅代表个人看法，不代表最优解

每道题都会附上ac代码，但是仅作参考，要看懂后再了解代码。补题不要直接抄代码！禁止自欺欺人！

只提供题解，不提供题目信息
ac代码为C++版本，如果遇到不懂的语法请自行百度
ac代码中的循环经常用到了for(int i = 1;i&lt;=n;i++) ，这种在for的括号中int i的操作只有大于等于C++11标准才可以使用，编译错误时请检查自己编译使用的标准。

A.数位分解对于一个数x， 

使用  x % 10 (% 是取余数) ，就可以得到他的最后一位
使用 x /= 10  (除以十并取整数)，就可以舍掉他的最后一位

使用while(x) 来进行循环
#include&lt;iostream&gt;using namespace std;int main()&#123;	int x;	cin&gt;&gt;x;	while(x)&#123;		cout&lt;&lt; x % 10 &lt;&lt;&quot; &quot;;		x = x / 10;	&#125;	return 0;&#125;
B.**大小写字母互换**对于一个小写字符ch, 使用代码ch = ch - (&#39;a&#39; - &#39;A&#39;);能够使他转换为大写字母， 相反对于大写字母，则需要使用代码ch = ch + (&#39;a&#39; - &#39;A&#39;);
本题读入的数据中存在空格，因此需要使用 gets()函数来读入。
使用string.h 库文件中的 strlen() 函数来获取字符串的长度
#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123;	char str[85];	gets(str);	for(int i = 0 ;i&lt; strlen(str);i++)&#123;		if(&#x27;a&#x27;&lt;=str[i] &amp;&amp; str[i]&lt;=&#x27;z&#x27;) 			str[i] -= (&#x27;a&#x27;-&#x27;A&#x27;);		else if(&#x27;A&#x27;&lt;=str[i] &amp;&amp; str[i]&lt;=&#x27;Z&#x27;) 			str[i] += (&#x27;a&#x27;-&#x27;A&#x27;);	&#125;	cout&lt;&lt;str;	return 0;&#125;
C.八进制转十进制给出的数据规模很小，直接根据进制公式计算即可。
下面通过一个例子来介绍计算公式
13579_{(8)} = 1 * 8^4 + 3*8^3 + 5*8^2 + 7*8^1 + 9*8^0
可以发现式子是可以用循环表示的
#include&lt;iostream&gt;using namespace std;int main()&#123;	int x;	cin&gt;&gt;x;	int p = 1;//p = 8 ^ i	int ans = 0;	for(int i = 0;x &gt; 0;i++)&#123;		ans += (x % 10) * p;//x % 10 数位分离		p = p * 8;//令p一直保持为 8 ^ i		x = x / 10;//数位分离的操作	&#125;	cout&lt;&lt;ans;	return 0;&#125;
**D. 西西务者**使用数组存下所有的数据，然后排序后选择其中的中间部分计算平均值即可，数据的总和会超过int的范围，注意使用**longlong**来存储中间区域的裁判的分数和。
数组占用的空间大，建议放在全局区。（也就是main函数的上面）
输入数据多，建议使用scanf读入数据（最好不要用cin，否则可能会读入超时）
#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 1e6;int dat[MAXN*5 + 5];int main()&#123;	int n;	cin&gt;&gt;n;	for(int i =1;i&lt;=n * 5;i++)&#123;		scanf(&quot;%d&quot;,&amp;dat[i]);	&#125;	sort(dat+1,dat+n*5+1);//C++中的排序函数，需要包含algorithm库	long long sum = 0;//一定要初始化	for(int i = n + 1;i&lt;=n * 4;i++)&#123;		sum += dat[i];	&#125;	printf(&quot;%.1lf&quot;,(double)sum / (n * 3)); //转换为double再计算才会有小数,%.1lf为保留一位小数输出double类型数据	return 0;&#125;
E.睡大觉本题使用的算法知识： 1.前缀和 2.二分查找 。 如果没有学过上述内容，建议前往([OI Wiki ](https://oi-wiki.org/))，或者[CSDN ](https://www.csdn.net/)等平台先行了解。
设每次开始睡觉（或结束睡觉）为一个时间点，使用前缀和数组qz记录从刚开始到某个时间点一共睡了多长时间，因此有以下方程：
qz[i] = qz[i-1](i为偶数)
qz[i] = qz[i-1] + a[i] - a[i-1] (i为奇数)
请根据题意“第i个数为奇数表示睡醒，为偶数表示睡着”认真理解上述公式。
数据处理完毕后，对于每组询问 l , r。 我们可以先计算出从刚开始到 l 一共睡了多长时间（设为timeL），以及从刚开始到r 一共用了多长时间（设为timeR） ，而从l到r的睡眠时间即为timeR - timeL。
下面探讨如何找到从刚开始到时间x 的总睡眠时间：使用int ind = lower_bound(a+1,a+1+n,x) - a - 1; 来找到从x往左数的第一个时间点的下标ind。（low\_bound()能够从a数组中二分找到第一个大于x的索引，减去首地址a即为下标，再减去a变为第一个小于x的下标）

如果ind为奇数，那么代表[ind,x] 这段时间是醒着的。那么直接返回 qz[ind]即可。

如果ind为偶数，那么代表[ind,x] 这段时间是睡着的，那么返回 qz[ind] + (x - ind)


需要注意的是：

答案可能会超出int的范围，建议使用long long。

使用cin cout可能会超时，建议使用scanf和printf


#include&lt;iostream&gt;using namespace std;const long long MAXN = 2e5+5;long long a[MAXN];//原始数据long long qz[MAXN];//前缀数组long long n; long long getnum(long long x)&#123;//获取从开始到x的睡眠时间	long long ind = (lower_bound(a+1,a+1+n,x) - a) ;	ind--;	if(ind % 2 == 0LL)&#123;		return x - a[ind] + qz[ind];	&#125;else return qz[ind];&#125;signed main()&#123;	scanf(&quot;%lld&quot;,&amp;n);	for(long long i = 1;i&lt;=n;i++)&#123;		scanf(&quot;%lld&quot;,&amp;a[i]);		if(i % 2 == 0) qz[i] = qz[i - 1];		else qz[i] =qz[i-1] + a[i] - a[i-1];	&#125;	long long q;	scanf(&quot;%lld&quot;,&amp;q);	while(q--)&#123;		long long l ,r;		scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r);		printf(&quot;%lld\n&quot;,getnum(r) - getnum(l));	&#125;	return 0;&#125;
F.ZZUacm 欢迎你直接输出即可
#include&lt;iostream&gt;using namespace std;int main()&#123;	cout&lt;&lt;&quot;hello zzuacm&quot;;	return 0;&#125;
G. 区间和的和注意使用int会溢出！！！
本题两种思路：
方案一、使用前缀和数组。
qz[i] 表示从第1个数到第i个数的总和。计算出前缀和数组后 q[i+k-1] - qz[i-1]就能表示 [i,i+k-1] 的总和。
#include&lt;iostream&gt;using namespace std;const int MAXN = 1e6+5;long long qz[MAXN];int main()&#123;	int n,k;	cin&gt;&gt;n&gt;&gt;k;	long long num;	qz[0] = 0;	for(int i = 1;i&lt;=n;i++)&#123;		scanf(&quot;%lld&quot;,&amp;qz[i]);		qz[i] += qz[i-1];	&#125;	long long ans = 0;//一定要初始化	for(int i = 1;i+k-1&lt;=n;i++)&#123;		ans += qz[i + k -1] - qz[i-1];	&#125;	cout&lt;&lt;ans;	return 0;&#125;
方案二、使用滑动窗口
如果用a[i] 表示第i个数，用 sum(L,R) ( R = L +k-1)   表示从第L个数到第R个数的总和。
那么可以发现 对于任意的L和R。都有sum(L+1,R+1) = sum(L,R) - a[L] + a[R] ，因此可以使用一个变量sum来记录当前k个数的总和，然后窗口每向右移动一下，就使用上述公式来更新sum的值。然后让ans每次都加上sum即可。
#include&lt;iostream&gt;using namespace std;const int MAXN = 1e6+5;long long a[MAXN];int main()&#123;	int n,k;	cin&gt;&gt;n&gt;&gt;k;	a[0] = 0;	for(int i = 1;i&lt;=n;i++)&#123;		scanf(&quot;%lld&quot;,&amp;a[i]);	&#125;	long long sum = 0;	for(int i = 1;i&lt;k;i++)&#123;		sum += a[i];	&#125;	long long ans = 0;	for(int i = k;i&lt;=n;i++)&#123;//i遍历右端点		sum = sum + a[i] - a[i-k];		ans += sum;	&#125;	cout&lt;&lt;ans;	return 0;&#125;
H. Sum of Maximum Weights压轴题！！
本题考察的算法知识： 并查集及其优化策略，树
题目要求每两点之间的 “最短路径的**最大权值** ”的和 ， 我们可以对边按照权值排序，这样每次处理都会是比之前都要大的权值。
每次处理一条边，考虑这个边的起点u和终点v。他们一定在不同的组（并查集中的组），设为U组和V组, 并且这两组分别有sizeU和sizeV个成员。那么U组中任意一个成员，到V组中的任意一个成员，他路径的最大权值都是e（e为当前边的权值）。这样我们就可以让ans = ans + size[u]*size[v]*e 来计算这两组成员之间互相连通产生的 最大权值的和。 然后就可以将这两组合并。
依次对每条边考虑上述情况，就可以得到总共的最大权值的和。
注意：本题使用int记录答案会导致数据溢出。
#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N = 2e6+5;const int M = N*2;int a[N],b[N];int fa[N];//并查集的father数组int size[N];//并查集中记录该组数据的数量int getf(int u)&#123;//并查集中的寻找祖先函数get_father	return u == fa[u] ? u : fa[u] = getf(fa[u]);&#125;struct edge&#123;	int u,v,e;//从u到v有一条权值为e的边&#125; e[N];//存储边的关系bool cmp(edge x,edge y)&#123;//edge结构体的比较函数	return x.e &lt; y.e;&#125;signed main()&#123;	int n;	cin&gt;&gt;n;	for(int i = 1;i&lt;n;i++)&#123;		scanf(&quot;%lld %lld %lld&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].e);	&#125;	for(int i = 1;i&lt;=n;i++)&#123;//并查集的初始化		fa[i] = i;		size[i] = 1;	&#125;	sort(e+1,e+n,cmp);	int ans = 0;	for(int i = 1;i&lt;n;i++)&#123;		edge t = e[i];		int u = t.u, v = t.v, e = t.e;		u = getf(u),v = getf(v);//找到祖先		if(size[u] &lt; size[v])&#123;//将并查集中的较小树作为较大树的子树			swap(u,v);		&#125;		ans += size[u] * size[v] * e;//计算ans		//合并		fa[u] = v;		size[v] += size[u];	&#125;	cout&lt;&lt;ans&lt;&lt;endl;&#125;
I. 区间偶数和设a[i]表示第i个数，循环判断，如果l\le i \le r 并且a[i] 为偶数，令答案加上a[i]即可。
需要使用long long来避免int造成的溢出
#include&lt;iostream&gt;using namespace std;int main()&#123;	int n,l,r;	cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;	long long num;	long long ans  = 0;//一定要初始化	for(int i = 1;i&lt;=n;i++)&#123;		scanf(&quot;%lld&quot;,&amp;num);		if(l &lt;= i &amp;&amp; i &lt;= r &amp;&amp; num % 2 == 0)&#123;			ans += num;		&#125;	&#125;	cout&lt;&lt;ans;	return 0;&#125;
J. 矩阵注意：由于01之间没有空格，因此无法使用读入数字的方法读取数据，应该使用读入字符的方法读取
设mp[i][j]表示第i行第j列数字。可以发现，对于原矩阵,mp[i][j]在经过旋转90°，旋转180°，旋转270° 之后，他们会分别到mp[j][n+1-i],mp[n+1-i][n+1-j],mp[n+1-j][i]  这些位置。
我们说mp[i][j],mp[j][n+1-i],mp[n+1-i][n+1-j],mp[n+1-j][i]，这四个位置是相关联的。如果让矩阵在旋转的过程中原封不动，那么就应该令每组**”相关联的“** 的四个字符变为同一个数字。考虑要尽可能少地改变数字，我们改变出现次数少的数字。（即如果出现了1个1和3个0，那么就把1变成0）
不重不漏地遍历所有的**”关联组“** 即可。（也可以遍历所有的数字，这样的话每个关联组都会被重复调用四次，因此最后需要令ans/=4）
#include&lt;iostream&gt;using namespace std;char mp[105][105];int main()&#123;	int n;	cin&gt;&gt;n;	int ans =0;	for(int i = 1;i&lt;=n;i++)&#123;		for(int j = 1;j&lt;=n;j++)&#123;			cin&gt;&gt;mp[i][j];		&#125;	&#125;	for(int i = 1;i&lt;=n;i++)&#123;		for(int j = 1;j&lt;=n;j++)&#123;			int cnt = 0;			if(mp[i][j] == &#x27;0&#x27;) cnt++;			if(mp[j][n+1-i] == &#x27;0&#x27;) cnt++;			if(mp[n+1-i][n+1-j] == &#x27;0&#x27;) cnt++;			if(mp[n+1-j][i] == &#x27;0&#x27;) cnt++;			ans += min(cnt,4-cnt);		&#125;	&#125;	cout&lt;&lt;ans/4;	return 0;&#125;
K. 模拟类问题方案一、使用一个数组来存储邻居关系，gx[i][j] 表示i和j有邻居关系，之后遍历所有的关系，数出其中没有邻居关系的即可。
#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int dat[55][55];int gx[55][55];//gx[i][j]表示i和j之间有邻居关系int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    int l,r;    for(int i = 1;i&lt;=m;i++)&#123;        for(int j = 1;j&lt;=n;j++)&#123;            scanf(&quot;%d&quot;,&amp;dat[i][j]);        &#125;    &#125;    for(int i = 1;i&lt;=m;i++)&#123;        for(int j = 1;j&lt;n;j++)&#123;            gx[dat[i][j]][dat[i][j+1]] = gx[dat[i][j+1]][dat[i][j]] = 1;        &#125;    &#125;    int ans = 0;    for(int i = 1;i&lt;=n;i++)&#123;        for(int j = i+1;j&lt;=n;j++)&#123;            if(gx[i][j] == 0)                ans ++;        &#125;    &#125;    cout&lt;&lt;ans;    return 0;&#125;
方案二、数据量很小，把数据存储起来后，暴力枚举每一对关系即可。
#include&lt;iostream&gt;using namespace std;int dat[55][55];int main()&#123;	int n,m;	cin&gt;&gt;n&gt;&gt;m;	for(int i = 1;i&lt;=m;i++)&#123;		for(int j = 1;j&lt;=n;j++)&#123;			scanf(&quot;%d&quot;,&amp;dat[i][j]);		&#125;	&#125;	int ans = 0;//记录答案	for(int i = 1;i&lt;n;i++)&#123;		for(int j = i+1;j&lt;=n;j++)&#123;//枚举每一对人			int flag = 0;//flag记录是否找到了邻居关系			for(int p = 1;p&lt;=m;p++)&#123;				for(int q = 1;q&lt;n;q++)&#123;					//如果第p行第q这对邻居恰好是i和j					if((dat[p][q] == i &amp;&amp; dat[p][q+1] == j) || (dat[p][q] == j &amp;&amp; dat[p][q+1] == i))						flag = 1;				&#125;			&#125;			if(flag == 0) ans++;//如果没有找到邻居关系		&#125;	&#125;	cout&lt;&lt;ans;	return 0;&#125;
L. 找最大值只考虑奇数，如果比当前的最大值大，就更新最大值。
#include&lt;iostream&gt;using namespace std;int main()&#123;	int mx = -1000000;//使最大值起初为无穷小	int n;	cin&gt;&gt;n;	int num;	for(int i = 1;i&lt;=n;i++)&#123;		cin&gt;&gt;num;		if(num % 2 == 1 &amp;&amp; mx &lt; num)&#123;			mx = num;		&#125; 	&#125;	cout&lt;&lt;mx;	return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建qqbot经历</title>
    <url>/378335218210/</url>
    <content><![CDATA[2024-7-4
虽然最终没有成功配置好qqbot，但是感觉这个过程还是值得记录的，所以写出了下文
最终因为登陆qq时的code45问题导致没有成功登录，据说更换qq号或者配置签名服务器是有可能可行的。
安装环境安装mcl（mirai的控制台）创建一个文件夹mcl 并进入文件夹
mkdir mcl &amp;&amp; cd mcl
寻找适合你的操作系统的的mcl安装包 ([下载链接](https://github.com/iTXTech/mcl-installer/releases))，将安装包下载到刚刚创建的文件夹中
下面shell指令以mcl-installer-1.0.7-linux-amd64为例
wget https://github.com/iTXTech/mcl-installer/releases/download/v1.0.7/mcl-installer-1.0.7-linux-amd64
赋予可运行权限，运行
chmod +x 
./mcl-installer-1.0.7-linux-amd64
这时候就安装好mcl了，之后只需要进入文件夹后使用
./mcl
就可以打开mcl了
安装mirai-api-http打开mcl的目录，使用指令安装
./mcl --update-package net.mamoe:mirai-api-http --channel stable-v2 --type plugin
运行mcl
./mcl -u
安装aliceBot使用pip安装
pip install alicebotpip install alicebot-adapter-mirai
安装验证器验证器用在登录qq中
fix-protocol-versionhttps://github.com/cssxsh/fix-protocol-version
基于**mirai**的qsign api对接。
qsign（签名）已经及咯！TAT
仓库
https://github.com/MrXiaoM/qsign/tree/bak
发行版下载
https://github.com/MrXiaoM/qsign/releases
mirai-login-solver-sakura[mirai-login-solver-sakura](https://github.com/KasukuSakura/mirai-login-solver-sakura) 滑块验证解决器
进入mcl的plugins，将github项目中的发行版jar放入文件夹中
wget https://github.com/KasukuSakura/mirai-login-solver-sakura/releases/download/v0.0.12/mirai-login-solver-sakura-0.0.12.mirai2.jar
mirai-device-generator[mirai-device-generator](https://github.com/cssxsh/mirai-device-generator) 仿真设备信息生成器
在mcl目录中使用指令一键安装
./mcl --update-package xyz.cssxsh.mirai:mirai-device-generator --channel maven-stable --type plugin
配置Mirai协议适配器配置Mirai-api-httphttps://docs.alicebot.dev/guide/adapters/mirai-adapter (aliceBot手册)
编辑 mirai-api-http 的配置文件 setting.yml。
Websocket Adapter模式
在mirai中的setting.yml文件中合并如下内容（即若原先出现了某个属性，则进行修改，若原先没有某属性则添加）
(setting.yml文件在 ./config/net.mamoe.mirai-api-http/setting.yml, 若您没有该文件，请检查是否安装并更新好**mirai-api-http**)
adapters:  - wsenableVerify: trueverifyKey: 1234567890adapterSettings:  ws:    host: localhost    port: 8080    reservedSyncId: -1
创建一个aliceBot项目[官方文档](https://docs.alicebot.dev/guide/quick-start)
项目结构.├── plugins (插件目录)│   └── xxx.py├── config.toml (配置文件)└── main.py
具体步骤创建一个目录
mkdir alicebot-start &amp;&amp; cd alicebot-start
创建plugins文件夹，用来存放插件
mkdir plugins
创建一个main.py文件，并写入如下信息

shell指令：

vim main.py

文件内容：

from alicebot import Botbot = Bot()if __name__ == &quot;__main__&quot;:    bot.run()
创建config.toml并编写内容

shell指令:

vim config.toml

文件内容（其中verify_key填写为上文setting.yml中的verifykey内容 ， qq = 填写为qqbot的qq号）

[bot]adapters = [&quot;alicebot.adapter.mirai&quot;][adapter.mirai]adapter_type = &quot;ws&quot;verify_key = &quot;1234567890&quot;qq = 机器人QQ号
运行后台运行指令以运行python为例
nohup python3 -u main.py &gt; out.log 2&gt;&amp;1 &amp;
该命令会运行当前目录下的test.py并把输出和报错都发送到文件out.log中。
使用jobs指令查看后台运行的进程
jobs
使用kill 指令杀死某个后台运行的进程(注意使用kill 1代表杀死进程号为1的进程， kill %1才是杀死作业号为1的作业）
kill %1
]]></content>
      <categories>
        <category>搭建环境</category>
      </categories>
      <tags>
        <tag>qqbot</tag>
      </tags>
  </entry>
  <entry>
    <title>期末回顾</title>
    <url>/555324d54baf/</url>
    <content><![CDATA[本文知识点均为从网络或其他地方搜集整理而来，提到的习题均无答案，完全不具备权威性质，作者不对看本文造成的后果负责，请合理参考。本人为ZZU2022级网安学院物联考生，以下是我对实际考试的考后记录，仅供复习参考。不保证提供的信息完全正确！！！用爱发电，欢迎纠正和补充，分享时请注明来源
我的复习资料合集[夸克网盘](https://pan.quark.cn/s/282df4876ab0) 资料仅供分享，不要抄袭！转发请注明出处。
2022大一上下期末回顾大一都是公修课，倒是用不上太多复习资料。
就随便说一下复习策略：

数学相关/离散数学/大学物理：一定要多看课后题，很多原题！！（看不懂就重新回顾知识点）
英语：背单词，没啥多说的。（听力需要重视一下）
政治：平时学不学区别不大，最后一两节课老师很可能会划重点。也可以去网上找资料（仅限政治可以去网上找资料！）

2023大二上期末回顾计算机组成原理任课老师：王银玲老师 ，林楠老师**题型**40选择10判断5计算 （25分）3综合（共25分）
其中选择题主要考察第2-6章（其他章节也略微出现一些题目）主要（占比较大的部分）为各种码的表示范围（补码，浮点数等），加减溢出判断，cache相关概念以及运算，地址偏移（注意pc+1中的1的含义），以及一些基础琐碎知识。判断题与选择类似，主要为一些小知识点。计算题：

整数的运算（给出x和y的补码，求z=2x+y/2的机器码，判断是否溢出）
浮点数的表示（1.01001x2^3）
带宽计算
给出指令长度16地址长度5，二地址指令60个一地址指令125个问零地址指令多少个
cpu处理设备，中断处理cpu占用率

综合题：

给出中断屏蔽字表，写出中断源的优先级
mips指令格式等（r型i型j型）
cache与虚拟内存的相关计算。（cache，主存，虚拟内存的字段划分）

历年考研原题占比**相当大**如果使用的课本同样是南京大学袁春风老师主编，可以借助如下链接学习/复习:[南京大学计算机组织与系统结构](http://media.njude.com.cn/course/jsjzcyl/index.htm)
数字电路与数字系统任课老师 ： 杨晓东老师，王瑞娟老师
基本都是课后题原题！！！一定要看一遍课后题！（如果时间充裕，最好把所有的课后题都看一下，时间不充裕就再看看老师布置的作业）
只考到触发器，没有考时序逻辑电路
**题型：**

10填空
8选择（2 * 8 = 16）
9判断
3看图写逻辑表达式（3*5 = 15）
3逻辑表达式的转换（3*5=15）
2应用大题（8+12）
2画波形图

**填空**
一些概念
余三码，二进制，十进制，十六进制的转化
2012个1的异或
看图写逻辑表达式
根据电路是否有记忆功能将电路分为组合逻辑电路和__
**选择**
根据ttl门电路，cmos门电路以及输入值，判断输出值
根据组合逻辑电路写逻辑表达式
选出oc门电路的对应符号
**判断**
基本都是概念
格雷码中相邻的数只有一位不同。
基本jk，主从jk，边沿jk的逻辑功能完全相同
**看图写逻辑表达式**
看的三个图（都是课本原题）分别为：

集成原件（四路选择器）
CMOS （中间有X，最终答案是A xor B的那道）
TTL （ A+B的非）

**逻辑表达式的转换**

化简为与非-与非式
画出卡诺图
画出卡诺图并化简

**应用题**
（都是课本原题）

1根据组合逻辑电路图求逻辑表达式，并画真值表，说出功能。逻辑表达式为AB+AC+BC

三个用电器ABC，两个发电机V1，V2。只有一个用电器时V1工作，恰有两个时V2工作，三个用电器时V1和V2都工作）
**画波形图**

基本RS-FF触发器
带异步Rd ,Sd 功能的主从JK触发器

毛概**材料：**
（1）如何理解过渡时期的总路线？ （20分）
（2）如何把握毛泽东思想的主要内容？（20分）
**论述：**

新民主主义革命的基本纲领是什么，以及新民主主义革命的意义（30分）

社会主义初步探索过程中产生了哪些的关键理论。社会主义初步探索的经验总结。（30分）


Linux**题型：**

30单项选择30分
10判断 10分
20填空 20分
4简答 20分
2综合 20分

选择判断不难，都是基础的指令填空考了一些概念，以及一堆关于用户和组的指令（比如新建删除修改用户和组，冻结解冻用户密码，相关内容一共九个空）综合也有一道指令题，考察分区fdisk，格式化mkfs.xfs，挂载mount的过程。综合题（1）提示输入一个目录（2）如果没有输入，则提示“请输入一个目录”（3）如果输入的不是目录，则提示“输入的不是目录”（4）如果输入的是目录，则遍历目录下的所有文件，如果文件是普通文件就复制到/tmp下，否则删除该文件
近代史**简答题**

简述中国近代反侵略战争失败的原因和教训
简述辛亥革命胜利的意义
中国式现代化的鲜明特征

**材料题**

建党精神的内涵
如何弘扬抗战精神
如何理解长征永远在路上
为什么说毛泽东将进入北平称作进京赶考

**论述题**

如何探索和中国革命新道路，并谈谈是怎样持续发展的

数据结构考的内容特别多，基本上考纲上有的都考到了。
选择判断填空都不难，都是基础知识。
**综合题：**

根据中序序列和后序序列画二叉树

给出0-14的表，哈希映射模13，以及12个数，求他们用平方探测法都放在了哪些位置，以及等概率下成功查找的平均查找长度

哈夫曼编码，给出abcdefgh的出现频率，让你画哈夫曼树，并求出平均长度

给出一个6x6的有向图


画图
求dijsktra后的1号定点到其他定点的最短路径的长度，并写出经过的定点
写出他的邻接表表示图 
求无向图的最小生成树，若有a-b和b-a取较小


15个数的shell排序写出每一趟的结果

**编程题：**
给出有序单链表，对他去重。（即将1 2 3 3 4 4 4 5 9， 变为 1 2 3 4 5 9)
2023大二下期末回顾英语没有阅读题所以时间比较充足连线题和正误题都是书中原文改编，注意看课后题。尤其是课后题中的选择题和短句子填空等。翻译考察了茶文化。作文考察 “the inportance of Chinese myths and legends in modern life”。中国神话传说对于现代生活的影响。要求列举几个神话并介绍他对于中国人的道德观价值观等的影响，以及如何传承发展中国神话传说。
操作系统选择 30填空 20判断 20大题x3 30考的很杂，很多概念io的五层，spooling技术的各个区。等等但是选择题有很多原题，一定要看历年考题和考研题(尤其是老师发的习题资料)大题1.给出作业进入顺序，问抢占式情况下，每个作业进入内存的时间，完成时间，和平均周转时间2.给出页面调用顺序，求FIFO和LRU分别的缺页次数和缺页率3.有一个景点，最多容纳1000人，一个入口一个出口，写同步互斥代码。
习概一大题1.为什么说中国特色社会主义进入新时代2.如何铸就中国文化二大题1.中国式现代化需要把握的重大关系2.新时代下如何建设美丽中国
物联网工程导论20填空(20x1)5多选(5x2)5简答(5x10)1设计题(20)大部分都是白皮书原题，尤其是简单题基本都是白皮书原题。简答题：1.物联网和互联网的区别2.物联网的三层模型3.RFID的组成部分和各个功能，无源RFID标签怎么工作的4.ipv6的特点以及为什么物联网时代将成为最重要重要的协议之一5.GNSS是什么，以及阐述GPS的三个部分设计题设计一个联网的物联系统，要求写出功能介绍，硬件配置，逻辑关系，并介绍用到的物联网技术
马原选择30多选10x2(少选不给分)材料(10x3)论述
主要考前五章，重点前三章。材料题实践和认知的关系物质和意识的关系矛盾的辨证统一关系(发展和生态保护的矛盾)论述题结合对立统一原理阐述为什么说我国的现代化发展中“既有成就，也有问题”。
计网40选择10判断10填空3x10大题
各种知识都考察到了，注意会有很多考研原题，一定要看老师发的资料。大题一 阐述dns协议的作用，以及客户端浏览器寻找一个域名，dns提供的服务过程。二考察网络结构图1.为路由器加上某个网络的跳转地址2.两个主机之间相互通信，依次经过了交换机，路由器，集线器。起初arp和交换表都是空，问两次交换数据哪些主机收到了。3.考察nat协议转发前后的，源地址和目的地址。三，给一个c类网络地址，将该地址分为五个子网。每个子网至少20-30个主机。
单片机15选择15判断4简答(7 8 8 9)5程序填空(共40分)绝大部分题都是课后题原题
简答1.简述51单片机的组成2.简述单片机最小系统有哪些部分，以及各部分的作用3.简述定时器工作方式1和2的特点4.串行口的四种工作方式程序1 2 3 根据程序代码写出运行结果

第一问：求出时钟频率6MHz，定时器工作方式1的情况下，定时1ms的定时器初值X第二问：程序填空，考察中断入口，以及填入初值5.多机通信第一问：画多机通信图第二问：六选四型程序填空

2023大三上期末回顾数据库**填空**amstrong 公理系统数据模式 三要素索引选择策略去重关键词定义表时的唯一性范式的定义等等…**大题简答：**连接操作算法有哪些，在连接两个表(10行和1000行)时各需要扫描表几次并发导致的几种问题是什么，以及哪些方法防止了哪个问题**计算：**一、sql语法：选择语句(考到了三重select 加 in 加 not exists)，插入语句，创建视图二、ER图给出一个系统，画出er图

写出该er图的关系模式3.指出关系模式中的主码和外码三、函数依赖集
求最小依赖集
分解关系，使得满足第三范式

传感器考的非常基础**选择多选**：和白皮书最近一套重合度很高。很基础。**填空**：比较难的有：微波的三类动态特性概念：时域，频域**判断：**冷门的有生物化学传感器(测血糖用的是酶传感器吗？)，但是前面选择给提示了。大题六道：

举出五个智能驾驶用到的传感器
一阶函数的响应曲线计算(原题)
平板电容器的电容变化量和位移灵敏度(原题)
变气隙式厚度电感式求灵敏度
求最大相对误差，给出两个温度计(精度等级0.5的0-300)和(精度等级1的0-100)问哪个好
写出传感器的五个发展趋势

嵌入式**简答**

嵌入式系统的定义，与通用计算机的区别
时钟系统有哪些
总线有哪些
NVIC配置
GPIO配置
ADC转换时间计算
uart传输时间计算
比较uart，i2c，spi9.嵌入式系统的开发过程程序填空有GPIO，ADC，DMA，TIM和NVIC的填空题有五题，每题两空
DMA传输四要素

人工智能**简答：**1.人工智能的定义，近期目标和远期目标2.状态空间法的定义和步骤3.消解原理的过程4.AI BI CI 的关系和区别5.人工神经网络的三要素和含义**计算：**消解原理(书上原题找罪犯)主观贝叶斯(课后作业原题)决策树(贼简单，一步成)
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>期末</tag>
        <tag>学习</tag>
        <tag>郑州大学</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客周赛round51</title>
    <url>/9d8cbf6e4caf/</url>
    <content><![CDATA[[牛客周赛 Round 51比赛链接](https://ac.nowcoder.com/acm/contest/86034)
A.小红的同余题意给一个**奇数**m，请你找出一个数`x (0 \le x < m)  使得 2x \equiv 1 (mod\ m)
思路2x \equiv 1(mod \ m)  即 2x 取余m等于1.   那么由于m是奇数， 很容易想到一个方案 2x = m+1 ， 即x = \frac{m+1}{2}
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int m;	cin&gt;&gt;m;	cout&lt;&lt;(m+1)/2;	&#125;signed main()&#123;	int T = 1;	// cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
B.小红的三倍数题意给n个数，问是否存在一种方案，使得  **这n个数拼接之后是3的倍数**。
思路这里要用到一个数学知识，即**x是3的倍数**等价于 **x的每一位相加的结果是3的倍数**。
如123 ，按位相加后1+2+3 = 6 ,6 \% 3 == 0  于是123是3的倍数。
所以我们不需要关心拼接的方案，只需要将每个数按位加和。 判断最终的总和是不是3的倍数即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int n;	cin&gt;&gt;n;	int ans =0;	rep(i,1,n)&#123;		string str;		cin&gt;&gt;str;		for(auto p : str)&#123;			ans += (p - &#x27;0&#x27;);		&#125;	&#125;	if(ans%3 == 0) cout&lt;&lt;&quot;YES\n&quot;;	else cout&lt;&lt;&quot;NO\n&quot;;&#125;signed main()&#123;	int T = 1;	// cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
C.小红充电题意题目中的题意就很好懂，我这边直接粘贴下来
思路如果当前的电量x小于超级充电的门槛电量t。 那么我们直接开启超级快充直到充满即可
ans = \frac{100-x}{c}(x \le t)
如果当前的电量x大于超级充电的门槛电量t。 那么我们有两个选择

使用普通充电，耗时t1 = \frac{100-x}{b}
先玩游戏使得电量等于门槛电量t，然后开始超级快充 ，耗时t2 = \frac{x-t}{y} + \frac{100-t}{c}

最终答案为ans = min(t1,t2)
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	int x,y,t,a,b,c;	cin&gt;&gt;x&gt;&gt;y&gt;&gt;t&gt;&gt;a&gt;&gt;b&gt;&gt;c;	if(x &lt;= t) &#123;printf(&quot;%.8lf&quot;,(100 - x+0.0)/c);&#125;	else&#123;		double ans1 = 0;		double ans2 = 0;		ans1 = (100.0-x)/b;		ans2 = (x-t+0.0)/y + (100.0-t)/c;		printf(&quot;%.8lf&quot;,min(ans1,ans2));	&#125;	return ;&#125;signed main()&#123;	int T = 1;	// cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
D. 小红的 gcd题意求gcd(a,b) , 其中1\le a \le 10^{10^6}, 1\le b \le 10^9
思路本题考察辗转相除法。 即 gcd(a,b) = gcd(b,a\%b)因此我们计算出c = a\%b 之后， 再使用基本的gcd就可以得出结果于是我们问题就变为了如何求a\%b 。 
我们设a一共有n位，每一位为a_1,a_2,...,a_n 。那么有 a = (((0+a_1)*10+a_2)*10...)+a_n
于是a\%b = ((((0+a_1)*10\%b+a_2)*10\%b...)+a_n)\%b  .这样就可以保证运算过程中的数据始终在long\ long的范围内
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;	string a;	int b;	cin&gt;&gt;a&gt;&gt;b;	int aa = 0;	for(auto p : a)&#123;		aa = aa*10 + p - &#x27;0&#x27;;		aa %= b;	&#125;	cout&lt;&lt;__gcd(aa,b)&lt;&lt;endl;&#125;signed main()&#123;	int T = 1;	// cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
E.小红走矩阵题意有一个n*n 的矩阵,小红从 undefined1,1)走到(n,n)$ ,定义一条路径的权值为**经过的所有点的最大值** .  请你找到**权值最小**的路径
思路求某个东西的 **最小的最大值** .考虑二分答案 .
我们假设要找一条权值不大于k的路径 , 那么显然 , 所有大于k的点我们都不能走 ,  所以在本次check中 , 将所有大于k的点都视为障碍物,使用bfs检查是否能从起点走到重点 , 若能则代表 ans \le k , 否则ans > k
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int n;bool vis[505][505];int nextx[4] = &#123;0,0,1,-1&#125;;int nexty[4] = &#123;1,-1,0,0&#125;;int mp[505][505];bool check(int mid)&#123;	if(mp[1][1] &gt; mid) return false;	memset(vis,0,sizeof(vis));	queue&lt;PII&gt; q;	q.push(&#123;1,1&#125;);	vis[1][1] = true;	while(q.size())&#123;		int x = q.front().first;		int y = q.front().second;		q.pop();		if(x == n &amp;&amp; y == n) return true;		for(int i = 0;i&lt;4;i++)&#123;			int nx = x + nextx[i];			int ny = y + nexty[i];			if(nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; n || vis[nx][ny]) continue;			if(mp[nx][ny] &gt; mid) continue;			vis[nx][ny] = true;			q.push(&#123;nx,ny&#125;);		&#125;	&#125;	return false;&#125;void solve()&#123;	cin &gt;&gt; n;	for(int i =1;i&lt;=n;i++)&#123;		for(int j = 1;j&lt;=n;j++) cin&gt;&gt;mp[i][j];	&#125;	int l = 1,r = 1e9+5;	while(l&lt;r)&#123;		int mid = (l+r) &gt;&gt; 1;		if(check(mid))&#123;			r = mid;		&#125;else		l = mid+1;	&#125;	cout&lt;&lt;l;&#125;signed main()&#123;	int T = 1;	// cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;	
F.小红的数组题意给n个数a_1,a_2,...,a_n , 以及q组询问 , 每次询问两个参数l,r , 问区间连续子段和的绝对值最大是多少 .  即有l \le x \le y \le r ,  求最大的 abs(a[x] + a[x+1] +... + a[y]) 是多少
思路先对a数组进行求前缀和, s[i] = \sum _{j=1}^i a[j]
于是求abs(a[x]+a[x+1]+...+a[y]) 就等价于求abs(s[y] - s[x-1])  , 而题目规定l \le x \le y \le r , 那么我们只需要找到MAX_{i=l-1}^r s[i] ， 以及MIN_{i=l-1}^r s[i] , 二者进行相减即可得出答案。
对于求区间最大/最小值问题， 我们使用ST表即可。
注意使用cin和cout可能会超时，需要关闭IO同流。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int lg[500005];int n;	int a[500005];int f1[500005][30];int f2[500005][30];void init()&#123;	lg[1] = 0;	rep(i,2,500003) lg[i] = lg[i&gt;&gt;1]+1;	rep(i,1,n) &#123;		f1[i][0] = a[i];		f2[i][0] = a[i];	&#125;	for(int j = 1;j&lt;=lg[n+1];j++)&#123;		for(int i = 0;i &lt;= n-(1&lt;&lt;j)+1;i++)&#123;			f1[i][j] = max(f1[i][j-1],f1[i+(1&lt;&lt;(j-1))][j-1]);			f2[i][j] = min(f2[i][j-1],f2[i+(1&lt;&lt;(j-1))][j-1]);		&#125;	&#125;&#125;void solve()&#123;	cin&gt;&gt;n;	for(int i = 1;i&lt;=n;i++)&#123;		cin&gt;&gt;a[i];		a[i] += a[i-1];	&#125;	init();	int q;	cin&gt;&gt;q;	while(q--)&#123;		int l, r;		cin&gt;&gt;l&gt;&gt;r;		l--;		int log = lg[r-l+1];		int ans = \		max(f1[l][log],f1[r-(1&lt;&lt;log)+1][log])- \		min(f2[l][log],f2[r-(1&lt;&lt;log)+1][log]);		cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;	&#125;&#125;signed main()&#123;	IO;	int T = 1;	// cin&gt;&gt;T;	while(T--)&#123;		solve();	&#125;	return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客周赛 35</title>
    <url>/8eac4d8e9423/</url>
    <content><![CDATA[[题目链接-牛客周赛 Round 35](https://ac.nowcoder.com/acm/contest/76133#question)
A - 小红的字符串切割题意给出一个长度为偶数的字符串，分别输出前一半和后一半
思路&amp;代码按题意输出即可
#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    string str;    cin&gt;&gt;str;    cout&lt;&lt;str.substr(0,str.length()/2)&lt;&lt;endl;    cout&lt;&lt;str.substr(str.length()/2,str.length()/2);&#125;signed main()&#123;    int T = 1;//     cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B - 小红的数组分配题意给你一个长度为2*n的数组，问能否分成两个长度为n的数组a,b使得a_i = b_i  。
思路先对原先的数组排序后 ，依次分别装入a和b即可。 如果在某次装入时值不同则无解。
代码void solve()&#123;    int n;    cin&gt;&gt;n;    vector&lt;int&gt; vec;    rep(i,1,2*n)&#123;        int num;cin&gt;&gt;num;        vec.push_back(num);    &#125;    sort(vec.begin(),vec.end());    vector&lt;int&gt; a;    for(int i = 0;i&lt;=2*n-1;i+=2)&#123;        if(vec[i] != vec[i+1]) &#123;cout&lt;&lt;-1&lt;&lt;endl;return ;&#125;        a.push_back(vec[i]);    &#125;    for(auto p : a)&#123;        cout&lt;&lt;p&lt;&lt;&#x27; &#x27;;    &#125;    puts(&quot;&quot;);    for(auto p : a)&#123;        cout&lt;&lt;p&lt;&lt;&#x27; &#x27;;    &#125;    puts(&quot;&quot;);&#125;
C - 小红关鸡题意给出一些鸡窝的坐标x_i, 以及你的栅栏的长度k  , 如果鸡在栅栏围住的区间中，那么他就被抓住。 现在鸡在所有鸡窝中等可能出现，问关注鸡的最大概率是多少。
思路其实就是问在一个区间[x,x+k-1] 中，最多有几个鸡窝。先对所有的坐标排序，之后可以双指针来找，也可以枚举左端点，然后二分右端点。
代码void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    vector&lt;int&gt; a;    rep(i,1,n)&#123;        int num; cin&gt;&gt;num;        a.push_back(num);    &#125;    int ans = 0;    sort(a.begin(),a.end());    for(int i = 0;i&lt;n;i++)&#123;        int r = a[i]+k;        int rind = upper_bound(a.begin(),a.end(),r)-a.begin();        ans = max(ans,rind-i);    &#125;    cout&lt;&lt;double(ans)/n;&#125;
D - 小红的排列构造题意给你一个数组，问最少修改几个数能使得这个数组是一个**排列**。给出一种修改方案。
(排列指的是1,2,3,...,n以任意顺序组成的数组) 
思路对于1~n这n个排列数，如果某个数x在原数组中已经存在，那么就一定不需要操作来变成x 。
而对于1~n这n个排列数，如果某个数y在原数组中不存在，那么一定需要进行一次操作来使某个数变成y。
为了得到具体的方案，我们需要记录**“冗余数”**的坐标。冗余数由以下两部分组成：

位于1~n区间内，但该数已经出现过。
不位于1~n的区间内。

如n=6 ，1,2,3,3,6,10 那么第二个3和10被视为了冗余数。
于是我们使用数组cnt记录1~n中每个数都出现了几次。 然后枚举1~n， 每当cnt[i] = 0 我们就选出随意一个冗余数，将它变为i。
代码int cnt[100005]; //记录1到n每个数都出现了多少次void solve()&#123;    int n;    cin&gt;&gt;n;    stack&lt;int&gt; st;    rep(i,1,n)&#123;        int num; cin&gt;&gt;num;        if(num&lt;1 || num &gt; n)&#123;            st.push(i);        &#125;else &#123;            cnt[num]++;            if(cnt[num]&gt;1) st.push(i);        &#125;    &#125;    int ans = 0;//一共需要修改几个数    for(int i = 1;i&lt;=n;i++)&#123;        if(cnt[i] == 0) ans++;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;    for(int i = 1;i&lt;=n;i++)&#123;        if(cnt[i] == 0) &#123;            cout&lt;&lt;st.top()&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&#x27;\n&#x27;;            st.pop();        &#125;    &#125;&#125;
E - 小红的无向图构造题意给出你n个节点， 以及从这n个节点到达第一个顶点的最短路距离a_i  。现在需要你构造一个有m条边的无向图，图中每条边的边权都为1，使得这个图满足距离限制。无向图中不应该包含重边或者自环。如果无解就输出-1。
保证(a_1 = 0,对于i\ge 2,1\le a_i \le n-1 )
思路首先我们知道每个节点都能到达1号节点，因此整个图一定是连通图。那么就出现了**第一个限定条件**：m\ge n-1 , 否则我们没有足够多的边来将所有顶点连接为一个整体。
接下来我们思考如何满足所有节点的距离限制。 如果我们将这n个节点组成一棵树，树根是1号顶点。 那么每个顶点到达1号顶点的最短路径长度即为这个节点的深度再减去1 。于是我们只需要**将节点按照深度进行分层组成一棵树**然后连接即可满足距离条件。
此时我们便发现了**第二个限定条件** ：若存在距离为a_k  的节点，但不存在距离为a_k - 1 的节点，那么一定无法构建这么一个无向图。若一个节点到达1号节点的最短距离为a_k, 那么他一定需要首先走到距离为a_k - 1的节点上。
可是我们要构造的是一个m条边的无向图，而不是一个n- 1条边的树。 我们需要在这棵树的基础上增加一些无关紧要的冗余边，使得每个节点到达1号节点的最短距离不变。可以发现，对于位于同一层的顶点，我们让他们任意两条边相连，都不会改变每个点到达1号顶点的最短距离。 同时，若让第i 层的节点与第i - 1层的节点两两相连，也不会使得某个节点到达1号节点的最短路径变小。
但是增加冗余边是有上限的，从没有任何边开始加的话，如果第i层的节点有b_i个 ，那么我们同层内只能增加undefinedfrac{b_i * (b_i=1)}{2}条边，而他和上一层可以连接b_i * b_{i-1}条边。 于是我们得到了边的最大限度maxm.于是就有了**第三个限定条件**m \le maxm$ 。
代码vector&lt;int&gt; dis[100005]; //dis[i]记录距离为i的节点的下标都有哪些void solve()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    rep(i,1,n)&#123;        int num; cin&gt;&gt;num;        dis[num].push_back(i);    &#125;    if(m&lt;n-1)&#123;cout&lt;&lt;-1;return ;&#125; //第一个限制条件    int maxm;//求边的最大限度    for(int i = 1;i&lt;n;i++)&#123;        int sz = dis[i].size();        if(dis[i+1].size() &amp;&amp; (dis[i].size() == 0))//如果不满足第二个限制条件就退出            &#123;cout&lt;&lt;-1;return;&#125;        int sz2 = dis[i-1].size();        maxm += sz*(sz-1)/2;//同层        maxm += sz*sz2;//相邻层    &#125;    if(m &gt; maxm) &#123;cout&lt;&lt;-1;return ;&#125;//第三个限制条件    //特判完毕，开始分配边    // 第一个二重循环，先建好一棵树。    for(int i = 1;i&lt;n;i++)&#123;        for(auto p : dis[i])&#123;            cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;dis[i-1][0]&lt;&lt;&#x27;\n&#x27;; //让每个节点都连接上一层节点(dis[i-1])的第一个节点(dis[i-1][0])        &#125;    &#125;    //分别考察每层能增加的冗余边    int le = m - (n-1);//还需要加几条冗余边    for(int i =1;i&lt;n;i++)&#123;        //同层        int sz = dis[i].size();        for(int j = 0;j&lt;sz;j++)&#123;            for(int k = j+1;k&lt;sz;k++)&#123;                if(le&lt;=0) &#123;return ;&#125;//如果不需要加了就return                cout&lt;&lt;dis[i][j]&lt;&lt;&quot; &quot;&lt;&lt;dis[i][k]&lt;&lt;&#x27;\n&#x27;;                le--;            &#125;        &#125;        //和上一层相连，但是只能从上一层的第二个节点(dis[i-1][1])开始连接        int sz2 = dis[i-1].size();        if(sz2 &lt;= 1) continue;//如果上一层没多余的节点        for(int j = 0;j&lt;sz;j++)&#123;            for(int k=1;k&lt;sz2;k++)&#123;                if(le&lt;=0) &#123;return ;&#125;//如果不需要加了就return                cout&lt;&lt;dis[i][j]&lt;&lt;&quot; &quot;&lt;&lt;dis[i-1][k]&lt;&lt;&#x27;\n&#x27;;                le--;            &#125;        &#125;    &#125;    return ;&#125;
F/G - 小红的子序列权值和题意定义一个数组的权值为 ： 数组中所有元素的乘积的因子数量，如[1,2,3] 的权值是4 .
现在**给你一个只有1 ，2，3三种数的数组a**， 问他们的所有**非空**子序列的权值的和是多少。
undefinedF: 1 \le n \le 10^3 , G: 1\le n \le 10^5)$
思路思路参考自该大佬-&gt;[题解链接](https://blog.nowcoder.net/n/58e379f6ec48457b859926673cde4b17)
我们用三个数cnt1,cnt2,cnt3来记录1,2,3这三个数各自出现了多少次 。 我们先不考虑1的问题，因为1对于一个数组最终的权值没有影响。 那么对于一个子序列，如果他有i 个2 ，j个3 ,他就会有undefinedi+1)*(j+1)个因子（ 选择0到i个2，以及0到j个3, 进行组合) 于是我们就可以枚举i从0到cnt2，j从0到cnt3. 对于每个i , j,他对答案的总贡献为 ：(i+1)*(j+1)*C_{cnt2}^i*C_{cnt3}^j其中C_a^b$表示从a中选择b个数的组合数。
 之后我们加上1对答案的影响，发现对于这cnt1个1，我们可以选择任意个1，于是共有2^{cnt1} 种选择，需要在原先答案的基础上乘上2^{cnt1} ，最终又由于题目要求子序列必须非空，令答案减一即为最终答案。
于是我们可以在n^2 的时间复杂度内完成本题，F题得以通过。
下面考虑如果节时来通过G题， 可以发现在i不变的情况下， 令j从0到cnt3， 贡献的答案为undefinedi+1)*C_{cnt2}^i *(1*C_{cnt3}^0+2*C_{cnt3}^1+…+(cnt3+1)*C_{cnt3}^{cnt3})，于是我们发现这个贡献中与cnt3有关的部分1*C_{cnt3}^0+2*C_{cnt3}^1+…+(cnt3+1)*C_{cnt3}^{cnt3}是一个常数，他的大小和i的取值无关，于是我们可以对他进行预处理， 然后我们枚举i即可， 于是就将计算答案的复杂度降为了O(n)。 但由于需要计算n个阶乘以及他们的逆元来求组合数，所以整段代码的复杂度为O(nlogn)$。
代码const int N = 1e5+5; // N的上界const int mod = 1e9+7; //模数int fac[N];// 阶乘,fac[i]表示 i 的阶乘int ifac[N]; // 阶乘的逆元 ifac[i] = inv(fac[i])int qpow(int x,int n)&#123; // 快速幂,用来求逆元    int ans = 1;    while(n)&#123;        if(n&amp;1) ans = ans * x % mod;        x = x * x % mod;        n&gt;&gt;=1;    &#125;    return ans;&#125;int inv(int x)&#123;//求逆元    return qpow(x,mod-2);&#125;void init()&#123; // 初始化,即预处理fac和ifac数组    fac[0] = 1;    for(int i = 1;i&lt;=1e5+2;i++)&#123;        fac[i] = fac[i-1] * i % mod;    &#125;    for(int i = 0;i&lt;=1e5+2;i++)&#123;        ifac[i] = inv(fac[i]);    &#125;    return ;&#125;int C(int a,int b)&#123;//求组合数    return fac[a] * ifac[b] % mod *ifac[a-b] % mod;&#125;void solve()&#123;    init();    int n;    cin&gt;&gt;n;    int cnt1,cnt2,cnt3;    cnt1 = cnt2 = cnt3 =0;    for(int i = 1;i&lt;=n;i++)&#123;        int num;cin&gt;&gt;num;        if(num == 1) cnt1 ++;        if(num == 2) cnt2 ++;        if(num == 3) cnt3 ++;    &#125;    int tmp = 0; //预处理    for(int i= 0;i&lt;=cnt3;i++)&#123;        tmp += C(cnt3,i) * (i+1)%mod;    &#125;    tmp %= mod;    int ans = 0;    for(int i = 0;i&lt;=cnt2;i++)&#123;//计算答案        ans = ans + C(cnt2,i)* (i+1) %mod *tmp %mod;    &#125;    ans = ans%mod * qpow(2,cnt1) % mod;//计算1的影响    cout&lt;&lt;ans-1;//输出ans-1&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客周赛round59</title>
    <url>/89dfe069fba2/</url>
    <content><![CDATA[比赛链接https://ac.nowcoder.com/acm/contest/89860
A - TD题意有m个人，其中n个人发送了TD，那么从m个人中随机挑选一个人，他发送过TD的概率是多少。
思路直接输出undefinedfrac{n}{m}$ 即可（要注意这里不是整数除法）
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    cout&lt;&lt;double(n)/m&lt;&lt;endl;&#125;signed main()&#123;    int T = 1;    // cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
B - 你好，这里是牛客竞赛题意给你一个链接，如果这个链接以https://ac.nowcoder.com或者ac.nowcoder.com 开头，就输出Ac
如果链接以https://www.nowcoder.com 或者www.nowcoder.com 开头，就输出Nowcoder ，
如果都不是，那么就输出No
思路可以先判断前几个字符如果是https;//就删掉这部分。
然后我们读取字符串，直到遇到.com就停止。
最后对读取的字符串判断即可。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    string str;    cin&gt;&gt;str;    if(str.substr(0,8) == &quot;https://&quot;)&#123;        str = str.substr(8);    &#125;    string ans = &quot;&quot;;    for(int i = 0;i&lt;str.size();i++)&#123;        if(i &gt;= 3 &amp;&amp; str.substr(i-3,3) == &quot;com&quot;) break;        ans += str[i];    &#125;    if(ans == &quot;ac.nowcoder.com&quot;) cout&lt;&lt;&quot;Ac\n&quot;;    else if(ans == &quot;www.nowcoder.com&quot;) cout&lt;&lt;&quot;Nowcoder\n&quot;;    else cout&lt;&lt;&quot;No\n&quot;;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
C - 逆序数题意已知一个**排列**undefined{ x_1 ,x_2,…,x_n \}的逆序对的数量是k, 请你输出\{x_n,…,x_2,x_1\}$ 的逆序对数量。
现在给你n,k ，请你输出结果。
思路一个长度为n的排列，一共有undefinedfrac{n*(n-1)}{2}个对， 并且只有正序对和逆序对，我们设数量分别为t,k,  那么在翻转整个排列后，显然原先的正序对会变为逆序的，逆序对会变为正序的。 那么反转后的逆序对的数量，就是原先正序对的数量。 即ans = t = \frac{n*(n-1)}{2} - k$
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    cout&lt;&lt;n*(n-1)/2 - k;    &#125;signed main()&#123;    int T = 1;    // cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
D - 构造mex题意给你整数s,k，请你将s分为**恰好**n个非负整数a_1,a_2,..,a_n， 使得a_1+a_2+...+a_n = s 并且 mex(a) = k 。 
注：mex(a)的含义是**在a数组中，未出现过的最小的非负整数**。
思路大讨论题，对于一般情况，我们很容易得知，需要构造0,1,2,...,k-1, s-(\frac{k*(k-1)}{2}),0,0,0 这样的数列。但是本题的关键在于考虑特殊情况。下面列举需要特判的条件：

如果k = 0 并且s < n ，条件无法成立那（这n个数中一定存在0，就不能使得k = 0.）
如果k = 1,s = 1 ,那么无论如何都不能成立。（a数组一定为一个1和一些0（可能为0个0），最后的mex一定为0或2，不是1）
如果n < k 那么无法成立（显然无法分出k份也就无法使得[0,k-1]都在a中出现，也就无法使得最终的mex是k）
如果n=k 且s \not= \frac{k*(k-1)}{2} ，无法成立（如果n和k相等，就代表应该恰好将s分为0,1,2,...,k-1 这k个数，如果总和不是s就违背了构造规则）
如果n = k+1 并且s = \frac{k*(k-1)}{2} + k 那么无法成立（即我们需要设置a数组为0,1,2,...,k-1,k , 那么它的mex就变为了k+1 而不是k)

代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;void solve()&#123;    int s,n,k;    cin&gt;&gt;s&gt;&gt;n&gt;&gt;k;    int sum = k*(k-1)/2;    if(k == 0)&#123;        if(s &lt; n) &#123;cout&lt;&lt;&quot;NO\n&quot;;return ;&#125;        cout&lt;&lt;&quot;YES\n&quot;;        rep(i,1,n-1)&#123;            cout&lt;&lt;1&lt;&lt;&#x27; &#x27;;        &#125;cout&lt;&lt;s-n+1;        puts(&quot;&quot;);return ;    &#125;    if(k == 1 &amp;&amp; s == 1)&#123;cout&lt;&lt;&quot;NO\n&quot;;return ;&#125;    if(n &lt; k) &#123;cout&lt;&lt;&quot;NO\n&quot;; return ;&#125;    if(sum &gt; s) &#123;cout&lt;&lt;&quot;NO\n&quot;; return ;&#125;    if(n == k) &#123;        if(sum != s) &#123;cout&lt;&lt;&quot;NO\n&quot;; return ;&#125;        else &#123;            cout&lt;&lt;&quot;YES\n&quot;;            rep(i,0,n-1)&#123;                cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;            &#125;puts(&quot;&quot;);return ;        &#125;    &#125;    if(n == (k+1) &amp;&amp; sum+k == s) &#123;cout&lt;&lt;&quot;NO\n&quot;;return ;&#125;    cout&lt;&lt;&quot;YES\n&quot;;    for(int i = 0;i&lt;k;i++)&#123;        cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;    &#125;    int left = s-sum;    if(left == k)&#123;        cout&lt;&lt;1&lt;&lt;&quot; &quot;&lt;&lt;k-1&lt;&lt;&#x27; &#x27;;        for(int i = k+3;i&lt;=n;i++) cout&lt;&lt;&quot;0 &quot;;    &#125;else&#123;        cout&lt;&lt;left&lt;&lt;&#x27; &#x27;;        for(int i =k+2;i&lt;=n;i++) cout&lt;&lt;&quot;0 &quot;;    &#125;    puts(&quot;&quot;);return ;&#125;signed main()&#123;    int T = 1;    cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
E - 小红的X型矩阵题意给你一个n*n 的01矩阵， 你进行若干次如下操作，使得最终的矩阵为X型矩阵 ，操作方法如下：

操作一：将矩阵中的一个元素反转（0变为1，1变为0）
操作二：将矩阵循环右移或者循环下移一位。

问最少需要几次操作一，能够使得矩阵变为X型矩阵
注：当且仅当一个矩阵的两个对角线全为1，其余地方全为0时，该矩阵为X型矩阵 （a_{ii}= 1,a_{i,n-i+1}= 1 其余全为0）
思路我们将最终目标的X矩阵进行一些次数的循环移动后，可以发现，X的中心移动到了矩阵中的某个位置，而其他的1同样在它的四个角落方向（若越界则循环至矩阵另一边）,因此这些1同样在两条对角线上。
10001           1100001010           1100000100    ---&gt;   0010101010           0001010001           00101
因此我们对输入矩阵维护每条对角线上的1的数量，然后我们枚举中心点的每个位置，找到和原矩阵匹配程度最大的那个即可（即在这两条对角线上，原矩阵的1出现的数量最多）。
需要注意如果n为偶数，因为两条对角线不存在交点，那么处理方式和奇数略有不同。
可以发现对于左上-右下对角线，我们可以这样表示它：i-j \equiv d (mod\ n) (对于每个d\in[0,n-1]，表示一条对角线)
对于左下-右上对角线，可以这样表示它：i+j \equiv d(mod\ n)(对于每个d\in[0,n-1]，表示一条对角线)
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int mp[1005][1005];int n;int sum1[2005];int sum2[2005];void solve()&#123;    cin&gt;&gt;n;    int sum = 0;    for(int i =1;i&lt;=n;i++)&#123;        for(int j = 1;j&lt;=n;j++)&#123;            cin&gt;&gt;mp[i][j];            if(mp[i][j]) sum ++ ;        &#125;    &#125;    for(int d = 0;d&lt;=n-1;d++)&#123;        for(int i = 1;i&lt;=n;i++)&#123;            int j = i + d;            if(j &gt; n) j -=n;            sum1[d] += mp[i][j];        &#125;    &#125;    for(int d = 0;d&lt;=n-1;d++)&#123;        for(int i = 1;i&lt;=n;i++)&#123;            int j = d - i;            if(j &lt; 1) j += n;            sum2[d] += mp[i][j];        &#125;    &#125;        int res = INF;    if(n%2 == 1)&#123;      for(int i = 1;i&lt;=n;i++)&#123;        for(int j =1;j&lt;=n;j++)&#123;            int cnt = sum1[(j-i+n)%n] + sum2[(i+j)%n] - mp[i][j];            int ans =(2 * n - 1 - cnt) + (sum - cnt);            res = min(res,ans);          &#125;      &#125;      &#125;else&#123;        for(int i = 1;i&lt;=n;i++)&#123;            for(int j = 1;j&lt;=n;j++)&#123;                int cnt = 0;                cnt += sum1[(j-i+n)%n];                int ii = i%n+1;                cnt += sum2[(ii+j)%n];                int ans =(2 * n - cnt) + (sum - cnt);                res = min(res,ans);            &#125;        &#125;    &#125;    cout&lt;&lt;res;&#125;signed main()&#123;    int T = 1;    // cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
F - 小红的数组回文值题意定义一个数组的回文值为：至少需要修改多少个数，能使得这个数组变为回文数组。
现在给你一个长度为n(1\le n \le 2000)的数组a_1,a_2,...,a_n ，问它的所有**子序列**的回文值的和是多少。答案对10^9+7 取模
思路我们应该先想到，一个数组的回文值，即为每对**对称的数** 不相等的数量。例：1,2,4,5,7 ，那么undefined1,7)对称，(2,5)$ 对称，并且这两个对都不相同，回文值为2。
即**只有不相同的数对会产生贡献**。 那么我们枚举数组a中的每个数对undefineda_i, a_j )$， 如果他们不相等， 我们就计算在多少个子序列中，这两个数是对称的。
很容易求出对于给定的undefinedi,j)他们之间有mid = j-i-1个数， 左边有le = i-1个数，右边有ri = n-j$ 个数。
分布如下：...i.....j.... 
我们得知，选择i,j中间的任意数不会破坏i和j对称。那么他们有2^{mid} 种方案。
对于两侧，我们必须选择同样多的数，才能保证i和j是对称的。假设我们选择了k个数。0 \le k \le min(le,ri) 
于是两侧的方案数为undefinedsum_{k=0}^{min(le,ri)} C_{le}^{k} C{ri}^k, 我们根据组合数的公式C_n^m = C_n^{n-m}，就可以将式子变为\sum_{k=0}^{min(le,ri)} C_{le}^{le-k} C_{ri}^k,那么根据**范德蒙恒等式** ， 方案数即为C_{le+ri}^{le},  因此对于这个数对(i,j)，它的贡献为2^{mid} * C_{le+ri}^{le}$ 
注：范德蒙恒等式如下：C_{n+m}^k = \sum_{t=0}^{k} C_n^t C_m^{k-t} , 解释为：有两个盒子，分别装有n个球和m个球 , 从中一共选择k个球（C_{n+m}^k） 等价于， 从第一个盒子中选择t个球C_n^t，从另一个盒子中选择k-t个球 C_m^{k-t} 。枚举每个t \in [0,k] 将方案数相加。
代码#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef pair&lt;int,int&gt; PII;int a[2005];int fac[2005];int ifac[2005];const int mod = 1e9+7;int qpow(int x,int n)&#123;    int ans = 1;    while(n)&#123;        if(n&amp;1) ans = ans * x % mod;        x = x * x % mod;        n &gt;&gt;= 1;    &#125;    return ans;&#125;int inv(int x)&#123;    return qpow(x,mod-2);&#125;int C(int n,int m)&#123;    if(m == 0 || n == m) return 1;    return fac[n] * ifac[n-m] % mod * ifac[m] % mod;&#125;void solve()&#123;    fac[0] = 1;    for(int i = 1;i&lt;=2000;i++) fac[i] = fac[i-1] * i % mod;    for(int i = 1;i&lt;=2000;i++) ifac[i] = inv(fac[i]);    int n;    cin&gt;&gt;n;    for(int i = 1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];    &#125;    int ans = 0;    for(int i = 1;i&lt;=n;i++)&#123;        for(int j = i+1;j&lt;=n;j++)&#123;            int l = i-1,m = (j-i-1),r=(n-j);            int sum = 0;            int mn = min(l,r);            ans = (ans + (a[i]!=a[j])*qpow(2,m)*(C(l+r,l))%mod)%mod;        &#125;    &#125;    cout&lt;&lt;ans;&#125;signed main()&#123;    int T = 1;    // cin&gt;&gt;T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>小白月赛 76</title>
    <url>/611f7aaa17d8/</url>
    <content><![CDATA[牛客小白月赛76 https://ac.nowcoder.com/acm/contest/60393
F. Kevin的矩阵1.题意给出n个数字的数字序列组成一个矩阵，m表示矩阵初始的列数，这n个数从左至右从上至下排列在矩阵中。要求进行若干次操作，使得矩阵的某一列的值全部为k可以执行的操作有:1.将矩阵的列数加1或者减12.改变矩阵中某个数的值一共有t组数据，并且保证所有数据中的n的和小于2e5
2.思路不论数据怎样，每组样例中所进行的操作数都不多于2 次操作1.初始的列数m小于 ,那么可以花费至多 – m次 操作将列数变为 ，然后花费至多 + 1 次操作改变某一列上面的值来保证这一列的值全部为k。假设m为最糟糕的情况，即m = 1，那么总共最多需要 2 * 次操作。2.初始的列数m大于 那么直接将某一列中的所有不为k的数都变为k。最多花费  次操作表示即可符合要求，因为m  所以，所以总操作数永远小于 2 *因此可以只对列数 [m – , m+]的区域进行遍历。(如果列数在这个范围之外,那么进行列数变换的操作花费已经大于最糟糕的情况了)
3.代码实现#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int INF = 0x3f3f3f3f;int a[200010];int main()&#123;    int t;    cin&gt;&gt;t;    int n,m,k;    while(t--)&#123;        int ans = INF;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int i = 1;i&lt;=n;i++)&#123;            scanf(&quot;%d&quot;,&amp;a[i]);        &#125;        int l = m - 2 * sqrt(n) - 5;        l = max(l,1);        int r = m + 2 * sqrt(n) + 5;        r = min(n,r);        for(int c = l;c&lt;=r;c++)&#123;            for(int i = 1;i&lt;=c;i++)&#123;                int num = a[i];                int cnt = abs(m - c);                for(int j = i;j &lt;= n;j+=c)&#123;                    if(a[j] != k)&#123;                        cnt++;                    &#125;                &#125;                ans = min(ans,cnt);            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;    return 0;&#125;
G.Kevin逛超市1.题意在n个物品中有1个是“有问题的”，为了找到这个物品，依次循环进行以下操作:选出这些物品当中的前 (n+1)/2 个数进行一次检测，如果检测到了“目标物品”，就选择这组物品重复操作，如果没有检测到，就选择另外的 n/2 个物品重复操作直到待检测的物品只有一个并且经过检测后确认该物品是“有问题的”，停止检测。可以得出总的期望次数 ,要求计算 mod 998244353 的结果。输入一个数t代表一共有t组样例，每组样例输入一个数n(t &lt;= 2* n&lt;=)输出每组样例的期望次数每组样例输出一个数代表结果
2.思路
期望dp，容易得出dp[i] = 1 + dp[i/2] + dp[(i+1)/2] 这样可以通过dfs来在logn的规模下进行求解。
通过map记录已经搜索的数据，实现记忆化搜索
需要特判dp[1]和dp[2] (dp[1]需要特判自不必多说，dp[2]需要特判在于按照题目规则 dp[2] = 而按照递归方程得出的dp[2] = 1 + dp[1] + dp[1] = 2不符合题意)

3.代码#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 998244353;unordered_map&lt;int, int&gt; mp;int qp(int a, int k)//快速幂 quick pow&#123;    int res = 1;    while (k)    &#123;        if (k &amp; 1) res = (LL) res * a % mod;        a = (LL) a * a % mod;        k &gt;&gt;= 1;    &#125;     return res;&#125; int dfs(int l, int r)&#123;    int len = r - l + 1, mid = l + r &gt;&gt; 1;    if (len == 1) return 1;    if (mp[len] != 0) return mp[len];     int &amp;val = mp[len];    if (mid - l + 1 == 1) val = dfs(l, mid);    else val = dfs(l, mid) + mid - l + 1;    val %= mod;    val = (val + dfs(mid + 1, r)) % mod;    val = (val + r - mid) % mod;    return val;&#125; void solve()&#123;    int n;    cin &gt;&gt; n;    cout &lt;&lt; (LL)dfs(1, n) * qp(n, mod - 2) % mod &lt;&lt; &quot;\n&quot;;&#125; int main()&#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);     int T;    cin &gt;&gt; T;     while (T -- ) solve();     return 0;&#125;
4.节时本题对时间要求不严格，但如果需要节时，可以考虑如下：使用二维数组mp[70][2]来代替map进行记录，其中mp[i][j]中的i代表进行第i次二分后的两个数，j如果为0就是较小者，为1就是较大者
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>电子扫盲</title>
    <url>/0ed69ce9ed7c/</url>
    <content><![CDATA[电子扫盲课文件后缀打开显示后缀可能你想写一个cpp代码，然后创建了一个文本文件叫做code.cpp , 那么实际上你创建的是code.cpp.txt  ,  他本质上还是一个txt文件。
有时候我们需要更改文件后缀，这时候我们就必须打开文件浏览器的显示后缀的功能了（默认是关闭的）
改后缀会不会出问题？改后缀只是更改了这个文件的标签，并没有更改内部的内容。
**谨慎处理不同文件类型之间的后缀相互转换！**

文本文件: txt、md、c、cpp、py等（注意docx文件并不是文本文件！）
图片： jpg、gif、png
等等等

**不要把doc文件转换为txt文件！！** 
jpg和png相互转换并不会转换文件格式，将一个jpg文件转为png文件再用软件打开，软件识别的不是png后缀而是图片文件内部的文件头。
电脑出现小问题问问AIAI还是太强大了orz
把你遇到的问题交给AI解决，尝试他给出的一系列方法。
*题外话：如果你的电脑是联想的，我感觉联想电脑管家中的人工客服挺好用的。*
重启大法重启解决95%的问题！如果电脑已经变的无法动弹，就长按电源键关机重启。
重装系统重装系统解决99.9%的问题！重装系统认准[官方系统](https://www.microsoft.com/zh-cn/software-download/windows11)
**谨防第三方系统植入病毒/流氓软件** (前些天我就在电脑维修店遭殃了)
如何获取网上的资源浏览器安装软件一定要认准官网！
浏览器推荐使用带插件的，能个性化浏览器的功能（chrome、edge、firefox）

百度搜索等国内搜索引擎
  门槛很低
  广告太多了！！！
  百度百科/百度翻译/百度AI 占了整个页面的绝大部分，很烦人呐
  推荐一款去广告插件 [ADGUARD](https://github.com/AdguardTeam/AdguardFilters) （降低你进入“盗版”官网的可能性）

google搜索/yandex
  门槛有点高，需要一些手段。
  绝大部分的搜素结果都很符合需求。
  很大程度减少


deepseek有些问题直接问deepseek也是一种很好的方案。
githubhttps://github.com/
github上不只有代码，还有很多有趣好玩的项目/软件/资源。
你可能需要一些手段来高速访问github。
解决代码报错大语言模型deepseek讲明自己现在的情况（如使用的系统是windows，代码语言是python等等）
将报错内容直接粘贴给AI，一般他会给你一些比较常见的解决办法。
浏览器直接搜这里就最好不要扯东扯西，直接把报错内容粘贴过去搜索。
大概率你会找到解决相同报错的博客（博客园、CSDN），或者stack overflow。
然后只需要照着做就好了。
压缩包别人发来的安装包/文件可能是压缩包格式的，解压之后再打开内部文件！
7zip压缩
windows自带了压缩功能，但是**奇慢无比**啊啊！！！（单线程导致的）

有些压缩包使用windows自带的解压缩会**出现错误**的情况TAT。

**不能分卷压缩**（百度网盘非会员上传单个文件最大1G）

**不能加密**压缩 / 不能解压缩带密码的压缩包

痛，太痛辣！！！
这里推荐**开源免费软件** [7zip](https://www.7-zip.org/) 
**安装包仅1.6MB**
7zip解决上面所有问题
双击安装包，等待安装完毕。选择要压缩/解压的文件，右键，查看更多选项，选择7zip
rar只有[winrar]( https://www.win-rar.com/)软件可以生成`.rar`后缀的rar压缩包。
但是几乎所有的压缩软件都可以解压缩rar压缩包。
**非必要不选择winrar**（1.自带广告的很烦人 2. 很丑）
软件相关Microsoft Store安装微软商店中也有一部分软件，方便快捷，可以避免遇到非官方软件。
软件商店的网络时好时坏的。
浏览器搜索官网安装**安装软件一定认准官网！！！**
安装时一定注意安装的位置， 尽量避免安装在系统盘（太容易满C盘了）
注意一定不要安装在C/D盘根目录。（一片混乱）
推荐对每个软件在D盘新建一个文件夹作为软件的存储位置
不要随意拖动软件文件不要把安装软件产生的一系列文件/文件夹随意拖动位置，尤其**不要把exe文件直接拖到桌面**。    
正确方法是：右键 -&gt;更多选项-&gt;发送到-&gt;发送到桌面快捷方式
添加环境变量可能你安装时没有勾选添加到环境变量（或者根本没有这个选项）
那么这时候你需要自己配置环境变量
设置-&gt;在设置中搜索环境变量-&gt;点击环境变量-&gt;将C/python软件的exe文件所在的文件夹加入到PATH中-&gt;点击确定保存设置。
卸载软件在设置-&gt;应用中找到对应软件，然后卸载。
或者在软件的文件中找到类似uninstall.exe 名称的程序，双击运行卸载程序。
**尽量不要直接删软件文件夹来“卸载软件”**
C盘满了更改QQ/微信存储位置QQ ：设置-&gt;存储管理
微信：设置-&gt;文件管理
存储感知设置-&gt;搜索存储感知，可以按照类别删去一些内容。
第三方软件磁盘存储分析工具[wiztree](https://diskanalyzer.com/)  ，然后根据需要删除占比大的无用文件。
[dism++](https://github.com/Chuyu-Team/Dism-Multi-language)或许可以通过删除一些非必须的系统文件，节省空间。
网上买个一天的wps会员，然后让wps帮你整C盘。（本人没试过）
磁盘重新分区注意重新分区可能会清空磁盘中所有的内容，对C盘重新分区可以在重装系统的时候选择。
加装硬盘升级硬盘容量，从根源解决问题。
电脑防护软件Microsoft defender是否需要 留着也行，但是有时候可能会很倔强地把你刚下载的文件认定为病毒，然后不经同意地删掉这个文件。
火绒还是360 我的选择是都不要，不进入病毒网站，不下载病毒文件的话问题不大，甚至还经常出现误报风险的问题。
如果担心电脑中病毒，也可以下载其中一个来防护，使用360请自己找去掉360弹窗的办法。下载360认准官网！
PDFpdf格式的文件较稳定，不会因为打开的软件不同导致文章的格式出现错误。
pdf24 Toolshttps://tools.pdf24.org/zh/all-tools
集成了几乎所有常见功能的pdf处理网站。
SumatraPDFhttps://www.sumatrapdfreader.org/free-pdf-reader
一款免费、轻量化、干净整洁的PDF阅读器。
MarkDown编写文章常用的一种轻量化语言。markdown文件的后缀是md，可以直接通过将txt文件的后缀改为md来创建md文件。
一般博客文章都是使用markdown来编写。
可以将自己的学习笔记、软件配置记录、题解等编写为md然后分享到博客网站（CSDN等）*广告：我的csdn博客https://blog.csdn.net/qq_66608435*
typora官网https://typora.io/ 
查看、编辑md的实用软件。
**并不是免费的，但实在太好用了。**
（vscode也可以直接编辑查看md文件）
一些实用玩意带有一定主观倾向！
仅作为分享，并不是宣传，不对使用下面资源产生的影响负责！！！
打字练习https://dazidazi.com/
该网站会从最基础的放手方法开始教你一步一步提升打字速度。
也可以测试自己的打字速度。
游戏/视频画质增强屏幕如果支持HDR（特别亮），在设置-&gt;系统-&gt;屏幕-&gt;使用HDR中可以打开。
可以用显卡增强浏览器的视频，在设置-&gt;系统-&gt;屏幕-&gt;显示卡中添加你使用的浏览器。（增加画质、补帧很好用）
下面这两个第三方软件本人也没用过，谨慎使用
https://github.com/Blinue/Magpie
https://github.com/bloc97/Anime4K
浏览器翻译开源插件流畅阅读 https://fluent.thinkstu.com/

支持接入各种AI，自定义prompt等
快捷键很人性化
页面好看

LocalSend
手机和电脑不是同一个品牌，没办法便捷互传文件？
使用QQ/微信有时候会遇到网速慢、文件记录多备份一遍、超大文件无法分享的问题。
微信发送文本还会偷偷更改tab的格式。

使用开源软件LocalSendhttps://github.com/localsend/localsend
CS自学这里的CS是computer science的缩写，不是Counter-Strike！
https://csdiy.wiki/#cs61a
收集了CS各方向的好用课程、课后作业等
在线流程图https://excalidraw.com/

界面干净好看
资源存储在本地
功能比较全
支持多人协作

在线剪贴板*给别人发送代码，文本太长没办法直接QQ发送？*
*QQ发送两页屏幕太占地方？*
*发送代码文件又不方便手机查看？*
https://paste.nugine.xyz/
代码粘贴到这个网站，然后将生成的链接发给他！
AI翻译PDFhttps://github.com/Byaidu/PDFMathTranslate
一个开源项目，可以对英文的PDF全文翻译。支持接入API
直接使用官方的网站（但是限制PDF文件大小）
或者也可以根据流程自己本机部署/下载安装包。
dism++https://github.com/Chuyu-Team/Dism-Multi-language
一款管理系统文件/系统设置的工具
里面一些个性化的小设置或许很有用。
]]></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>电子扫盲</tag>
        <tag>讲座</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯python语法速通</title>
    <url>/689a26879a60/</url>
    <content><![CDATA[Python 语法**python代码有严格的缩进限制，不同的缩进代表了不同的含义，请不要随意缩进！！！**
变量类型python**不需要** 预先声明变量，并且没有显式的类型声明，python 代码最后**不需要加分号**
a = b = c = 1 # 把 a , b , c 都赋值为1d,e,f = 777 , 3.14159 , &quot;eeee&quot; # 把d赋值为777， e赋值为小数3.14159 , f赋值为字符串“eee&quot;
数字
​    数字类型的变量理论上可以存储无限大的数，但是会受限于计算机的运算速度。
str（字符串类型）
​        不论双引号&quot;ABC&quot;，还是单引号 ‘ABC’ ，代表的都是字符串（即使是&#39;a&#39; ，也是长度为一的字符串，而不是字符）
列表（list） 
​    列表使用**中括号**表示。
​    类似于C中的数组，能够存储一些数据，支持按下标找值。列表中可以存放任何类型，并且**单个列表可以存放多种类型**
a = [0,[1,2,2,5],[[1]] ]# a[0] = 0# a[1] = [1,2,2,5]### a[1][0] = 1 , a[1][3] = 5# a[2] = [[1]]# a[2][0][0] = 1### a[2][0][1] 下标越界!!! 
元组（tuple）
​    元组用小括号()表示
​    和列表类似，常用来函数返回多个值
tup = (111,222,&quot;abc&quot;) # tup是一个元组print(type(tup))# &lt;class &#x27;tuple&#x27;&gt;print(tup[1]) # 222def func():    name = &#x27;ttt&#x27;    age = 114    score = 514    return name,age,scoreprint(func())#(&#x27;ttt&#x27;, 114, 514)
元组同样可以使用下标来访问
集合（set）
​    集合中的元素无序，不重复。 
a = &#123;-1,3,-5,3,2,4,4,4&#125;print(a)#&#123;2, 3, 4, -5, -1&#125;
字典（dict）
​    字典，顾名思义，就是用来查找值的，每一项是一个**键值对**，我们通过键可以找到对应的值，每个键值对表示为 **key : value** .即一个冒号，左边是键，右边是值。
dic = &#123;&quot;mike&quot; : 1000, &quot;Lisa&quot; : 111 , 114 : 514&#125;
其中”mike”, “Lisa”,114是键， 1000，111，514 是对应的值。
假设dic是一个字典，使用dic.pop(“mike”) 来清除mike这个键值对。 使用dic[“aaa”] = “ttt”  来加入一个键值对。
如果我们要判断一个键值对是否存在，应该使用
dic = &#123;&quot;mike&quot; : 1000, &quot;Lisa&quot; : 111 , 114 : 514&#125;dic[222] = 456print(dic[222])print(dic.get(222))dic.pop(114)if(not dic.get(114)):    print(&quot;No!&quot;)
输入输出输入input输入使用input() 函数，input函数有以下几个特性：

会直接读取完一整行
读入后的数据以字符串的形式表示

a = input()print(type(a))# 输入## 123 456# 输出## &lt;class &#x27;str&#x27;&gt;
我们经常需要使用**强制类型转换来**变成其他形式的值
inum = int(input())
如果一行有多个整数需要输入怎么办？？？
# 输入# 1 2 3 4 5 6 7 8 99## 1.使用input输入一整行lst = input()# lst = &#x27;1 2 3 4 5 6 7 8 99&#x27;## 2.使用字符串的split()函数来将一个字符串分隔开(默认是遇到空格分隔)lst = input().split() # lst= [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;99&#x27;]## 3.使用map函数对列表的每一项进行int操作,此时lst是一个map类型lst = map(int,input().split()) #此时只可以对lst进行遍历，不可以进行下标访问## 4. 使用list强制转换为列表lst = list(map(int,input().split()))# list = [1, 2, 3, 4, 5, 6, 7, 8, 99]
输出格式化输出：
在字符串前加f,然后字符串内加大括号,{}
a = 55b = &quot;bbb&quot;print(f&quot;a is &#123;a&#125;, b is &#123;b&#125;&quot;)
确定小数位数用：
a = 55.00print(&quot;&#123;:.5f&#125;&quot;.format(a))# 保留5位小数
不想让print之后换行
print(&quot;abc&quot;,end=&quot; &quot;)print(&quot;bcd&quot;,end=&quot;&quot;)
判断判断和C中的判断基本一样，区别在于 C中的else if 要换成**elif**
//C codeint a = 77;if(a &lt; 60)&#123;    printf(&quot;Bad!\n&quot;);&#125;else if(a &lt; 80)&#123;    printf(&quot;Good!\n&quot;);&#125;else&#123;    printf(&quot;Perfect!&quot;);&#125;
#python codea = 77if a &lt; 60 :   print(&quot;Bad&quot;)#这里必须要缩进elif (a &lt; 80):    print(&quot;Good!&quot;)else:    print(&quot;Perfect!&quot;)#Tab键就是缩进
循环循环一般使用for和while循环：
for循环for循环用来遍历某个可枚举的类型（集合，列表，元组，字典，range等等）
先来看看range
#只有一个参数时range(n)表示从0 ~ n-1range(5) # 0 1 2 3 4# 有两个参数时range(l,r)表示区间[l,r)# 区间是左闭右开的range(5,12) # 5 6 7 8 9 10 11# 有三个参数时range(l,r,step),表示从l到r(取不到r),步长为steprange(3,8,1) # 3, 4 5 6 7range(3,8,2) # 3 5 7range(9,3,-2) # 9 7 5 
因此我们的for循环应该这么用：for i in range(8):    print(i)# 0 ~ 7lst = [5,7,&quot;bcc&quot;,123,677.001]for i in lst:	print(i) #依次输出每一项
while循环while循环和C中的用法一样，不再赘述
特殊性质Python中的循环可以加**else**，表示循环正常结束时进行的操作：（如果使用break中断循环就不会进行else中的操作）
for i in range(5):    print(i)else :    print(777)
运算和C相同的运算就不说了，下面说一下不同：

整数除法//
a,b = 5,2print(a//b) #5 // 2 = 2

求次方 **
a,b = 5,3print(a**b)#5 * 5 * 5 = 125

合并数据类型 + *
# strstr1,str2 = &quot;AB&quot;,&quot;CD&quot;print(str1+str2)#ABCDprint(str1 * 3) #ABABAB# listlst1 = [1,2,3]lst2 = [3,4,5]print(lst1+lst2)#[1, 2, 3, 3, 4, 5]print(lst1*3)#[1, 2, 3, 1, 2, 3, 1, 2, 3]


一些小技巧（注意点）快读
使用input输入数据比较慢，有时候可能会导致超时，需要换成sys.stdin.readline()
import sys #引入sys库num = int(sys.stdin.readline())
[B2056 求整数的和与均值 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/B2056)
使用input耗时85ms
n = int(input())sum = 0for i in range(n):    num = int(input())    sum += numprint(&#x27;&#123;&#125; &#123;:.5f&#125;&#x27;.format(sum,sum/n))
使用readline耗时58ms
import sysn = int(sys.stdin.readline())sum = 0for i in range(n):    num = int(sys.stdin.readline())    sum += numprint(&#x27;&#123;&#125; &#123;:.5f&#125;&#x27;.format(sum,sum/n))


注意避免浅拷贝a1 = [1,2,3,4,5]b1 = a1a1[0] = 114514print(b1) # 114514,2,3,4,5## 此处由于b1是浅拷贝，导致对a1的修改也会影响b1a2 = [1,2,3,4,5]b2 = a2[:]c2 = a2.copy()a2[0] = 114514print(b2) # 1,2,3,4,5print(c2) # 1,2,3,4,5## 此处b2和c2都是深拷贝，改变a2不会影响b2和c2a3 = [[1,2],[3,4]]b3 = a3[:]c3 = a3.copy()a3[0][0] = 114514print(b3) # [[114514,2],[3,4]]print(c3) # [[114514,2],[3,4]]## 这里嵌套列表，导致即使使用了[:] 或者 copy(),但仍然是复制的原始的列表,所以会同步更改a4 = [[1,2],[3,4]]b4 = []for i in range(len(a4)):    tmp = []    for j in range(len(a4[i])):        tmp.append(a4[i][j])    b4.append(tmp)a4[0][0] = 114514print(b4) #[[1, 2], [3, 4]]## 在蓝桥杯中为了保险起见我们可以选择用循环来逐个复制元素
二维数组的定义：错误样例：
arr = [[0] * 100] * 50
此时当我们使用arr[5][2]， 修改第6行第3列这个元素时，会导致整个第3列都变成这个值（我也搞不懂为什么）
正确示范：
append函数用来向列表的末尾插入一个元素
arr = []for i in range(50):    arr.append([0] * 100)
快速幂python的pow函数内置了快速幂
[P1226 【模板】快速幂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1226)
C代码如下：
#include&lt;stdio.h&gt;#define int long longint quickpow(int x,int n,int p)&#123;    int ans = 1;    while(n)&#123;        if(n &amp; 1)             ans = ans * x % p;        x = x * x % p;        n &gt;&gt;= 1;    &#125;    return ans;&#125;signed main()&#123;    int a,b,p;    scanf(&quot;%lld %lld %lld&quot;,&amp;a,&amp;b,&amp;p);    printf(&quot;%lld^%lld mod %lld=%lld&quot;,a,b,p,quickpow(a,b,p));&#125;
python代码如下：
a,b,p = list(map(int,input().split()))print(f&quot;&#123;a&#125;^&#123;b&#125; mod &#123;p&#125;=&#123;pow(a,b,p)&#125;&quot;)
高精度​    python内置了高精度运算
[P1601 A+B Problem（高精） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1601)
a,b = int(input()),int(input())print(a+b)
[P1480 A/B Problem - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1480)
a,b = int(input()),int(input())print(a//b)
自测代码用时python蓝桥杯中一般会给10s的时间，但我们如何知道我们的代码大概用了多少时间？
import timetic = time.time()a = 0for i in range(int(1e8)):    a += itok = time.time()print(tok-tic) # 8.40402865409851
我们在代码的最上面和最下面分别记录当前的时间，然后输出二者的差。
在我自己的电脑cpu:R6800H上运行了8.4s,  而一般测评机只会更差，于是我们可以大致估算出python一秒能够支持大概10^7 次算术运算。
datetime可能不会再出日历题了，但是还是放在这边叭。
# date+time 既有日期也有时间from datetime import datetimedate_time_1 = datetime(2025,3,29,12,5,13) # 2025年3月29日12时5分13秒date_time_2 = datetime(2026,6,1,17,5,20) # 2026年6月1日12时5分20秒delta = date_time_2 - date_time_1 # 代表两个时间之间的差值print(delta.days) # 天数 429天print(delta.seconds) # 秒数 18007秒print(delta.total_seconds()) #37083607.0秒
# date只有日期from datetime import datedate1 = date(2020, 2, 28) # 定义一个datedate2 = date(2020, 3, 1)delta = date2 - date1 # 计算两天的差值print(delta.days) # 2天# 示例：# 求从1900年1月1日开始到y年m月d日，有多少个周日？def cal_sunday(y,m,d):    dat1 = date(1900,1,1)    dat2 = date(y,m,d)    sunday_cnt = 0    while (dat1 &lt; dat2):        if (dat1.weekday() == 6):            sunday_cnt += 1        dat1 += date.resolution # 日期加1天    print(sunday_cnt)cal_sunday(2025,4,8) # 6536个周日
自定义排序class Node:    def __init__(self, x, y):        self.x = x        self.y = y    def __lt__(self, other):        if self.x == other.x:            return self.y &lt; other.y        return self.x &lt; other.x    def __repr__(self):        return f&quot;Node(x=&#123;self.x&#125;, y=&#123;self.y&#125;)&quot;# 示例使用nodes = [    Node(1, 2),    Node(1, 1),    Node(2, 3),    Node(2, 1),    Node(3, 4)]# 排序节点nodes.sort()# 打印排序后的节点# for node in nodes:#     print(node)# 自定义排序方法的优先队列：from queue import PriorityQueuepq = PriorityQueue()pq.put(Node(1, 5))pq.put(Node(1, 1))pq.put(Node(4, 4))while (not pq.empty()):    print(pq.get())
数据结构C++转python此处通过一些“等价”的代码来介绍一些C++和python共同的数据结构。
vectorundefinedto$ list//cpp  versionvector&lt;int&gt; vec(114,514);vec.push_back(1919810);cout&lt;&lt;vec.back()&lt;&lt;endl;vec.clear();cout&lt;&lt; vec.size()&lt;&lt;endl;
# python versiona = [514] * 114a.append(1919810)print(a[-1])a.clear()print(len(a))
map undefinedto$ dict注意：

python中的dict在遍历时并不会保持有序
python中的dict使用dic[key]访问值，在遇到不存在的key会直接报错。


collections库中包含一个OrderedDict,但这里的ordered指代的”有序“并非像C++那样键的有序。而是保持插入顺序，因此在算法竞赛中通常用不到OrderedDict。

// cpp versionmap&lt;int,int&gt; mp;mp[114] = 514;// 选取某个元素cout&lt;&lt;mp[2]&lt;&lt;endl; // 访问未定义的键会自动创建然后返回0.mp.erase(2);// 删除元素mp.clear();// 清空for(pair&lt;int,int&gt; pii : mp)&#123;// 枚举元素    int x = pii.first;    int y = pii.second;    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#125;
# python versiondic = dict() # 或者 dic=&#123;&#125;dic[114] = 514 # 选取某个元素# print(dic[2]) # 注意！访问未定义的键会报错 KeyError: 2print(dic.get(2,0)) # 使用get函数访问,并设置默认值为0 ,注意这样并不会将2加入到dict中，需要手动加入if(dic.get(2,None) == None): # 判断键是否存在    dic[2] = 0    print(&quot;dic[2] is not exist&quot;)dic.pop(2) # 删除元素dic.clear()# 清空dic[6] = 1dic[5] = 2dic[4] = 3for x,y in dic.items(): # 枚举元素    print(x,y)
也可以使用collections中的defaultDict，这个数据结构支持为字典定义默认值，从而避免访问不存在的key而报错。
default_dic = defaultdict(lambda:-1) # lambda是一个工厂函数，返回-1print(default_dic[&#x27;a&#x27;]) # 输出-1dic = dict()print(dic[&#x27;a&#x27;]) # 报错KeyError: &#x27;a&#x27;
set undefinedto$ set注意python中的set是无序的。可以使用sorted来将set变为有序的list。
//cpp versionset&lt;int&gt; st = &#123;1,1,4,5,1,4&#125;; //初始化集合st.insert(5); // 插入元素st.erase(5); // 删除元素cout &lt;&lt; st.count(5)&lt;&lt;endl; //  查找某个元素是否存在cout &lt;&lt; *st.begin()&lt;&lt;endl; // 最小的元素for(int x : st)&#123; // 枚举元素    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;&#125;
# python versionst = set([1,1,4,5,1,4]) #  注意st = &#123;&#125; 是字典不是集合st.add(5) # 插入元素st.remove(5) # 删除元素print(5 in st) #  查找某个元素是否存在for x in st: # 枚举元素，并不会保证有序    print(x,end = &#x27; &#x27;) # python中的set是无序的。
queue undefinedto$ Queue注意python中的获取队首元素 get方法，会将队首弹出。
而C++中获取首元素que.front()并不会弹出该元素。
虽然queue理论上只能访问队首元素，但是在python的Queue中我们可以直接遍历查看queue的每一个元素的值。

注意Queue的大小写

// cpp versionqueue&lt;int&gt; que;que.push(1);que.push(1);que.push(4); // 推入元素que.push(5);que.push(1);que.push(4);cout&lt;&lt; que.front()&lt;&lt;&#x27; &#x27;&lt;&lt; que.back()&lt;&lt;endl; // 首尾元素que.pop(); // 队首出队cout &lt;&lt; que.size(); // 队列长度
# python versionfrom queue import Queue# 创建一个队列que = Queue()que.put(1);que.put(1);que.put(4)# 推入元素que.put(5);que.put(1);que.put(4)print(que.queue[0],que.queue[-1]) # 首尾元素que.get() # 队首出队(返回队首元素并出队)print(que.qsize()) # 队列长度for x in que.queue: # 遍历队列    print(x,end=&#x27; &#x27;)
priority_queue undefinedto$ PriorityQueue

注意python中的Priority Queue默认是小根堆（我们可以通过定义一个类，然后重写它的__lt__ 方法,来实现其他排序方式的堆，详见本文之前的“自定义排序”小节。）
注意PriorityQueue的大小写


// cpp versionpriority_queue&lt;int&gt; pq;pq.push(1); pq.push(1); pq.push(4);pq.push(5); pq.push(1); pq.push(4); // 插入元素pq.pop(); // 移出堆顶元素cout&lt;&lt; pq.top(); // 获取堆顶元素
# python versionfrom queue import PriorityQueuepq = PriorityQueue()pq.put(1);pq.put(1);pq.put(4)pq.put(5);pq.put(1);pq.put(4) # 插入元素pq.queue[0] # 选择堆顶元素(不移出)top = pq.get() # 移出并返回堆顶元素
deque undefinedto$ deque和queue类似，虽然deque只能从两端进出元素，但我们仍然可以直接枚举整个队列。
// C++ versiondeque&lt;int&gt; dq;dq.push_back(1);dq.push_back(2);dq.push_back(3); // 从右端添加元素dq.push_front(0); // 从左端添加元素int right_element = dq.back(); // 从右端移除元素，并打印被移除的元素dq.pop_back();cout &lt;&lt; right_element &lt;&lt; endl;  // 输出: 3int left_element = dq.front(); // 从左端移除元素，并打印被移除的元素dq.pop_front();cout &lt;&lt; left_element &lt;&lt; endl;  // 输出: 0for (const auto&amp; x : dq) &#123; // 打印双端队列    cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;  // 输出: 1 2int front_element = dq.front();// 获取队首元素（左端）cout &lt;&lt; front_element &lt;&lt; endl;  // 输出: 1int back_element = dq.back();// 获取队尾元素（右端）cout &lt;&lt; back_element &lt;&lt; endl;  // 输出: 2int queue_size = dq.size();// 获取双端队列的长度cout &lt;&lt; queue_size &lt;&lt; endl;  // 输出: 2dq.insert(dq.end(), &#123;3, 4, 5&#125;);// 从右端扩展多个元素for (const auto&amp; x : dq) &#123;    cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;  // 输出: 1 2 3 4 5dq.insert(dq.begin(), &#123;0, -1&#125;);// 从左端扩展多个元素for (const auto&amp; x : dq) &#123;    cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;  // 输出: -1 0 1 2 3 4 5for (const auto&amp; x : dq) &#123;// 迭代双端队列中的元素    cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;  // 输出: -1 0 1 2 3 4 5
# python versionfrom collections import dequedq = deque() # 创建一个双端队列dq.append(1) ;dq.append(2);dq.append(3) # 从右端添加元素dq.appendleft(0) # 从左端添加元素right_element = dq.pop() # 从右端移除元素,注意该函数返回了被移除的元素。print(right_element)  # 输出: 3left_element = dq.popleft() # 从左端移除元素print(left_element)  # 输出: 0print(dq)  # 输出: deque([1, 2])front_element = dq[0] # 获取队首元素（左端）print(front_element)  # 输出: 1back_element = dq[-1] # 获取队尾元素（右端）print(back_element)  # 输出: 2queue_size = len(dq) # 获取双端队列的长度print(queue_size)  # 输出: 2dq.extend([3, 4, 5]) # 从右端扩展多个元素print(dq)  # 输出: deque([1, 2, 3, 4, 5])dq.extendleft([0, -1]) # 从左端扩展多个元素print(dq)  # 输出: deque([-1, 0, 1, 2, 3, 4, 5])for x in dq: # 迭代双端队列中的元素    print(x,end = &quot; &quot;)
stack undefinedto$ list推荐用list来模拟，(类似于C++中的用vector模拟栈)。list的用法详见vector  undefinedto$ list 篇
]]></content>
      <categories>
        <category>讲座</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>蓝桥杯</tag>
        <tag>讲座</tag>
      </tags>
  </entry>
</search>
