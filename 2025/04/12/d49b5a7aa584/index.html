<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2025蓝桥杯PythonA组省赛题解 | Little_sk</title><meta name="author" content="Little_sk"><meta name="copyright" content="Little_sk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2025蓝桥杯PythonA组省赛题解 一定注意，由于在编写本题解时还没有在线题目。所以： 本题解仅供参考，在题意、思路、code上都可能发生错误！  A. RGB三色题意我们可以用三个0~255之间的数(r,g,b)来表示一个颜色，如(0,0,255) 表示蓝色。 那么请问所有的颜色中，有多少种颜色是“偏蓝色” 我们定义当且仅当$b &gt; r $ 并且$b &gt; g$ ，$(r,g,b)">
<meta property="og:type" content="article">
<meta property="og:title" content="2025蓝桥杯PythonA组省赛题解">
<meta property="og:url" content="https://lsk404.github.io/2025/04/12/d49b5a7aa584/index.html">
<meta property="og:site_name" content="Little_sk">
<meta property="og:description" content="2025蓝桥杯PythonA组省赛题解 一定注意，由于在编写本题解时还没有在线题目。所以： 本题解仅供参考，在题意、思路、code上都可能发生错误！  A. RGB三色题意我们可以用三个0~255之间的数(r,g,b)来表示一个颜色，如(0,0,255) 表示蓝色。 那么请问所有的颜色中，有多少种颜色是“偏蓝色” 我们定义当且仅当$b &gt; r $ 并且$b &gt; g$ ，$(r,g,b)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://lsk404.github.io/img/avator.jpg">
<meta property="article:published_time" content="2025-04-12T12:28:00.000Z">
<meta property="article:modified_time" content="2025-04-16T09:45:15.510Z">
<meta property="article:author" content="Little_sk">
<meta property="article:tag" content="题解">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lsk404.github.io/img/avator.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2025蓝桥杯PythonA组省赛题解",
  "url": "https://lsk404.github.io/2025/04/12/d49b5a7aa584/",
  "image": "https://lsk404.github.io/img/avator.jpg",
  "datePublished": "2025-04-12T12:28:00.000Z",
  "dateModified": "2025-04-16T09:45:15.510Z",
  "author": [
    {
      "@type": "Person",
      "name": "Little_sk",
      "url": "https://lsk404.github.io/lsk404.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://lsk404.github.io/2025/04/12/d49b5a7aa584/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-745T2DDK98"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-745T2DDK98')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-745T2DDK98', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":150,"languages":{"author":"Author: Little_sk","link":"Link: ","source":"Source: Little_sk","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2025蓝桥杯PythonA组省赛题解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(img/bg3.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" alt="Logo"></a><a class="nav-page-title" href="/"><span class="site-name">2025蓝桥杯PythonA组省赛题解</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">2025蓝桥杯PythonA组省赛题解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-12T12:28:00.000Z" title="Created 2025-04-12 20:28:00">2025-04-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-16T09:45:15.510Z" title="Updated 2025-04-16 17:45:15">2025-04-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A2%98%E8%A7%A3/">题解</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">5.5k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="2025蓝桥杯PythonA组省赛题解"><a href="#2025蓝桥杯PythonA组省赛题解" class="headerlink" title="2025蓝桥杯PythonA组省赛题解"></a>2025蓝桥杯PythonA组省赛题解</h1><blockquote>
<p>一定注意，由于在编写本题解时还没有在线题目。所以：</p>
<p>本题解仅供参考，在题意、思路、code上都可能发生错误！</p>
</blockquote>
<h2 id="A-RGB三色"><a href="#A-RGB三色" class="headerlink" title="A. RGB三色"></a>A. RGB三色</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>我们可以用三个0~255之间的数<code>(r,g,b)</code>来表示一个颜色，如<code>(0,0,255)</code> 表示蓝色。</p>
<p>那么请问所有的颜色中，有多少种颜色是“偏蓝色”</p>
<p>我们定义当且仅当$b &gt; r $ 并且$b &gt; g$ ，$(r,g,b)$ 是偏蓝色的。</p>
<h3 id="思路-amp-代码"><a href="#思路-amp-代码" class="headerlink" title="思路 &amp; 代码"></a>思路 &amp; 代码</h3><p>直接暴力枚举！ 复杂度$256^3 = 16777216$ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span>(b &gt; g <span class="keyword">and</span> b &gt; r):</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(ans) <span class="comment"># 5559680</span></span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<p>使用公式计算：</p>
<p>如果我们给定b，那么r和g可以取$[0,b-1]$ 中的任何一个值，有$b^2$ 种可能。于是我们就有如下公式：</p>
<script type="math/tex; mode=display">
ans = \underset{b = 1}{\overset{255}{\sum}} b^2</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    ans += b * b</span><br><span class="line"><span class="built_in">print</span>(ans) <span class="comment"># 5559680</span></span><br></pre></td></tr></table></figure>
<h2 id="B-IPv6的缩写长度"><a href="#B-IPv6的缩写长度" class="headerlink" title="B. IPv6的缩写长度"></a>B. IPv6的缩写长度</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出IPv6的缩写规则：</p>
<p>IPv6由8段组成，每段4个16进制数。</p>
<p>省略规则如下：</p>
<ol>
<li>对于一段的四个十六进制数，前导零可以省略。</li>
<li>如果一段中只包含零，必须保留一个零。</li>
<li>可以将一段连续的0省略，用<code>::</code> 替代，但是整个IPv6只能缩写一段。</li>
</ol>
<p>下面给出一些例子</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>缩写前</th>
<th>缩写后</th>
</tr>
</thead>
<tbody>
<tr>
<td>2001:0db8:0000:0000:0000:ff00:0042:8329</td>
<td>2001:db8::ff00:42:8329</td>
</tr>
<tr>
<td>0000:0000:0000:0000:0000:0000:0000:0001</td>
<td>::1</td>
</tr>
<tr>
<td>0000:0000:0000:0000:0000:0000:0000:0000</td>
<td>::</td>
</tr>
<tr>
<td>ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</td>
<td>ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</td>
</tr>
<tr>
<td>2001:0db8:85a3:0000:0000:8a2e:0370:7334</td>
<td>2001:db8:85a3::8a2e:370:7334</td>
</tr>
</tbody>
</table>
</div>
<p>那么请问：</p>
<p>所有的IPv6地址，把他们的长度加起来是多少？</p>
<p>由于答案太大，我们对$10^9+7$  取模。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接枚举肯定是不可以的。</p>
<p>我们考虑按段分类枚举：</p>
<p>对于八个段中的每一个段，我们分为以下五种情况：</p>
<ol>
<li>这一段是0 ,共<code>1</code>个数符合情况</li>
<li>这一段是一位数，即三位前导零，共<code>(000f - 0 = 15)</code>个数符合情况 </li>
<li>这一段是两位数，即两位前导零，共<code>`(00ff - 000f = 15*16)</code>个数符合情况 </li>
<li>这一段是三位数，即一位前导零，共<code>(0fff - 00ff = 15*16*16)</code> 个数符合情况 </li>
<li>这一段是四位数，没有前导零，共<code>(ffff - 0fff = 15*16*16*16)</code> 个数符合情况 </li>
</ol>
<p>当我们固定了八段所有的情况后， 他的长度就可以求出来了，于是我们对每段枚举这五种情况。循环的时间复杂度是$5^8$ 。</p>
<p>之后我们假设这个IPv6地址如下：<code>a0:a1:a2:a3:a4:a5:a6:a7</code> </p>
<p>那么我们就可以计算得到在缩写前的总长度是$length_{pre} = (l_0+l_1+l_2+…+l_7) + 7$ (七个冒号) (这里$a_i = 0$时$l_i=1$ ,其他时候$l_i = a_i$ )</p>
<p>在缩写时我们对每段连续0区间进行计算，得到他的缩小程度。我们取其中的最大值$length_{omit}$即可。</p>
<p>如何计算？假设我们得到了一个区间$[l,r]$</p>
<ol>
<li>如果$l = 0 \text{ and }r = 7$ , $length_{omit} = 13$</li>
<li>若不满足第一项：如果$l = 0 \text{ or } r = 7$ , $length_{omit} = 2 * (r - l + 1) - 2$</li>
<li>如果不满足第一、二项；$length_{omit} = 2 * (r - l + 1) - 1$</li>
</ol>
<p>这样我们就计算出来这个地址的长度，那么这个地址的总数则是每段所包含的数的数量，把他们乘到一起。$cnt<em>{all} = \Pi</em>{i = 0}^7 cnt(a_i)$</p>
<p>那么整个这个类型的IPv6的地址总长度，当然就是$cnt<em>{all} * (length</em>{pre} - length_{omit})$ 了。</p>
<blockquote>
<p>注：我们枚举八个段，可以使用八重循环（太丑陋！）</p>
<p>也可以直接枚举一个“五进制数”，从0 到$5^8$ , 然后对他进行进制拆分</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote>
<p>我们在调试时可以把N设置的比较小，然后输出所有的情况来查看计算是否有问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">8</span></span><br><span class="line">ans = <span class="number">2</span> <span class="comment"># 这里直接把全零的情况提取出来，后面的range从1开始</span></span><br><span class="line">cnt = [<span class="number">1</span>,<span class="number">15</span>,<span class="number">15</span>*<span class="number">16</span>,<span class="number">15</span>*<span class="number">16</span>*<span class="number">16</span>,<span class="number">15</span>*<span class="number">16</span>*<span class="number">16</span>*<span class="number">16</span>]</span><br><span class="line">MOD = <span class="built_in">int</span>(<span class="number">1e9</span>+<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>**N):</span><br><span class="line">    a = [] <span class="comment"># a[i]表示第i位是几</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        a.append(x%<span class="number">5</span>)</span><br><span class="line">        x //= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接下来找连续的0串</span></span><br><span class="line">    left = -<span class="number">1</span></span><br><span class="line">    length_omit = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="comment"># 这里枚举的区间是(left,right],区间长度是right-left</span></span><br><span class="line">        <span class="keyword">if</span>(a[right] == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span>(left == -<span class="number">1</span> <span class="keyword">or</span> right == N-<span class="number">1</span>):</span><br><span class="line">                length_omit = <span class="built_in">max</span>(length_omit,<span class="number">2</span> *(right-left)-<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                length_omit = <span class="built_in">max</span>(length_omit,<span class="number">2</span> *(right-left)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            left = right</span><br><span class="line">    length_pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">0</span>):</span><br><span class="line">            length_pre += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            length_pre += a[i]</span><br><span class="line">    length_pre += (N-<span class="number">1</span>)</span><br><span class="line">    cnt_all = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        cnt_all = cnt_all * cnt[a[i]] % MOD</span><br><span class="line">    <span class="comment"># print(a)</span></span><br><span class="line">    <span class="comment"># print(length_pre,length_omit)</span></span><br><span class="line">    ans += cnt_all * (length_pre - length_omit) % MOD</span><br><span class="line">    ans %= MOD</span><br><span class="line"><span class="built_in">print</span>(ans) <span class="comment"># 905307083</span></span><br></pre></td></tr></table></figure>
<h2 id="C-2025"><a href="#C-2025" class="headerlink" title="C. 2025"></a>C. 2025</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出$n,w$, 求出n行m列的2025矩阵：</p>
<ol>
<li><p>第1行是2025的不断重复</p>
</li>
<li><p>从第2行开始，每行都是上一行左移一位</p>
</li>
</ol>
<p>当<code>n = 4,m = 10</code>时如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2025202520</span><br><span class="line">0252025202</span><br><span class="line">2520252025</span><br><span class="line">5202520252</span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们发现，左下-右上对角线上的元素是相同的。他们满足$j + i = c$ ，即列和行的和是定值。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">Input = sys.stdin.readline</span><br><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,Input().split())</span><br><span class="line"></span><br><span class="line">ch = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="built_in">print</span>(ch[(i+j)%<span class="number">4</span>],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="D-1到n的二进制拼接"><a href="#D-1到n的二进制拼接" class="headerlink" title="D 1到n的二进制拼接"></a>D 1到n的二进制拼接</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>把1到n这些数，转换为二进制，然后进行拼接操作。</p>
<p>问怎样拼接能使得数值尽可能大？ 把这个01串再转换回十进制。</p>
<p>例如：n = 3时，$1,2,3$ 的二进制分别为$1,10,11$ ，进行拼接后最大为<code>11110</code> ,转换为十进制为30</p>
<p>$n \le 10000$</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>把代码分为三部分，然后每部分分别处理即可。</p>
<ol>
<li>第一步，二进制转换，我们使用字符串来保存。</li>
</ol>
<p>对每个数进行按位分离(每位为2)，然后拼接成字符串即可。</p>
<ol>
<li>第二步，找最大的拼接。</li>
</ol>
<p>这是一个经典例题<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-number/description/">最大数(leetcode)</a> , 简单地说就是对字符串进行排序，排序规则是“对于相邻的两个串， 如果$s_a + s_b &gt; s_b + s_a$，那么$s_a$ 在$s_b$ 的前面” ,详细证明可以看leetcode例题的题解。</p>
<ol>
<li>第三步，对拼接后的字符串进行二进制转十进制。</li>
</ol>
<p>从最高位枚举然后乘起来即可，我们python不需要考虑溢出问题。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">s_lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    a = []</span><br><span class="line">    x = i</span><br><span class="line">    <span class="keyword">while</span>(x):</span><br><span class="line">        a.append(<span class="built_in">str</span>(x%<span class="number">2</span>))</span><br><span class="line">        x //= <span class="number">2</span></span><br><span class="line">    s_lst.append(<span class="string">&quot;&quot;</span>.join(a[::-<span class="number">1</span>])) <span class="comment"># 注意这里要倒过来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义排序推荐重写类的___lt__ 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,s</span>):</span><br><span class="line">        <span class="variable language_">self</span>.s = s</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self,other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.s+other.s &gt; other.s+<span class="variable language_">self</span>.s</span><br><span class="line"></span><br><span class="line">node_lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s_lst:</span><br><span class="line">    node_lst.append(Node(i))</span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">node_lst.sort()</span><br><span class="line"><span class="comment"># 拼接</span></span><br><span class="line">ans_str = <span class="string">&quot;&quot;</span> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> node_lst:</span><br><span class="line">    ans_str += i.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进制转换</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ans_str:</span><br><span class="line">    ans = ans * <span class="number">2</span> + <span class="built_in">int</span>(i)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>
<h2 id="E-彩色瓶子"><a href="#E-彩色瓶子" class="headerlink" title="E. 彩色瓶子"></a>E. 彩色瓶子</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给你n个瓶子，以及整数k。</p>
<p>每隔k个他们的瓶子颜色就是一样的。即对于所有的i，满足$color<em>i = color</em>{i + k}$  , 每个瓶子中都有一定量的水。记作$a_1,a_2,…,a_n$  。 </p>
<p>你可以任意次地将第$i$个瓶子中的整数量的水倒入相同颜色的瓶子$j$中 ,唯一的要求是$i &lt; j$。</p>
<p>那么请问，在任意次操作后， 所有瓶子中含水量的最小值，最大的可能是多少。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>最大的最小值，我们要首先尝试二分答案，在本题，二分求瓶子的最小值x。</p>
<p>我们的check函数应该是这样的：</p>
<p>我们对每个水瓶进行如下处理：</p>
<ol>
<li>如果当前水瓶的水超过x，那么把多余的水存下来，供后面使用。</li>
<li>如果当前水瓶的水不够x，则用之前相同颜色水瓶存的水补满，补不满则宣告这个x是不可能的。</li>
</ol>
<p>如果check(x) == True，我们则可以考虑令x更大一些</p>
<p>如果check(x) == False ，我们则考虑令x更小一些。</p>
<p>于是这样就能找到满足check(x) == True的最大的x了。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">n,k = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">global</span> n,a,k</span><br><span class="line">    have = [<span class="number">0</span>] * k </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt;= x):</span><br><span class="line">            have[i % k] += a[i] - x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span>(have[i%k]+a[i] &gt;= x):</span><br><span class="line">                have[i%k] -= x - a[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">l = <span class="number">1</span></span><br><span class="line">r = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"><span class="keyword">while</span>(l &lt; r):</span><br><span class="line">    mid = (l + r + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(check(mid)):</span><br><span class="line">        l = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = mid - <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure>
<h2 id="F-拼好数"><a href="#F-拼好数" class="headerlink" title="F.拼好数"></a>F.拼好数</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给出n个正整数。 $a_1,a_2,…,a_n$</p>
<p>你可以将他们拼接为若干个组。 要求如下：</p>
<ol>
<li>每组最多由三个数拼接而成</li>
<li>拼接完成后“6”的数位数量不少于6个。</li>
</ol>
<p>那么请问最多可以分为多少组？</p>
<p>$n \le 1000$</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>我们不关心$a$数组之间的顺序关系，并且只关心$a_i$ 中包含6的数量。所以我们可以统计一下出现$(0,1,2,3,4,5,6+)$个6的数分别有多少个。</p>
<p>注意</p>
<ol>
<li>当一个数中出现了不少于6个6时，那么只需要一个这个数就可以使得答案成立。我们可以把这一类数归为同一类。这一类不需要参与计算，他们单独一组就是最优的。</li>
<li>当一个数中出现了0个6时，这个数是没有用的，我们可以直接扔掉。</li>
</ol>
<p>于是我们就得到了cnt数组。其中$cnt[i]$ 表示出现了i个6有多少个数。</p>
<p>于是我们就可以考虑使用搜索来求了，那么如何进行状态转移？action为选择了一个合适的组。我的做法是预处理出所有可选的operator。得到如下数组(直接三重循环即可)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ope = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="comment"># 我们可以将这里的0视为不选，也可以视为选择一个包含0个6的数，因为“包含0个6的数”可以是任意多个。</span></span><br></pre></td></tr></table></figure>
<p>然后我们就可以通过这些操作来进行状态转移了。</p>
<p>一个状态可以描述为五元组$(cnt[1],cnt[2],…,cnt[5])$ 的取值。</p>
<p>之后我们进行搜索即可。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>本体的关键在于优化，下面详细讲一下优化策略：</p>
<ol>
<li>最刚需的优化就是记忆化搜索：</li>
</ol>
<p>我们发现对于某个状态，我们可能会重复了很多很多次，比如初始状态为$(0,0,3,3,3)$ ，那么如下两种序列都可以得到$(0,0,1,1,3)$ , 于是我们就会计算两次(甚至更多次)状态$(0,0,1,1,3)$ </p>
<p>序列一：</p>
<script type="math/tex; mode=display">
(0,0,3,3,3) \overset{ope(0,3,3)}{\to} (0,0,1,3,3)\overset{ope(0,4,4)}{ \to} (0,0,1,1,3) \\
(0,0,3,3,3) \overset{ope(0,3,4)}{\to} (0,0,1,3,3)\overset{ope(0,4,4)}{ \to} (0,0,1,1,3) \\</script><p>所以我们每次计算出一个状态的结果后，立刻把他放到字典当中。$dic(state) = value$ .</p>
<p>当下次再一次遇到这个状态时，我们就可以直接返回这个值了。</p>
<ol>
<li>剪枝</li>
</ol>
<p>本题的剪枝主要是计算答案的上界。 假设我们要从状态$u$ 转移到状态$v$ 。 $v = (s_1,s_2,s_3,s_4,s_5)$</p>
<p>那么状态v的贡献一定不会超过这两个值：</p>
<p>首先，必须选择至少两个数来组成一组，所以</p>
<script type="math/tex; mode=display">
ans_v \le \frac{s_1+s_2+...s_5}{2}</script><p>其次，每组必须有至少6个6.所以</p>
<script type="math/tex; mode=display">
ans_v \le \frac{s_1 + 2 * s_2 + ...+ 5*s_5}{6}</script><p>当我们在取到等号时，仍然无法做到$ans_v + 1 &gt; ans_u$ 即更新状态u的答案，那么我们再对v搜索就是徒劳的。这时候应该直接跳过本次搜索。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>()) </span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># n = 1000</span></span><br><span class="line"><span class="comment"># a = [6,66,666,6666,66666] * 200</span></span><br><span class="line">ope = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j,<span class="number">6</span>):</span><br><span class="line">            <span class="keyword">if</span>(i + j + k &gt;= <span class="number">6</span>):</span><br><span class="line">                ope.append((i,j,k))</span><br><span class="line"></span><br><span class="line">cnt = [<span class="number">0</span>] * <span class="number">7</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x = a[i]</span><br><span class="line">    cc = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(x):</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">10</span> == <span class="number">6</span>):</span><br><span class="line">            cc += <span class="number">1</span></span><br><span class="line">        x //= <span class="number">10</span></span><br><span class="line">    cnt[<span class="built_in">min</span>(cc,<span class="number">6</span>)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">cnt[<span class="number">0</span>] = <span class="built_in">int</span>(<span class="number">1e12</span>)</span><br><span class="line"><span class="comment"># 给cnt[0]一个足够大的值，代表我们可以选择任意数量的无效数。</span></span><br><span class="line"><span class="comment"># 可以减少特判</span></span><br><span class="line"></span><br><span class="line">visit = &#123;&#125; <span class="comment"># 记忆化字典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>():    </span><br><span class="line">    <span class="comment"># 如果当前完全凑不够6个6就该返回了。</span></span><br><span class="line">    cc = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">        cc += cnt[i] * i</span><br><span class="line">    <span class="keyword">if</span>(cc &lt; <span class="number">6</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span> <span class="comment"># 当前dfs最大可能的取值</span></span><br><span class="line">    gt = visit.get(<span class="built_in">tuple</span>(cnt[<span class="number">1</span>:<span class="number">6</span>]),<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span>(gt != <span class="literal">None</span>): <span class="comment"># 如果之前计算过，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> gt</span><br><span class="line">    <span class="keyword">for</span> x,y,z <span class="keyword">in</span> ope:</span><br><span class="line">        <span class="comment">## 尝试选择这组ope</span></span><br><span class="line">        cnt[x] -= <span class="number">1</span></span><br><span class="line">        cnt[y] -= <span class="number">1</span></span><br><span class="line">        cnt[z] -= <span class="number">1</span></span><br><span class="line">        ok = <span class="number">0</span> <span class="comment"># 这组ope是否是合法的     </span></span><br><span class="line">        <span class="keyword">if</span>(cnt[x] &gt;= <span class="number">0</span> <span class="keyword">and</span> cnt[y] &gt;= <span class="number">0</span> <span class="keyword">and</span> cnt[z] &gt;= <span class="number">0</span>):</span><br><span class="line">            ok = <span class="number">1</span> <span class="comment"># 是合法的</span></span><br><span class="line">        <span class="keyword">if</span>(ok):</span><br><span class="line">            <span class="comment"># 两个剪枝</span></span><br><span class="line">            c1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">                c1 += cnt[i]</span><br><span class="line">            <span class="comment"># 是否通过剪枝</span></span><br><span class="line">            c2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">                c2 += cnt[i] * i</span><br><span class="line">            <span class="keyword">if</span>(c1//<span class="number">2</span> + <span class="number">1</span> &gt; ans <span class="keyword">and</span> c2 //<span class="number">6</span> + <span class="number">1</span> &gt; ans):</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,dfs()+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 不管有没有进入dfs，都要返回现场</span></span><br><span class="line">        cnt[x] += <span class="number">1</span></span><br><span class="line">        cnt[y] += <span class="number">1</span></span><br><span class="line">        cnt[z] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最后记得更新visit</span></span><br><span class="line">    visit[<span class="built_in">tuple</span>(cnt[<span class="number">1</span>:<span class="number">6</span>])] = ans</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="built_in">print</span>(dfs()+cnt[<span class="number">6</span>]) <span class="comment">#  别忘了加cnt[6]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">6 66 666 6666 66666 666666</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">666 66 666666 123456</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">6 6 6 6 6 6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="G-登山"><a href="#G-登山" class="headerlink" title="G. 登山"></a>G. 登山</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>有一个n行m列的矩阵$h$ 。描绘了一个地图上每个格子的高度。$h[i][j]$ 表示第$i$行第$j$ 列的高度。</p>
<p>你当前的节点位置为$(p,q)$每次可以选择下面操作之一：</p>
<ol>
<li>选择一个$i&gt;p$ 的节点，并且$h[i][q] &lt; h[p][q]$ , 走到节点$(i,q)$</li>
<li>选择一个$i<p$ 的节点，并且$h[i][q] > h[p][q]$ , 走到节点$(i,q)$</li>
<li>选择一个$j&gt;q$ 的节点，并且$h[p][j] &lt; h[p][q]$ , 走到节点$(p,j)$</li>
<li>选择一个$j&lt;q$ 的节点，并且$h[p][j] &lt; h[p][q]$ , 走到节点$(p,j)$</li>
</ol>
<p>设你从(x,y) 节点出发，能够到达的最高的高度为$v_{x,y}$ , 本题你需要求的是从所有的节点出发能到达的最高高度的总和，数学表示为：</p>
<script type="math/tex; mode=display">
\underset{x = 1}{\overset{n}{\sum}}\underset{y = 1}{\overset{m}{\sum}} v_{i,j}</script><p>保证$1 \le n,m \le 10^4 , n*m \le 10^6$</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>首先我们可以发现：</p>
<blockquote>
<p>节点之间的路径是无向的，即如果可以从$(x_1,y_1)$ 移动到$(x_2,y_2)$ ，那么反过来一定可以从$(x_2,y_2)$ 移动到$(x_1,y_1)$ 。</p>
</blockquote>
<p>即节点之间的边均为无向边。那么又可以得到如下的结论：</p>
<blockquote>
<p>如果$(x<em>1,y_1)$ 与$(x_2,y_2)$ 之间有(无向)边, 那么$v</em>{x<em>1,y_1} = v</em>{x_2,y_2}$</p>
</blockquote>
<p>于是我们边很容易地想到了染色法求连通块的属性，具体为使用bfs/dfs搜索连通块，或者使用并查集来维护点的联通关系。</p>
<h3 id="一个会超时的反例"><a href="#一个会超时的反例" class="headerlink" title="一个会超时的反例"></a>一个会超时的反例</h3><p>以dfs为例，我们的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="number">0</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x,y</span>):</span><br><span class="line">    height = <span class="built_in">max</span>(height,h[x][y])</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> 满足条件 <span class="keyword">and</span> vis == <span class="number">0</span>:</span><br><span class="line">            vis[x2][y] = <span class="number">1</span></span><br><span class="line">            dfs(x2,y)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">if</span> 满足条件 <span class="keyword">and</span> vis == <span class="number">0</span>:</span><br><span class="line">            vis[x][y2] = <span class="number">1</span></span><br><span class="line">            dfs(x,y2)</span><br><span class="line">最终这个连通块的贡献就是height * cnt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该dfs的复杂度如下：</p>
<p>我们对每个节点都要进入一次dfs循环($vis[x][y]$从0到1的那一次)，因此一共有$n*m$ 个dfs。</p>
<p>而对于每一个dfs函数，我们都使用了两个循环来找答案。</p>
<p>总的时间复杂度是$O(n<em>m</em>(n+m))$</p>
<p>在本题这是不被允许的。</p>
</blockquote>
<p>复杂度的问题在于，在我们染色时，很多时候遇到的都是之前已经遇到过的节点。而这些节点只会花时间判断if为False然后结束，并没有高效地更新答案。</p>
<h3 id="正确的思路"><a href="#正确的思路" class="headerlink" title="正确的思路"></a>正确的思路</h3><p>我们改用并查集维护颜色，并尝试借用单调属性进行优化。过程如下：</p>
<p>我们发现，本体的难点在于计算出哪些节点之间是联通的。</p>
<p>我们先逐行分析，取出第一行$h[1]$ , 我们叫他$a$ , 那么根据行动规则：</p>
<p>$a[i]$ 会和所有$j &lt; i, a[j] &gt; a[i]$ 的节点连通。(说人话就是这个节点会和前面所有比他大的节点连通) 。</p>
<p>假设我们的a数组如下：</p>
<p>$\text{1 3 5 4 7 2 9 8 10}$</p>
<p>我们枚举每个元素。下面详细讲解过程：</p>
<ol>
<li>遇到了1，3，5 。他们之间不能连接。此时有三个小组(1),(3),(5)</li>
<li>遇到了4， 他可以和(5) 连接 ，此时三个小组(1),(3),(5,4)</li>
<li>遇到了7，他不能和任何组(如果7比一个组中的最大值要大，那么就可以和这一组连接)连接，此时四个小组(1),(3),(5,4),(7)</li>
<li>遇到了2，能和(3),(5,4),(7)连接， 这三个组合并,现在两个组(1),(3,5,4,7,2)</li>
<li>遇到了9，无法连接，现在三个组(1),(3,5,4,7,2),(9)</li>
<li>遇到了8，和9连接，(1),(3,5,4,7,2),(9,8)</li>
<li>遇到了10，无法连接(1),(3,5,4,7,2),(9,8),(10)</li>
</ol>
<p>这样我们就分好了组。同组之间的节点可以相互到达。</p>
<p>接下来对每行都进行如上处理。然后对每列再进行处理。行列合并后就得到了连通块。</p>
<p>如何保证时间复杂度？</p>
<p>我们知道我们只关心每组最大的那个成员，所以我们称它为“代表”</p>
<p>每组选择一个代表，可以证明他们本身就是有序关系的（如果后面一个组的max小于前面某个组的max，那么就会触发合并操作），于是我们倒序地找所有比x大的组，将这些组和x一起合并。 </p>
<p>于是总的复杂度是$O(n*m)$ 的。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>本题代码来自我的队友<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45809243">csdn主页</a> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">mp = [[<span class="number">0</span>] * (m+<span class="number">5</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">5</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    mp[i][<span class="number">1</span>:m+<span class="number">1</span>] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">f = [<span class="number">0</span>] * (n*m+<span class="number">5</span>)</span><br><span class="line">maxh = [<span class="number">0</span>] * (n*m+<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n*m+<span class="number">1</span>):</span><br><span class="line">    f[i] = i</span><br><span class="line">    maxh[i] = mp[(i-<span class="number">1</span>)//m+<span class="number">1</span>][(i-<span class="number">1</span>)%m+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_idx</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x-<span class="number">1</span>)*m+y-<span class="number">1</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findf</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> f[x] == x:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f[x] = findf(f[x])</span><br><span class="line">        <span class="keyword">return</span> f[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">u, v</span>):</span><br><span class="line">    fu, fv = findf(u), findf(v)</span><br><span class="line">    maxh[fu] = <span class="built_in">max</span>(maxh[fu], maxh[fv])</span><br><span class="line">    f[fv] = fu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    stack = <span class="built_in">list</span>()  <span class="comment"># 高度 并查集位置</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">        idx = to_idx(i, j)</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>][<span class="number">0</span>] &gt; mp[i][j]:</span><br><span class="line">            merge(stack[-<span class="number">1</span>][<span class="number">1</span>], idx)</span><br><span class="line">            stack.pop()</span><br><span class="line">        stack.append((mp[i][j], idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">    stack = <span class="built_in">list</span>()  <span class="comment"># 高度 并查集位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        idx = to_idx(i, j)</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>][<span class="number">0</span>] &gt; mp[i][j]:</span><br><span class="line">            merge(stack[-<span class="number">1</span>][<span class="number">1</span>], idx)</span><br><span class="line">            stack.pop()</span><br><span class="line">        stack.append((mp[i][j], idx))</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">        fa = findf(to_idx(i, j))</span><br><span class="line">        ans += maxh[fa]</span><br><span class="line">    <span class="comment">#     print(maxh[fa], end=&quot; &quot;)</span></span><br><span class="line">    <span class="comment"># print()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans/(n*m))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">2 2</span></span><br><span class="line"><span class="string">1 4</span></span><br><span class="line"><span class="string">4 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2 3</span></span><br><span class="line"><span class="string">2 4 1</span></span><br><span class="line"><span class="string">4 2 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="H-原料采购"><a href="#H-原料采购" class="headerlink" title="H.原料采购"></a>H.原料采购</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>在一条直线道路上，你在道路的最左边（原点）， 在原点的右边有n个采购点。</p>
<p>对于第i个采购点，他的单价是$a_i$元 ,一共有$b_i$ 个物品， 距离原点$c_i$ </p>
<p>你需要采购总共m个物品。公路的行驶单价为$o$ ,这意味着每当你在公路上行走了$2<em>x$米。你就会花费$o </em> x$ 元。(这里的单价是往返单价，所以你到达距离x再返回，则会 花费$o*x$ 元 )</p>
<p>那么请问，购买恰好m个物品，最少需要花费多少钱。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>很经典的反悔贪心。（解决的问题是可能会在未来遇到更好条件（在本体是更低的单价），而可能又必须在现在就执行的问题）</p>
<p>假设我们要在前i个采购点采购物品。那么路费就是$o * c_i$  。</p>
<p>此时我们可以在这i个采购点中选择单价最小的m个物品来购买。假设购买清单如下：${(cost_t,buy_t)}_k$</p>
<p>表示买了$buy_t$ 个单价为$cost_t$ 的物品，这样的元组一共有k个（即有k种不同的单价）。</p>
<p>我们便可以算出他们的总花费$COST<em>i = \sum</em>{t=1}^k cost_t * buy_t$ （这里体现了贪心，即尽量选择单价小的物品）</p>
<p>当我们再多考虑一个采购点时，我们先假设购买第$i+1$ 个采购点的所有物品。 那么这时候可能会发生购买的物品超过了m。这时候我们需要“退货” ，假设需要退货$refund_i$件物品, 我们就选择已购买的物品中单价最大的$refund_i$ 个退货就好了。找单价最大的物品可以用单调队列（也就是堆）实现（这里体现了反悔）</p>
<p>重复此过程，答案即为$\underset{i = k} {\overset{n}\sum} (COST_i + o * c_i)$ , 这里的i要从k开始，k的含义为，全买下来所有前k个采购点的物品，恰好大于等于m个物品。（即k-1就不够了）</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">INlist = <span class="keyword">lambda</span>: <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">n,m,o = INlist()</span><br><span class="line">cgd = [] <span class="comment"># 采购点</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    cgd.append(INlist())</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,buy,cost</span>):</span><br><span class="line">        <span class="variable language_">self</span>.buy = buy</span><br><span class="line">        <span class="variable language_">self</span>.cost = cost</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self,other</span>):<span class="comment"># 花费高的在前面,优先出队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.cost &gt; other.cost </span><br><span class="line"></span><br><span class="line">pq = PriorityQueue()</span><br><span class="line"></span><br><span class="line">buy_cnt = <span class="number">0</span> <span class="comment">#买了几件物品了</span></span><br><span class="line">cost_cnt = <span class="number">0</span> <span class="comment"># 购买花费了多少</span></span><br><span class="line">ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment"># 总花费</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    pq.put(Node(cgd[i][<span class="number">1</span>],cgd[i][<span class="number">0</span>]))<span class="comment"># 全买下来</span></span><br><span class="line">    buy_cnt += cgd[i][<span class="number">1</span>]</span><br><span class="line">    cost_cnt += cgd[i][<span class="number">0</span>] * cgd[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span>(buy_cnt &gt; m):</span><br><span class="line">        <span class="keyword">while</span>(buy_cnt &gt; m):</span><br><span class="line">            node = pq.get()</span><br><span class="line">            t = <span class="built_in">min</span>(node.buy,buy_cnt - m)</span><br><span class="line">            buy_cnt -= t</span><br><span class="line">            cost_cnt -= node.cost * t</span><br><span class="line">            node.buy -= t</span><br><span class="line">            <span class="keyword">if</span>(node.buy &gt; <span class="number">0</span>) : <span class="comment"># 还有剩余,还要购买</span></span><br><span class="line">                pq.put(node)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,cost_cnt+o*cgd[i][<span class="number">2</span>]) <span class="comment"># 总花费=商品花费+路程花费</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="lsk404.github.io">Little_sk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://lsk404.github.io/2025/04/12/d49b5a7aa584/">https://lsk404.github.io/2025/04/12/d49b5a7aa584/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A2%98%E8%A7%A3/">题解</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post-share"><div class="social-share" data-image="/img/avator.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/09/0ed69ce9ed7c/" title="电子扫盲"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">电子扫盲</div></div><div class="info-2"><div class="info-item-1">电子扫盲课文件后缀打开显示后缀可能你想写一个cpp代码，然后创建了一个文本文件叫做code.cpp , 那么实际上你创建的是code.cpp.txt  ,  他本质上还是一个txt文件。 有时候我们需要更改文件后缀，这时候我们就必须打开文件浏览器的显示后缀的功能了（默认是关闭的） 改后缀会不会出问题？改后缀只是更改了这个文件的标签，并没有更改内部的内容。 谨慎处理不同文件类型之间的后缀相互转换！  文本文件: txt、md、c、cpp、py等（注意docx文件并不是文本文件！） 图片： jpg、gif、png 等等等  不要把doc文件转换为txt文件！！...</div></div></div></a><a class="pagination-related" href="/2025/04/16/887930e5b441/" title="强化学习数学原理笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">强化学习数学原理笔记</div></div><div class="info-2"><div class="info-item-1">强化学习数学原理第一章基本概念 grid-world example ： 一个机器人走网格的经典例子，机器人尽量避免进入forbidden grid、尽量减少拐弯、不要走出边界、……  state: 状态，表示为一个节点，在grid-world中可以表示为一个格子（也可以添加其他信息到状态，如速度等）  state space：状态空间，所有状态的集合。  action：行动，能够使得状态变化的动作。（如向上/下/左/右移动，等）  action space：行动的集合，通常依赖于当前的状态。  state transition：状态转移，从一个状态移动到另一个状态。   $s_5 \overset{a_1}{\rightarrow} s_6$ 表示从状态$s_5$ 经过动作$a_1$ 到达状态 $a_6$  state transition probability: 状态转移的条件概率。（例如：$p(s_2|s_1,a_2) = 0.8$ 代表在状态$s_1$，行动$a_2$ 下，$s_2$的概率是0.8)  Policy:...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/09/29/4b96d5c23f0d/" title="2022绵阳站E"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-29</div><div class="info-item-2">2022绵阳站E</div></div><div class="info-2"><div class="info-item-1">2022 CCPC 绵阳站 E题 （图上DP，根号分治）题意有一个由$n$城市组成的国家，城市之间由一条权值为$w$的边连接，共m条这样的边，并且保证整个国家是连通的。每个城市中有$a_i$ 个居民。 在接下来的q天，每天都会有一个城市遭受灾难$b_1,b_2,…,b_q$，你必须将该城市的所有人都转移到其它城市才能避免居民受到灾难，转移一个居民到相邻城市的代价为两个城市之间路径的权值w。 请问你最少需要多少代价才能让所有居民都安全度过q天的灾难。 思路我们不必管每个城市中有多少个人，我们只需要求出每个城市中转移一个人的最小代价，在最终计算总代价时再乘上人数即可。很容易想到一个暴力的DP解法如下： 令$f(i,j)$ 表示在第$j$号点，第$i$天后所有的操作中最小的代价。那么有$f(i,j) = MIN{(v,w) \in edge{b_i}}{w+f(i+1,v)}$ 。  我们发现每天只会更新一个dp值，于是我们可以直接省去f的第一维，然后倒序枚举天数 $i $ 从$q$到$1$ 。 总的时间复杂度为$O(\sum_{i=1}^q deg(b_i)$...</div></div></div></a><a class="pagination-related" href="/2023/11/12/026c0040b952/" title="2023ICPC网络赛第二场"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="info-item-2">2023ICPC网络赛第二场</div></div><div class="info-2"><div class="info-item-1">The 2023 ICPC Asia Regionals Online Contest (2) (pintia.cn) K Super-knight题意有一个士兵，起初在n*n的棋盘的左下角，每次向右移动a格，向上移动b格，当越过地图边界时，则到地图的另一边（类似于没有边界墙的贪吃蛇），对这个士兵能到达的格子做标记，所有被标记的格子中，离左下角格子最近的距离是多少。（假设最近的格子为$(x, y)$，就输出$(x - 1)^2+(y - 1)^2$ ) （ $2 \le n \le 10^{18}, 1 \le a,b \le 200$) 思路可以得出，在经过n次移动后，一定回回到起始点，所以最终的路径一定是循环的。 但n太大，无法通过这样判断所有的被标记的点。 可以发现，在移动了若干次后，除非穿过地图边界，否则只会增加 与原点的距离。因此我们只需要考虑刚穿过地图边界的点...</div></div></div></a><a class="pagination-related" href="/2023/09/18/3b4839b3d1b7/" title="2023ICPC网络赛第一场"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-18</div><div class="info-item-2">2023ICPC网络赛第一场</div></div><div class="info-2"><div class="info-item-1">The 2023 ICPC Asia Regionals Online Contest (1)，不要选时光机，用签到送的金币就可以练习 G Spanning Tree题意起初树只有n个节点，没有边，按照如下操作进行n-1次，对于第i次操作，选择$a_i,b_i$ ,从$a_i$ 所在的块中随机选出一个节点$u_i$，从$b_i$ 所在的块中随机选出一个节点$v_i$， 连接$u_i,v_i$保证最终会形成一个树，求构造出的这个树和给出的标准的树T能够完全相同的期望（对 998244353取模） 保证第$i$次操作前,$a_i,b_i$ 不在同一个块。 定义一个节点v所在的块即v能到达的所有节点的集合（包括v本身） 请注意，所求的期望可能是0。 思路可以得出，最终期望一定是0或者 $\frac{1}{s}$ ： 每次连接两个块时，最多只有一种连接方式能够使得所连边的情况和最终的树匹配。而本次操作会使得操作前的期望$s_{i-1}$ 再乘上 $\frac{1}{sz_a*sz_b}$ ($sz_a,sz_b$表示a和b当前所在块的节点数量)。 ...</div></div></div></a><a class="pagination-related" href="/2023/10/29/c6413222be25/" title="2023年10月ZZUACM实验室招新赛题解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="info-item-2">2023年10月ZZUACM实验室招新赛题解</div></div><div class="info-2"><div class="info-item-1">注意事项请注意！：  题解仅代表个人看法，不代表最优解  每道题都会附上ac代码，但是仅作参考，要看懂后再了解代码。补题不要直接抄代码！禁止自欺欺人！  只提供题解，不提供题目信息 ac代码为C++版本，如果遇到不懂的语法请自行百度 ac代码中的循环经常用到了for(int i = 1;i&lt;=n;i++) ，这种在for的括号中int i的操作只有大于等于C++11标准才可以使用，编译错误时请检查自己编译使用的标准。  A.数位分解对于一个数x，   使用  x % 10 (% 是取余数) ，就可以得到他的最后一位 使用 x /= 10  (除以十并取整数)，就可以舍掉他的最后一位  使用while(x) 来进行循环 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123;	int x;	cin&gt;&gt;x;	while(x)&#123;		cout&lt;&lt; x % 10 &lt;&lt;&quot; &quot;;		x = x / 10;	&#125;	return...</div></div></div></a><a class="pagination-related" href="/2024/09/09/17fe9a65a7dc/" title="AtCoder Beginner Contest 346"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-09</div><div class="info-item-2">AtCoder Beginner Contest 346</div></div><div class="info-2"><div class="info-item-1">AtCoder Beginner Contest 346 A - Adjacent Product题意给你一个数组$a1,a_2,…,a_n$ ，现在有$b_i = a_i * a{i+1}$ 输出$b1,b_2,…,b{n-1}$ 思路照着题意写就行 代码12345n = int(input())lst = [int(x) for x in input().split()]ans = []for i in range(len(lst)-1):    print(lst[i] * lst[i+1],end=&#x27; &#x27;) B - Piano题意有一个字符串，由无数个wbwbwwbwbwbw 重复得来，现在给出两个数W和B$(1\le W,B \le 100 )$ 问是否存在某个子串满足：包含$W$个w以及$B$ 个b 思路这个子串一定不会超过200位，所以我们重复wbwbwwbwbwbw 40次(长度$12*40 = 480$)就可以保证所有的子串都在其中，然后我们求所有长度为$W+B$...</div></div></div></a><a class="pagination-related" href="/2023/09/29/f6c0852c19b0/" title="Codeforces Round 806 (Div. 4)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-29</div><div class="info-item-2">Codeforces Round 806 (Div. 4)</div></div><div class="info-2"><div class="info-item-1">刚学python，还是免不了C++的代码风格。 Love Story12345678910111213def solve():    str = input()    ans = 0    for i in range(10):        if(str[i] != std[i]):            ans +=1    print(ans)###########t = int(input())std = &quot;codeforces&quot;for i in range(t):    solve()      Blank Space1234567891011121314#pythont = int(input())for i in range(t):    n = int(input())    a = map(int,input().split())    temp = 0    ans = -1    for j in a:        if j == 0:            temp+=1        else:            temp =...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Little_sk</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lsk404/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">加我友链！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2025%E8%93%9D%E6%A1%A5%E6%9D%AFPythonA%E7%BB%84%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">2025蓝桥杯PythonA组省赛题解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-RGB%E4%B8%89%E8%89%B2"><span class="toc-number">1.1.</span> <span class="toc-text">A. RGB三色</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">思路 &amp; 代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-IPv6%E7%9A%84%E7%BC%A9%E5%86%99%E9%95%BF%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">B. IPv6的缩写长度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-2025"><span class="toc-number">1.3.</span> <span class="toc-text">C. 2025</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D-1%E5%88%B0n%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.4.</span> <span class="toc-text">D 1到n的二进制拼接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.4.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#E-%E5%BD%A9%E8%89%B2%E7%93%B6%E5%AD%90"><span class="toc-number">1.5.</span> <span class="toc-text">E. 彩色瓶子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">1.5.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.5.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#F-%E6%8B%BC%E5%A5%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">F.拼好数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-5"><span class="toc-number">1.6.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">1.6.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.3.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">1.6.4.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G-%E7%99%BB%E5%B1%B1"><span class="toc-number">1.7.</span> <span class="toc-text">G. 登山</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-6"><span class="toc-number">1.7.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">1.7.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BC%9A%E8%B6%85%E6%97%B6%E7%9A%84%E5%8F%8D%E4%BE%8B"><span class="toc-number">1.7.3.</span> <span class="toc-text">一个会超时的反例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">1.7.4.</span> <span class="toc-text">正确的思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">1.7.5.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H-%E5%8E%9F%E6%96%99%E9%87%87%E8%B4%AD"><span class="toc-number">1.8.</span> <span class="toc-text">H.原料采购</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-7"><span class="toc-number">1.8.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">1.8.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">1.8.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/16/887930e5b441/" title="强化学习数学原理笔记">强化学习数学原理笔记</a><time datetime="2025-04-16T09:53:00.000Z" title="Created 2025-04-16 17:53:00">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/12/d49b5a7aa584/" title="2025蓝桥杯PythonA组省赛题解">2025蓝桥杯PythonA组省赛题解</a><time datetime="2025-04-12T12:28:00.000Z" title="Created 2025-04-12 20:28:00">2025-04-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/09/0ed69ce9ed7c/" title="电子扫盲">电子扫盲</a><time datetime="2025-03-09T04:00:00.000Z" title="Created 2025-03-09 12:00:00">2025-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/12/27d697c28fe4/" title="十六届蓝桥杯模拟赛3题解">十六届蓝桥杯模拟赛3题解</a><time datetime="2025-02-12T04:00:00.000Z" title="Created 2025-02-12 12:00:00">2025-02-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/02/c836153aa73d/" title="十六届蓝桥杯模拟赛1题解">十六届蓝桥杯模拟赛1题解</a><time datetime="2024-12-02T04:00:00.000Z" title="Created 2024-12-02 12:00:00">2024-12-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(img/bg3.png);"><div id="footer-wrap"><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20250258" target="_blank">萌ICP备20250258号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'jY5tnMLwMUhZNOv61yXvepci-gzGzoHsz',
      appKey: 'gZbn0Lr7joLZ83iUlbqPfk4J',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: '01FHVVY2XK',
    apiKey: '758762af2109005ec9cba47e50ae0bfa',
    indexName: 'lsk404io_articles',
    container: '#docsearch',
    placeholder: 'Search what you want to search',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>