<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>cpp知识点总结 | Little_sk</title><meta name="author" content="Little_sk"><meta name="copyright" content="Little_sk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0. 杂类cin&#x2F;cout提速使用ios::sync_with_stdio(false);加速输入输出速度 &lt;&lt;的优先级运算符&lt;&lt;和&gt;&gt; 的优先级比表达式中有的运算符要高，有时候要加上括号 1cout&lt;&lt;(a&lt;b)&lt;&lt;endl; 字符函数库cctype判断一个字符ch是什么类型的： 1234isalpha(ch);&#x2F;&#x2F;字母isdig">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp知识点总结">
<meta property="og:url" content="https://lsk404.github.io/0a85d83dfe8a/index.html">
<meta property="og:site_name" content="Little_sk">
<meta property="og:description" content="0. 杂类cin&#x2F;cout提速使用ios::sync_with_stdio(false);加速输入输出速度 &lt;&lt;的优先级运算符&lt;&lt;和&gt;&gt; 的优先级比表达式中有的运算符要高，有时候要加上括号 1cout&lt;&lt;(a&lt;b)&lt;&lt;endl; 字符函数库cctype判断一个字符ch是什么类型的： 1234isalpha(ch);&#x2F;&#x2F;字母isdig">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://lsk404.github.io/img/avator.jpg">
<meta property="article:published_time" content="2023-06-27T04:00:00.000Z">
<meta property="article:modified_time" content="2025-03-20T14:36:20.939Z">
<meta property="article:author" content="Little_sk">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lsk404.github.io/img/avator.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "cpp知识点总结",
  "url": "https://lsk404.github.io/0a85d83dfe8a/",
  "image": "https://lsk404.github.io/img/avator.jpg",
  "datePublished": "2023-06-27T04:00:00.000Z",
  "dateModified": "2025-03-20T14:36:20.939Z",
  "author": [
    {
      "@type": "Person",
      "name": "Little_sk",
      "url": "https://lsk404.github.io/lsk404.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://lsk404.github.io/0a85d83dfe8a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-745T2DDK98"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-745T2DDK98')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-745T2DDK98', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":150,"languages":{"author":"Author: Little_sk","link":"Link: ","source":"Source: Little_sk","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cpp知识点总结',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(img/bg3.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.ico" alt="Logo"></a><a class="nav-page-title" href="/"><span class="site-name">cpp知识点总结</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">cpp知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-06-27T04:00:00.000Z" title="Created 2023-06-27 12:00:00">2023-06-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-20T14:36:20.939Z" title="Updated 2025-03-20 22:36:20">2025-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">22.4k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="0-杂类"><a href="#0-杂类" class="headerlink" title="0. 杂类"></a>0. 杂类</h1><h2 id="cin-cout"><a href="#cin-cout" class="headerlink" title="cin/cout"></a>cin/cout</h2><h3 id="提速"><a href="#提速" class="headerlink" title="提速"></a>提速</h3><p>使用ios::sync_with_stdio(false);加速输入输出速度</p>
<h3 id="lt-lt-的优先级"><a href="#lt-lt-的优先级" class="headerlink" title="&lt;&lt;的优先级"></a><strong>&lt;&lt;的优先级</strong></h3><p>运算符&lt;&lt;和&gt;&gt; 的优先级比表达式中有的运算符要高，有时候要加上括号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;(a&lt;b)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h3 id="字符函数库cctype"><a href="#字符函数库cctype" class="headerlink" title="字符函数库cctype"></a><strong>字符函数库cctype</strong></h3><p>判断一个字符ch是什么类型的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isalpha</span>(ch);<span class="comment">//字母</span></span><br><span class="line"><span class="built_in">isdight</span>(ch);<span class="comment">//数字</span></span><br><span class="line"><span class="built_in">isspace</span>(ch);<span class="comment">//空白（不止是空格）</span></span><br><span class="line"><span class="built_in">ispunct</span>(ch);<span class="comment">//标点</span></span><br></pre></td></tr></table></figure>
<p>比直接判断ASCII码更加容易使用（有的字符格式没有用ASCII码存就只能这么判断）</p>
<h3 id="文件输入输出IO"><a href="#文件输入输出IO" class="headerlink" title="文件输入输出IO"></a>文件输入输出IO</h3><p>包含库文件fstream后可以进行文件的读写</p>
<p>创建ofstream对象和ifstream对象来分别对文件进行写和读用法和cout cin类似；</p>
<p>使用ofstream对象中的open()方法可以打开一个文件</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="顺序点"><a href="#顺序点" class="headerlink" title="顺序点"></a>顺序点</h3><p>当到达顺序点时，会结算所有副作用（比如自增自减）</p>
<p>一个完整表达式的末尾是一个顺序点（完整表达式代表这个表达式不是其他表达式的子表达式）</p>
<p>逻辑运算符||和&amp;&amp;也是顺序点</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>内联函数在声明和定义的时候都需要加上inline，并且和普通的函数不同，内联函数的定义必须在被调用之前</p>
<p>内联函数在声明和定义的时候都需要加上inline，并且和普通的函数不同，内联函数的定义必须在被调用之前</p>
<h3 id="尽可能地使用const"><a href="#尽可能地使用const" class="headerlink" title="尽可能地使用const"></a>尽可能地使用const</h3><p>使用const能够<strong>避免无意中修改数据的编程错误</strong></p>
<p>使用const<strong>使函数能够处理const和非const实参</strong>，否则将只能接受非const数据</p>
<p>使用consti引用能够<strong>使函数正确生成并使用临时变量</strong></p>
<h2 id="提升可读性"><a href="#提升可读性" class="headerlink" title="提升可读性"></a>提升可读性</h2><h3 id="字符串-字符指针作函数形参"><a href="#字符串-字符指针作函数形参" class="headerlink" title="字符串/字符指针作函数形参"></a>字符串/字符指针作函数形参</h3><p>在函数头的形参定义中使用<code>char p[]</code>，和<code>char *p</code>往往有相同作用，</p>
<p>但是当只希望实参<strong>传入字符串</strong>时候使用<code>char p[]</code>,希望传入一个<strong>字符指针</strong>时使用<code>char *p</code>比较好</p>
<h2 id="4-复合类型"><a href="#4-复合类型" class="headerlink" title="4.复合类型"></a>4.复合类型</h2><h3 id="4-1字符串字面量"><a href="#4-1字符串字面量" class="headerlink" title="4.1字符串字面量"></a>4.1字符串字面量</h3><h4 id="4-1-1其他形式的字符串字面量"><a href="#4-1-1其他形式的字符串字面量" class="headerlink" title="4.1.1其他形式的字符串字面量"></a>4.1.1其他形式的字符串字面量</h4><p>在字符串的前面加上L u 和U等（分别表示widechar，char16，char32）</p>
<p>在字符串的前面加上L u 和U等（分别表示widechar，char16，char32）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> str1[] = <span class="string">L&quot;w_char string&quot;</span>;</span><br><span class="line"><span class="type">char16_t</span> str2[] = <span class="string">u&quot;char16_t string&quot;</span>;</span><br><span class="line"><span class="type">char32_t</span> str3[] = <span class="string">U&quot;char32_t string&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2原始字符串"><a href="#4-1-2原始字符串" class="headerlink" title="4.1.2原始字符串"></a>4.1.2原始字符串</h4><p>一般的原始字符串的格式为<code>R&quot;(...)&quot;</code> 。诸如<code>\n</code>等转义字符会被解释为两个字符<code>\</code>和<code>n</code>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">R&quot;(this is a &quot;raw&quot; string \n)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">// this is a &quot;raw&quot; string \n</span></span><br></pre></td></tr></table></figure>
<p>可以通过在双引号”和括号(之间加入任意字符，这样只有遇见与之相同的字符时才会代表整个字符串的结束：（当字符串中出现小括号时使用）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">R&quot;+*(this is a string()())+*&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">//this is a string()()</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2指针和自由存储空间"><a href="#4-2指针和自由存储空间" class="headerlink" title="4.2指针和自由存储空间"></a>4.2指针和自由存储空间</h3><p><strong>*</strong>运算符 被称为<strong>间接值（indirect value）</strong> 或<strong>解除引用（derefencing）</strong>运算符。</p>
<p>指针用于在运行阶段分配未命名的内存以存储值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-1自由储存空间"><a href="#4-2-1自由储存空间" class="headerlink" title="4.2.1自由储存空间"></a>4.2.1自由储存空间</h4><p>使用<code>int a;</code> 生成的变量会被存储在<strong>栈</strong>（stack）中</p>
<p>而使用<code>new</code>生成的数据对象则会被储存在<strong>堆</strong>（heap）或称<strong>自由存储区</strong>（free store）中</p>
<p>使用<code>delete</code>来释放内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*p = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>这样不会删除p指针本身，只会释放p指针指向的地址</p>
<h4 id="4-2-2动态数组"><a href="#4-2-2动态数组" class="headerlink" title="4.2.2动态数组"></a>4.2.2动态数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * psome = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] psome;</span><br></pre></td></tr></table></figure>
<p>假设有数组 arr[10];<br>那么 <strong>arr</strong>和<strong>&amp;arr</strong>的值是相同的，但是表达的意义不一样，<strong>arr</strong>表示首元素的地址，<strong>&amp;arr</strong>表示整个数组的地址<br>可以这样定义一个指向数组本身的指针：（p是 short[10]类型的指针）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">short</span> (*p)[<span class="number">10</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>
<p>使用cout打印时，如果使用的变量是数组名，数组是字符数组，则打印字符（串），是其他类型数组（如int数组，则打印首地址）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ins[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">char</span> chs[<span class="number">10</span>] = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">std::cout&lt;&lt;ins&lt;&lt;endl;<span class="comment">//0x61fdf0</span></span><br><span class="line">std::cout&lt;&lt;chs&lt;&lt;endl;<span class="comment">//12345</span></span><br></pre></td></tr></table></figure>
<p>如果需要打印数组的首地址，那么可以对指针进行类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;(<span class="type">int</span>*)chs&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3指针和const"><a href="#4-2-3指针和const" class="headerlink" title="4.2.3指针和const"></a>4.2.3指针和const</h4><p>常量指针<code>const int* ps = &amp;a;</code></p>
<p>指针常量<code>int * const finger = &amp;b;</code></p>
<p>区别在于，<strong>const的位置不同。</strong></p>
<p>当const位于*前面时候，不能通过ps修改a的值，但是可以修改ps所指向的地址（可以改为ps=&amp;b）</p>
<p>当const位于*后面时，则恰恰相反， 可以通过ps修改a的值，但是不能更换ps指向的地址。</p>
<h3 id="4-3数组的替代品vector-array"><a href="#4-3数组的替代品vector-array" class="headerlink" title="4.3数组的替代品vector/array"></a>4.3数组的替代品vector/array</h3><p>模板类 <strong>vector</strong>，可以实现可变数组的效果，内部使用new和delete动态分配内存</p>
<p>需要包含文件 <code>&lt;vector&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi;<span class="comment">//创建一个0长的int类型数组</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">vd</span><span class="params">(n)</span></span>;<span class="comment">//创建double类型数组</span></span><br></pre></td></tr></table></figure>
<p>模板类 <strong>array（c11）</strong></p>
<p>对于长度固定的数组，使用array类比vector更佳</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,5&gt; ai;<span class="comment">//长度为5的int类型数组</span></span><br><span class="line">array&lt;<span class="type">double</span>,4&gt; ad = &#123;<span class="number">1.0</span>,<span class="number">2.5</span>,<span class="number">3.3</span>,<span class="number">4</span>&#125;;<span class="comment">//长度为4的double类型数组</span></span><br></pre></td></tr></table></figure>
<h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7.函数"></a>7.函数</h2><h3 id="7-1函数和二维数组"><a href="#7-1函数和二维数组" class="headerlink" title="7.1函数和二维数组"></a>7.1函数和二维数组</h3><p>数组名被视为数组的首地址：</p>
<p>比如一个二维数组data和函数sum</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> total = <span class="built_in">sum</span>(data,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>那么函数的原型应该为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> (*arr2)[<span class="number">4</span>],<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> arr2[][<span class="number">4</span>],<span class="type">int</span> size)</span></span>;<span class="comment">//可读性更强</span></span><br></pre></td></tr></table></figure>
<p>arr2是指向一个<strong>由4个int组成的数组</strong>的指针(所以他是个数组指针)</p>
<h3 id="7-2函数指针"><a href="#7-2函数指针" class="headerlink" title="7.2函数指针"></a>7.2函数指针</h3><h4 id="7-2-1获取函数的地址"><a href="#7-2-1获取函数的地址" class="headerlink" title="7.2.1获取函数的地址"></a>7.2.1获取函数的地址</h4><p>只使用函数名（后面不加参数）就相当于<strong>函数的地址</strong></p>
<p>比如对于函数<code>think(a)</code>,那么<code>think</code>就代表了这个函数的地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">process1</span>(think);</span><br><span class="line"><span class="built_in">process2</span>(<span class="built_in">think</span>());</span><br></pre></td></tr></table></figure>
<p>对于第一行代码，<code>process1</code>以<code>think</code>的地址为实参进行传递</p>
<p>第二行代码，则会先运行<code>think()</code>函数，然后将他的返回值传递给<code>process2</code></p>
<h4 id="7-2-2声明指向函数的指针"><a href="#7-2-2声明指向函数的指针" class="headerlink" title="7.2.2声明指向函数的指针"></a>7.2.2声明指向函数的指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> (*pf)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>pf表示一个<strong>特征标</strong>为int，<strong>返回值</strong>为double的函数指针 。</p>
<p>必须用括号括住（*pf）, 如果不带括号会变成声明一个函数。</p>
<p>将一个函数指针指向函数时，必须保证二者<strong>的特征标和返回值都相同</strong></p>
<h4 id="7-2-3使用函数指针"><a href="#7-2-3使用函数指针" class="headerlink" title="7.2.3使用函数指针"></a>7.2.3使用函数指针</h4><p>在第8行中，<code>(*pf)(5)</code>也可以替换为<code>pf(5)</code>,但是前者给出了提示：代码正在使用函数指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">double</span> (*pf)(<span class="type">int</span>);</span><br><span class="line">pf=pam;</span><br><span class="line"><span class="type">double</span> x = <span class="built_in">pam</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">double</span> y = (*pf)(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h4 id="7-2-4深入探讨函数指针"><a href="#7-2-4深入探讨函数指针" class="headerlink" title="7.2.4深入探讨函数指针"></a>7.2.4深入探讨函数指针</h4><p>1.对于以下<strong>特征标</strong>，他们看似不同，实则是相同的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[],<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f2</span><span class="params">(<span class="type">const</span> <span class="type">double</span> [],<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> * <span class="title">f3</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *,<span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在<strong>函数原型</strong>中，可以省去标识符，因此 <code>const double ar[]</code>可以简化为<code>const double []</code></p>
<p>2.由<strong>函数指针</strong>组成的数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span>* (*pa[<span class="number">3</span>])(<span class="type">const</span> <span class="type">double</span>* ,<span class="type">int</span>)=&#123;f1,f2,f3&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>[3]</code>的位置，<strong>pa</strong>是一个包含三个元素的数组，所以首先要使用<strong>pa[3]</strong>，然后由于<strong>[]</strong>的优先级高于<em>的优先级，所以<strong>不需要加括号</strong>，所以 **</em>pa[3]**是一个包含三个指针的数组，之后小括号括住，左右两边分别加上返回值和特征标</p>
<p>(C11)这里不能使用自动类型auto来自动获取pa的类型（因为<strong>auto只能用于单值初始化，不能用于初始化列表</strong>），但是可以在已经声明pa之后，使用自动类型来初始化同样的指针数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pb = pa；</span><br></pre></td></tr></table></figure>
<h2 id="8-函数探幽"><a href="#8-函数探幽" class="headerlink" title="8.函数探幽"></a>8.函数探幽</h2><h3 id="8-1内联函数"><a href="#8-1内联函数" class="headerlink" title="8.1内联函数"></a>8.1内联函数</h3><p>内联函数<strong>比常规函数运行更快</strong>，但是会<strong>占用更多的内存</strong>，如果程序在10个不同的地方调用了内联函数，那么就会产生10个副本。</p>
<p><strong>内联函数不能递归!!!</strong></p>
<p>程序员请求函数声明为内联函数时，编译器不一定会满足需求，<strong>当编译器认为函数过大或者注意到函数调用了他自己时，不会将他作为内联函数</strong> 。</p>
<h3 id="8-2引用变量"><a href="#8-2引用变量" class="headerlink" title="8.2引用变量"></a>8.2引用变量</h3><h4 id="8-2-1将引用作为函数参数"><a href="#8-2-1将引用作为函数参数" class="headerlink" title="8.2.1将引用作为函数参数"></a>8.2.1将引用作为函数参数</h4><p>将引用作为函数参数成为按引用传递，按引用传递允许被调用的函数能够访问调用函数中的变量</p>
<p>相对于按值传递（需要拷贝整份数据），按引用传递可以提高效率，节省空间，并且避免了使用指针</p>
<h3 id="8-3默认参数"><a href="#8-3默认参数" class="headerlink" title="8.3默认参数"></a>8.3默认参数</h3><h4 id="8-3-1声明和定义带默认参数的函数"><a href="#8-3-1声明和定义带默认参数的函数" class="headerlink" title="8.3.1声明和定义带默认参数的函数"></a>8.3.1声明和定义带默认参数的函数</h4><p>注意<strong>只有在函数声明时需要提供默认参数，函数定义时和没有默认参数时完全相同</strong></p>
<p>并且<strong>带参数的形参必须在不带参数的形参之后</strong></p>
<h4 id="8-3-2调用带默认参数的函数"><a href="#8-3-2调用带默认参数的函数" class="headerlink" title="8.3.2调用带默认参数的函数"></a>8.3.2调用带默认参数的函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a=<span class="number">1</span>,<span class="type">int</span> b=<span class="number">2</span>,<span class="type">int</span> c=<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优先使用实参，实参数量不足时使用默认参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>();<span class="comment">//func(1,2,3)</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">11</span>);<span class="comment">//func(11,2,3)</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">22</span>,<span class="number">33</span>);<span class="comment">//func(22,33,3)</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">444</span>,<span class="number">555</span>,<span class="number">666</span>);<span class="comment">//func(444,555,666)</span></span><br></pre></td></tr></table></figure>
<h3 id="8-4函数重载"><a href="#8-4函数重载" class="headerlink" title="8.4函数重载"></a>8.4函数重载</h3><p>函数重载让你能够使用多个同名的函数，只要他们的特征标的种类和顺序不完全相同</p>
<h4 id="8-4-1注意事项"><a href="#8-4-1注意事项" class="headerlink" title="8.4.1注意事项"></a>8.4.1注意事项</h4><p>注意，编译器在检查特征标时，将类型引用和类型本身视为同一个特征标</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;<span class="comment">//会导致二义性</span></span><br></pre></td></tr></table></figure>
<p>如果传入一个int类型的实参，那么会由于二义性导致编译失败</p>
<h4 id="8-4-2重载引用参数"><a href="#8-4-2重载引用参数" class="headerlink" title="8.4.2重载引用参数"></a>8.4.2重载引用参数</h4><p>类设计和STL经常使用引用参数，因此知道不同引用类型的重载很有用，比如下面三个原型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(<span class="type">double</span> &amp; r1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sank</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp; r2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sunk</span><span class="params">(<span class="type">double</span> &amp;&amp; r3)</span></span>;</span><br></pre></td></tr></table></figure>
<p>左值引用参数r1与可修改的左值参数(如double)匹配</p>
<p>const左值引用参数r2与可修改的左值参数、const左值参数和右值参数（如两个double值的和）匹配</p>
<p>右值引用参数r3与右值匹配。</p>
<p>注意到r1和r3匹配的参数都与r2匹配</p>
<p>所以如果重载这三个函数，会调用最合适的版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">stove</span><span class="params">(<span class="type">double</span> &amp; r1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stove</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp; r2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stove</span><span class="params">(<span class="type">double</span> &amp;&amp; r3)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这让我们能够根据参数是左值，const还是右值来定制函数的行为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stove</span>(x);<span class="comment">//调用stove(double &amp; r1);</span></span><br><span class="line"><span class="built_in">stove</span>(pi);<span class="comment">//调用stove(const double * r2);</span></span><br><span class="line"><span class="built_in">stove</span>(x+pi);<span class="comment">//调用stove(double &amp;&amp; r3);</span></span><br></pre></td></tr></table></figure>
<p>如果没用定义函数stove(double &amp;&amp;),stove(x+pi)则会调用函数stove(double &amp;)</p>
<h4 id="8-4-3何时使用函数模板"><a href="#8-4-3何时使用函数模板" class="headerlink" title="8.4.3何时使用函数模板"></a>8.4.3何时使用函数模板</h4><p>只有当函数基本上执行相同任务，但使用不同形式的数据时进行函数重载</p>
<h3 id="8-5函数模板"><a href="#8-5函数模板" class="headerlink" title="8.5函数模板"></a>8.5函数模板</h3><p>如果需要将同一种算法应用于不同类型的函数，使用模板来节省需要编写的代码量，比并且提高代码的重用性</p>
<h4 id="8-5-1声明和定义函数模板"><a href="#8-5-1声明和定义函数模板" class="headerlink" title="8.5.1声明和定义函数模板"></a>8.5.1声明和定义函数模板</h4><p>在C++98之前，用关键字class来替代typename创建模板，如果不考虑向下兼容性，那么最好使用typename来创建模板</p>
<p>模板并不创建任何函数，只是在<strong>告诉编译器如何定义函数</strong>，当需要用来交换int的函数时，编译器将按照模板来创建相应的函数，同样需要用来交换double的函数时，则会再创建另一个函数</p>
<p>注意：函数模板并不能缩短可执行程序，最终的代码不会包含任何模板，使用模板的好处是可以使定义更简单，更可靠</p>
<p>通常将模板放在头文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(AnyType &amp;a,AnyType &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AnyType temp;</span><br><span class="line">    temp a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-5-2重载的模板"><a href="#8-5-2重载的模板" class="headerlink" title="8.5.2重载的模板"></a>8.5.2重载的模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span>&#123;cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T *a,T *b,<span class="type">int</span> n)</span></span>&#123;cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> x=<span class="number">2</span>,y=<span class="number">3</span>;</span><br><span class="line">   <span class="type">int</span> arrx[]=&#123;<span class="number">2</span>&#125;;</span><br><span class="line">   <span class="type">int</span> arry[]=&#123;<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="type">int</span> num=<span class="number">4</span>;</span><br><span class="line">   <span class="built_in">Swap</span>(x,y);</span><br><span class="line">   <span class="built_in">Swap</span>(arrx,arry);</span><br><span class="line">   <span class="built_in">Swap</span>(arrx,arry,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第10行代码传入了两个int类型的参数，使用第一个模板</p>
<p>11行传入两个int*类型的参数，但是因为只有两个参数，不符合第二个模板，所以仍然使用第一个模板</p>
<p>12行传入两个int*类型的参数和一个int类型的参数，使用第二个模板</p>
<h4 id="8-5-2模板的局限性"><a href="#8-5-2模板的局限性" class="headerlink" title="8.5.2模板的局限性"></a>8.5.2模板的局限性</h4><p>同一个模板在接收不同的数据类型时会用相同的代码去执行，但有时候某些运算是不适用于所有数据类型的，</p>
<p>如下面代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数据类型是地址时，模板中的&gt;变得不再适用。</p>
<p>有时会出现意想不到的结果。比如运算符*在处理int，double等类型时，表示乘法，而如果数据类型是一个指针，那么将会变成解引用的意思</p>
<h4 id="8-5-3显式具体化"><a href="#8-5-3显式具体化" class="headerlink" title="8.5.3显式具体化"></a>8.5.3显式具体化</h4><p>当编译器找到与函数调用匹配的具体化定义的时候，将使用该定义，而不再寻找模板</p>
<p>对于给定的函数名，可以有非模板函数，模板函数和显示具体化模板函数以及它们的重载版本</p>
<p>显示具体化的原型和定义应该以template&lt;&gt;打头，并通过名称来指出类型</p>
<p>具体化优先于常规模板，非模板函数又优先于具体化和常规模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">job</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(job &amp;,job &amp;)</span></span>;<span class="comment">//非模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;,T &amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">Swap</span>&lt;job&gt;(job &amp;,job &amp;);<span class="comment">//显示具体化模板函数</span></span><br></pre></td></tr></table></figure>
<p><job>是可选的，因为后面的参数类型已经表明了这是job的一个具体化。所以可以省去不写</p>
<h4 id="8-5-4具体化和实例化"><a href="#8-5-4具体化和实例化" class="headerlink" title="8.5.4具体化和实例化"></a>8.5.4具体化和实例化</h4><p>最初，，编译器只能通过隐式实例化来使用模板生成函数定义，但现在C++还允许显式实例化，这意味着可以直接命令编译器创建特定的实例，如Swap<int>()，语法是，用&lt;&gt;声明所需的种类，然后在声明前加上关键字templat</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>,<span class="type">int</span>);<span class="comment">//显示实例化</span></span><br></pre></td></tr></table></figure>
<p>还有一种叫显示具体化，声明如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>,<span class="type">int</span>);<span class="comment">//显示具体化</span></span><br></pre></td></tr></table></figure>
<p>显示具体化的意思是“不要使用Swap()模板来生成函数定义，而应该使用专门为int类型显式地定义的函数定义”。这些原型必须又自己的函数定义，显式具体化声明在关键字template后面包含一个&lt;&gt;，而显式具体化没有</p>
<p>警告：<strong>在同一文件（或者转换单元）中，同时使用同一种类型的显式实例和显式具体化将出错</strong></p>
<p><strong>创建自定义选择：</strong><br>在有些情况下，可以通过编写合适的函数调用来引导编译器做出自己希望的选择。</p>
<p>在main函数中，17行调用#2，18行调用double类型的#1，19行为int类型的#1，20为int类型的#1（哪怕传入的是double类型的参数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">lesser</span><span class="params">(T a,T b)</span></span>&#123;<span class="comment">//#1</span></span><br><span class="line">	<span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lesser</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="comment">//#2</span></span><br><span class="line">	a = a&lt;<span class="number">0</span>?-a:a;</span><br><span class="line">	b=b&lt;<span class="number">0</span>?-b:b;</span><br><span class="line">	<span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="type">int</span> m = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">-30</span>;</span><br><span class="line">	<span class="type">double</span> x = <span class="number">-15.5</span>;</span><br><span class="line">	<span class="type">double</span> y = <span class="number">25.9</span>;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">lesser</span>(m,n)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">lesser</span>(x,y)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;lesser&lt;&gt;(m,n)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">lesser</span>&lt;<span class="type">int</span>&gt;(x,y)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-内存模型和名称空间"><a href="#9-内存模型和名称空间" class="headerlink" title="9.内存模型和名称空间"></a>9.内存模型和名称空间</h2><h3 id="9-1单独编译"><a href="#9-1单独编译" class="headerlink" title="9.1单独编译"></a>9.1单独编译</h3><p><strong>不要将函数定义或者变量声明放在头文件里面</strong>，否则当两个以上的文件包含该头文件的时候，除非函数是内联的，否则将会出错</p>
<p><strong>不要使用include来包含源文件代码，这样做会导致多重声明</strong></p>
<p>翻译单元（一般为一个文件为一个翻译单元）</p>
<h3 id="9-2存储持续性，作用域和链接性"><a href="#9-2存储持续性，作用域和链接性" class="headerlink" title="9.2存储持续性，作用域和链接性"></a>9.2存储持续性，作用域和链接性</h3><p>c++使用了三种（c++11之后是4种）方案来存储数据，区别在于数据保存在内存中的时间</p>
<p><strong>自动存储持续性</strong>：在函数中声明的变量（包括函数参数），在程序开始执行函数或者代码块的时候被创建，执行完函数或者代码块的时候被释放 。</p>
<p><strong>静态存储持续性</strong>：在函数外定义的变量和使用关键字static定义的变量都为静态的，他们在程序的整个运行过程中都存在</p>
<p><strong>线程存储持续性（c++11）</strong>：变量使用<strong>thread_local</strong>声明的，那么他的生命周期就和他所属的线程一样长<strong>（并行编程）</strong></p>
<p><strong>动态存储持续性</strong>：用new运算符分配的内存会一直存在，直到程序使用delete运算符来释放掉或者程序结束。这种内存也称为动态内存（free store）或者堆（heap）</p>
<h4 id="9-2-1作用域和链接"><a href="#9-2-1作用域和链接" class="headerlink" title="9.2.1作用域和链接"></a>9.2.1作用域和链接</h4><p><strong>作用域描述了名称在文件（翻译单元）中多大范围可见</strong>，<strong>链接性描述了名称如何在不同的单元间共享</strong></p>
<p>链接性为外部的名称可以在文件之间共享，里娜姬恶行为内部的名称只能由一个文件中的函数共享，自动变量的名称没有链接性，他们不能共享。</p>
<p>在名称空间中声明的变量的作用域为整个名称空间（全局作用域就是名称空间作用域的特例）</p>
<h4 id="9-2-2自动存储持续性"><a href="#9-2-2自动存储持续性" class="headerlink" title="9.2.2自动存储持续性"></a>9.2.2自动存储持续性</h4><p>在函数中创建的变量默认为自动类型变量，</p>
<p><strong>auto关键字：</strong>在<strong>c++11之前</strong>可以使用auto在定义时标明这是个自动类型的变量（由于只能用于默认是自动的变量，所以没有实际作用，只用来提醒），<strong>在C++11之后，</strong>auto变为一种类型，用来自动判断变量应为什么类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>];<span class="comment">//一个数组指针</span></span><br><span class="line"><span class="keyword">auto</span> p2=p;<span class="comment">//和p类型一样的数组指针</span></span><br></pre></td></tr></table></figure>
<p>register寄存器变量</p>
<p>使用register定义的变量是寄存器变量，他会<strong>建议</strong>编译器使用CPU寄存器来存储自动变量，在C++11中，失去了这种提示作用，register只能用来标明这是个自动类型的变量（虽然这个变量本身就是自动类型的）</p>
<h4 id="9-2-3静态持续变量"><a href="#9-2-3静态持续变量" class="headerlink" title="9.2.3静态持续变量"></a>9.2.3静态持续变量</h4><p>static定义的函数是静态的，存储在静态存储区，有两个主要用法：<br>1.在函数中定义变量时加上static，来改变这个变量的生存周期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sum;</span><br><span class="line">sum++;<span class="comment">//每当调用这个函数的时候，sum继承上一次的值，而不是重新开始</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">add</span>();<span class="comment">//执行完之后sum为1（但是在main函数中不可见）</span></span><br><span class="line"><span class="built_in">add</span>();<span class="comment">//sum为2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.在全局区定义变量时加上static，会将链接性从外部改为内部，即其他文件（翻译单元）不可见。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> global;<span class="comment">//链接性为外部，所有编译的文件都可见</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> one_file;<span class="comment">//链接性为内部，只有本文件可见</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">add</span>();<span class="comment">//执行完之后sum为1（但是在main函数中不可见）</span></span><br><span class="line">	<span class="built_in">add</span>();<span class="comment">//sum为2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-4静态持续性，外部链接性"><a href="#9-2-4静态持续性，外部链接性" class="headerlink" title="9.2.4静态持续性，外部链接性"></a>9.2.4静态持续性，外部链接性</h4><p><strong>单定义规则</strong></p>
<p>C++有两种变量声明：一种是<strong>定义声明（defining declaration）</strong>或 称<strong>定义（definition）</strong>；另一种是<strong>引用声明（referencing declaration）</strong>或称<strong>声明（declaration）</strong>。</p>
<p><strong>一个变量可以有多个声明，但只能有一个定义。</strong></p>
<p>使用关键字extern来进行<strong>引用声明</strong>，（只声明不引用）不进行初始化。否则就会定义。</p>
<p>由于单定义规则，所以只需要在一个文件包含该变量的定义，在其他所有文件中用extern声明他。</p>
<p>tips:如果在定义时对一个变量进行了初始化，那么即使加上extern那么这也是一个定义而不是声明</p>
<h4 id="9-2-5静态持续性，内部链接性"><a href="#9-2-5静态持续性，内部链接性" class="headerlink" title="9.2.5静态持续性，内部链接性"></a>9.2.5静态持续性，内部链接性</h4><p>如果一个文件中，同时有外部静态变量和static修饰的内部静态变量，那么内部静态变量会将外部静态变量隐藏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1</span></span><br><span class="line"><span class="type">int</span> i1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//file2</span></span><br><span class="line"><span class="type">int</span> i1 = <span class="number">6</span>;<span class="comment">//不被允许，违反了单定义规则</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i1 = <span class="number">7</span>;<span class="comment">//允许，会隐藏掉file1中的i1</span></span><br></pre></td></tr></table></figure>
<h4 id="9-2-6静态存储持续性，无链接性"><a href="#9-2-6静态存储持续性，无链接性" class="headerlink" title="9.2.6静态存储持续性，无链接性"></a>9.2.6静态存储持续性，无链接性</h4><p>也就是静态局部变量。（在函数中使用static定义的变量）</p>
<h4 id="9-2-7说明符和限定符"><a href="#9-2-7说明符和限定符" class="headerlink" title="9.2.7说明符和限定符"></a>9.2.7说明符和限定符</h4><p>存储说明符：<br>auto（在C++11中已经不再是说明符），register（C++11中无实际作用），static，extern，thread_local（C++11新增，用于多线程中），mutable（与const对应，含义大致相反）</p>
<ol>
<li><strong>cv-限定符：const，volatile</strong></li>
</ol>
<p>const表示代码无法改变该值，volatile表示即使代码没有对内存单元进行修改，它的值仍然可能会改变，主要用来提醒编译器不要对该变量进行编译优化，直接存取该地址的值，以免出错。一般用在1）并行设备的硬件寄存器中。2）中断服务程序中修改的供其他程序检测的变量，需要加volatile3）多任务下各任务间共享的标志。4）存储器映射的硬件寄存器。</p>
<ol>
<li><strong>multable</strong></li>
</ol>
<p>它表示，即使结构体或者类的变量被定义为const，但其中某个被multable修饰的成员变量仍然是可以修改的。</p>
<ol>
<li><strong>const！！</strong></li>
</ol>
<p>对于一个全局变量，使用const修饰后会将他的链接性从外部变为内部（就像加了static一样）。这样方便将const的变量定义放在头文件中，此时内部链接性会保证不会违反单一定义原则。</p>
<p>如果想要让一个常量的链接性为外部，那么可以在加上extern，但只需要对一个文件中的const变量进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> one_file = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> all_files = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-8函数和链接性"><a href="#9-2-8函数和链接性" class="headerlink" title="9.2.8函数和链接性"></a>9.2.8函数和链接性</h4><p>函数也有链接性，，但是比变量可选择的范围要小，由于C++不允许在函数中定义另一个函数，所以函数的存储性都是静态的。在默认情况下函数的链接性为外部的。也可以使用static将一个函数的链接性转换为内部的。在函数的声明和定义中都需要有static关键字</p>
<h4 id="9-2-9语言链接性"><a href="#9-2-9语言链接性" class="headerlink" title="9.2.9语言链接性"></a>9.2.9语言链接性</h4><p>链接程序要求每一个函数都有自己的符号名，在C++中存在重载，所以会存在相同名字的函数，但是相同函数名的重载函数也有不同的符号名。C++将重载函数名字转换为符号名的过程叫做C++语言链接性。</p>
<p>可以用函数原型来指出使用什么约定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">spiff</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//使用C的语言链接约定</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">spoff</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//使用C++的语言链接约定</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> <span class="function"><span class="type">void</span> <span class="title">spaff</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//使用C++的语言链接约定</span></span><br></pre></td></tr></table></figure>
<h3 id="9-3名称空间"><a href="#9-3名称空间" class="headerlink" title="9.3名称空间"></a>9.3名称空间</h3><p>名称空间可以是全局的，也可以位于另一个名称空间之中，但不能位于代码块之中。</p>
<p>在默认情况下，名称空间的链接性是外部的，除非他引用了变量。</p>
<h4 id="9-3-1using声明和using编译指令"><a href="#9-3-1using声明和using编译指令" class="headerlink" title="9.3.1using声明和using编译指令"></a>9.3.1using声明和using编译指令</h4><p>使用using声明会将名称添加到局部声明区域内，会和其他局部变量一样，将覆盖同名的全局变量</p>
<p>using编译指令会将整个名称空间的所有名称都可用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> aaa&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> aaa::a;<span class="comment">//using声明</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> aaa;<span class="comment">//using编译指令</span></span><br></pre></td></tr></table></figure>
<p><strong>安全性比较：</strong></p>
<p>using声明只会引入一个变量，当出现同名时，会导致报错提醒。更安全</p>
<p>using编译指令则会全部导入变量名字，如果遇到同名则会跳过导入（局部版本隐藏掉名字空间版本）不会报错，这样可能会出现意想不到的结果</p>
<p>所以在导入名字时，最好使用using声明(using std::cout)或者作用域解析运算符（std::cout）</p>
<h2 id="10-对象和类"><a href="#10-对象和类" class="headerlink" title="10.对象和类"></a>10.对象和类</h2><h3 id="10-1抽象和类"><a href="#10-1抽象和类" class="headerlink" title="10.1抽象和类"></a>10.1抽象和类</h3><p>对于一个类型的确定，需要完成三项工作：</p>
<p>1.决定数据对象需要的内存数量</p>
<p>2.决定如何解释内存的位</p>
<p>3.决定可使用数据对象执行的操作或方法</p>
<p>对于内置类型，有关操作隐藏在编译器中，对于用户自定义类型，需要自己定义这些内容。</p>
<h4 id="10-1-1访问控制"><a href="#10-1-1访问控制" class="headerlink" title="10.1.1访问控制"></a>10.1.1访问控制</h4><p>类提供了三种访问控制，用来表示成员变量或者成员函数能够怎样被访问（默认为private）</p>
<p><strong>private</strong>（私有）：只能通过公有成员函数或者友元函数来访问对象的私有成员</p>
<p><strong>protected</strong>（保护）：允许本类和本类的派生类访问。</p>
<p><strong>public</strong>（公有）允许任意访问。</p>
<p>类设计应该尽可能将公有接口和实现细节分开，（数据隐藏），这让类在被使用时无需关心内部实现，只需注重如何使用接口。</p>
<h4 id="10-1-2类成员函数"><a href="#10-1-2类成员函数" class="headerlink" title="10.1.2类成员函数"></a>10.1.2类成员函数</h4><p>注意：成员函数如果在类的声明中就被定义，那么这个函数会自动成为内联函数，而如果在类内声明，类外定义，就是普通的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person1</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> age;&#125;<span class="comment">//内联函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">person1::getheight</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> height;&#125;<span class="comment">//非内联函数</span></span><br></pre></td></tr></table></figure>
<h3 id="10-2类的构造函数和析构函数"><a href="#10-2类的构造函数和析构函数" class="headerlink" title="10.2类的构造函数和析构函数"></a>10.2类的构造函数和析构函数</h3><h4 id="10-2-1构造函数的使用"><a href="#10-2-1构造函数的使用" class="headerlink" title="10.2.1构造函数的使用"></a>10.2.1构造函数的使用</h4><p>构造函数相对于其他成员函数有以下特点：<br>1.没有返回值（也不写void）<br>2.名称和类名一样<br>3.在实例化对象时自动调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> height1,<span class="type">int</span> age1)&#123;height=height1;age=age1;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在构造函数中可以使用初始化列表来初始化数据成员，并且需要注意的是，<strong>这些项目被初始化的顺序是他们被声明的顺序而不是在他们在初始化列表中的顺序</strong></p>
<p>初始化列表为在函数头后面跟冒号，然后以<strong>项目1 (形参1)</strong>的形式表示将形参1赋值给项目1，并且各单元之间用逗号分隔开</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">person</span>(<span class="type">int</span> height1,<span class="type">int</span> age1):<span class="built_in">age</span>(age1),<span class="built_in">height</span>(height1)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>调用构造函数的两种方法：<br>1.<strong>显式调用：</strong><br>person p1 = person(1,2)<br>2.<strong>隐式调用</strong><br>person p1(1,2);</p>
<h4 id="10-2-2析构函数"><a href="#10-2-2析构函数" class="headerlink" title="10.2.2析构函数"></a>10.2.2析构函数</h4><p>在对象被释放的时候，会自动调用析构函数，</p>
<p>通常不应该在代码中显示地调用析构函数</p>
<p>使用~加类名来定义析构函数。</p>
<p>当构造函数中用到new来分配空间时，析构函数需要使用delete来释放空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">person</span>()&#123;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">30</span>];&#125;</span><br><span class="line">   ~<span class="built_in">person</span>()&#123;<span class="keyword">delete</span>[] name;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">char</span>* name;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-2-3const成员函数"><a href="#10-2-3const成员函数" class="headerlink" title="10.2.3const成员函数"></a>10.2.3const成员函数</h4><p>在函数的括号后面加上const的函数是const成员函数，这样的函数不被允许修改他所调用的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">//const成员函数</span></span><br><span class="line">      cout&lt;&lt;height&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>就像尽可能将const引用和指针用作函数形参那样，当一个成员函数不需要修改对象的值时，就应该让他成为const成员函数。</p>
<h4 id="10-2-4其他"><a href="#10-2-4其他" class="headerlink" title="10.2.4其他"></a>10.2.4其他</h4><p>上文提到了两种实例化对象并初始化的方法，下面说一下他们之间细节上的区别</p>
<p>1.显式调用：</p>
<p>person p1 = person(1,2)</p>
<p>2.隐式调用</p>
<p>person p1(1,2);</p>
<p>对于第一种调用方法，编译器可以有两种处理情况。一是和第二种隐式调用一样直接生成p1并调用构造函数。二是可能会先生成临时变量，再把这个临时变量赋值给p1，再删除掉临时变量（可能会立刻删除，也可能会等一段时间再删除），删除对象的时候会调用析构函数</p>
<p>再再注意：第一种调用方法可能会不产生临时对象，也可能会产生（编译器决定），但这只是在实例化对象的时候，如果是给对象赋值，那么就肯定会产生临时对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">//不会产生临时变量</span></span><br><span class="line">person p2 = <span class="built_in">person</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//可能会产生临时变量，可能不会</span></span><br><span class="line">p1 = <span class="built_in">person</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//一定会产生临时变量</span></span><br></pre></td></tr></table></figure>
<p>如果既可以通过初始化，也可以通过赋值的方式来设置对象的值，那么最好使用初始化的方式，因为这样可以提升效率</p>
<h3 id="10-3this指针"><a href="#10-3this指针" class="headerlink" title="10.3this指针"></a>10.3this指针</h3><p>所有成员函数（包括构造函数和析构函数，不包括静态成员函数）都内置了一个this指针，this指针指向用来调用函数的成员函数的对象。</p>
<p>对于常成员函数（即在函数括号后面加上const）本质上是将this指针用const修饰。</p>
<p>如果一个方法要引用整个调用对象，那么可以使用<em>this<strong>作为调用对象的别名</strong>来完成前面方法的定义，（</em>this是调用对象的一个引用而不是一个副本）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> person &amp; <span class="title">comage</span><span class="params">(<span class="type">const</span> person &amp; p1)</span> <span class="type">const</span></span>&#123;<span class="comment">//compare age</span></span><br><span class="line">  <span class="keyword">if</span>(p<span class="number">1.</span>age&gt;<span class="keyword">this</span>-&gt;age) <span class="keyword">return</span> p1;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-4对象数组"><a href="#10-4对象数组" class="headerlink" title="10.4对象数组"></a>10.4对象数组</h3><p>在声明对象数组的时候，和声明一般数据类型的数组相同。直接使用中括号，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person pp[<span class="number">10</span>];<span class="comment">//声明和定义对象数组</span></span><br></pre></td></tr></table></figure>
<p>如果没有给定参数，会自动调用默认构造函数。</p>
<p>可以使用构造函数来对数组进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person pp[<span class="number">10</span>]&#123;</span><br><span class="line">  <span class="built_in">person</span>(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">  <span class="built_in">person</span>(<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">  <span class="built_in">person</span>(<span class="number">4</span>,<span class="number">4</span>),</span><br><span class="line">&#125;;<span class="comment">//声明和定义对象数组</span></span><br></pre></td></tr></table></figure>
<p>上文中的三个构造函数会分别用来初始化pp[0],pp[1],pp[2].之后的元素会使用默认构造函数来初始化。</p>
<p>初始化队型数组的方案是，先使用默认构造函数创建数组元素，用花括号中的构造函数创建临时对象，再将临时对象复制到响应的元素中，所以所以，<strong>想要创建对象数组，就必须有默认构造函数</strong></p>
<h3 id="10-5类作用域"><a href="#10-5类作用域" class="headerlink" title="10.5类作用域"></a>10.5类作用域</h3><p>在类内定义的名称的作用域是整个类，作用域为整个类的名称只在该类中是已知的。</p>
<p>在其他情况下使用类中的名称时，需要根据上下文使用<strong>直接成员运算符（.）、间接成员运算符（-&gt;）、或者作用域解析运算符（::）</strong>等</p>
<h4 id="10-5-1作用域为类的常量"><a href="#10-5-1作用域为类的常量" class="headerlink" title="10.5.1作用域为类的常量"></a>10.5.1作用域为类的常量</h4><p>有时候需要在类中定义一个常量。在C++11之前下面这样写是无法通过编译的。而在C++11之后也最好不要这么写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> allowage = <span class="number">18</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可以使用两种其他方法来实现，</p>
<p>1.使用枚举类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">enum</span> &#123;allowage = <span class="number">18</span>&#125;;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>这之中的pi只是一个符号常量，在编译的时候遇到allowage会用18来替换,并且只用用于整数常数（因为枚举类型不允许存在小数）</p>
<p>2.使用static修饰的const成员常量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> allowage = <span class="number">18</span>;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>上面两种方式创建的成员常量都是公共的，<strong>不属于任何对象</strong>，所以即使他的访问权限是public，也不能使用成员运算符（.和-&gt;)来引用常量。而应该用作用域解析符</p>
<h4 id="10-5-2作用域内枚举（C-11）"><a href="#10-5-2作用域内枚举（C-11）" class="headerlink" title="10.5.2作用域内枚举（C++11）"></a>10.5.2作用域内枚举（C++11）</h4><p>传统的枚举不允许在不同的枚举中使用相同的关键字。如下代码在c++11之前是不被允许的。如下面的代码；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">egg</span>&#123;Small,Medium,Large&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">shirt</span>&#123;Small,Large,Super_Large&#125;;<span class="comment">//C++11之前不允许这么写，因为Small和Large存在二义性</span></span><br></pre></td></tr></table></figure>
<p>在C++11之后，可以令枚举的作用域为类（结构stuct也可以），用法是在enum和枚举名称的中间加上class关键字（或者stuct）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11之后允许这么写</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">egg</span>&#123;Small,Medium,Large&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">shirt</span>&#123;Small,Large,Super_Large&#125;;</span><br></pre></td></tr></table></figure>
<p>但是如果一个enum被定义为类枚举类型。那么就不能作为右值赋给int类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egg egg1 = egg::Large;<span class="comment">//可以~</span></span><br><span class="line"><span class="type">int</span> temp = egg::Large;<span class="comment">//不可以！</span></span><br></pre></td></tr></table></figure>
<p>但在必要的时候可以进行显式转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="built_in">int</span>(egg::Large);</span><br></pre></td></tr></table></figure>
<h2 id="11-使用类"><a href="#11-使用类" class="headerlink" title="11.使用类"></a>11.使用类</h2><h3 id="11-1运算符重载"><a href="#11-1运算符重载" class="headerlink" title="11.1运算符重载"></a>11.1运算符重载</h3><h4 id="11-1-1运算符重载的使用"><a href="#11-1-1运算符重载的使用" class="headerlink" title="11.1.1运算符重载的使用"></a>11.1.1运算符重载的使用</h4><p>为了让对象操作更加美观，可以对运算符进行重载，C++允许将运算符䗏扩展到用户定义的类型当中。比如通过重载来让+（加号运算符）能够对两个对象进行相加。</p>
<p>运算符函数的格式如下：</p>
<p>operatorop(argument-list)</p>
<p>其中括号前的两个字母op应该被替换为一个运算符，括号内写参数列表。 例如：operator+()重载了加号运算符</p>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>&#123;<span class="comment">//定义一个时间类，用h，m，s来表示时间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Time</span>(<span class="type">int</span> h = <span class="number">0</span>,<span class="type">int</span> m = <span class="number">0</span>,<span class="type">int</span> s = <span class="number">0</span>)&#123;hour = h;minute=m;second = s;&#125;</span><br><span class="line">   Time <span class="keyword">operator</span>+(Time &amp; t)&#123;</span><br><span class="line">      <span class="type">int</span> sum = t.hour*<span class="number">3600</span>+t.minute*<span class="number">60</span>+t.second+<span class="keyword">this</span>-&gt;hour*<span class="number">3600</span>+<span class="keyword">this</span>-&gt;minute*<span class="number">60</span>+<span class="keyword">this</span>-&gt;second;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Time</span>(sum/<span class="number">3600</span>,(sum%<span class="number">3600</span>)%<span class="number">60</span>,sum%<span class="number">60</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在上面的代码中应该注意的是，<strong>返回的不能是一个对象的引用，</strong>而应该是一个对象，因为在函数中创建的对象在函数结束时就会被释放，引用也就无法起作用。</p>
<h4 id="11-1-2注意事项"><a href="#11-1-2注意事项" class="headerlink" title="11.1.2注意事项"></a>11.1.2注意事项</h4><p>1。<strong>重载的运算符函数所接受的参数数量必须和运算符本身的操作数一一对应</strong>，（比如加法运算符有两个值，那么参数就必须是两个）</p>
<p>2.如果运算符重载函数<strong>作为成员函数，那么传入的参数需要减少一个</strong>，因为对象本身（*this）始终会作为第一个参数。</p>
<p>3.重载的运算符函数不能所有操作数都是基本类型，<strong>必须包含一个自定义类型</strong>（编译不会通过，为了防止随意重载导致的严重后果）</p>
<p>4.不能重载以下运算符：</p>
<p>sizeof(sizeof运算符）.(一个点，成员运算符) .*(一个点一个星，成员指针运算符)::( 作用域解析运算符）?:(一个问号一个冒号，条件运算符)typeid( 一个RTTI运算符）const_cast(强制类型转换运算符）dynamic_castreinterpret_caststatic_cast</p>
<p>5.以下运算符必须通过成员函数重载：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>=(赋值运算符)</th>
</tr>
</thead>
<tbody>
<tr>
<td>（）（左右括号，函数调用运算符）</td>
</tr>
<tr>
<td>[]（左右中括号，下标运算符）</td>
</tr>
<tr>
<td>-&gt;（通过指针访问类成员的运算符）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="11-2友元"><a href="#11-2友元" class="headerlink" title="11.2友元"></a>11.2友元</h3><p>友元有三种，<strong>友元类，友元函数，友元成员函数。</strong></p>
<p>让函数成为类的友元，可以让他拥有和成员函数一样的访问权限</p>
<h4 id="11-2-1为什么要使用友元函数"><a href="#11-2-1为什么要使用友元函数" class="headerlink" title="11.2.1为什么要使用友元函数"></a>11.2.1为什么要使用友元函数</h4><p>在为类重载二元运算符的时候经常需要用到友元</p>
<p>比如想要重载加号运算符，使其左操作数是一个int类型，右操作数是Time类</p>
<p>1.对于重载运算符<strong>成员函数</strong>，第一个参数必须是对象本身，所以无法实现目的。</p>
<p>2.对于一个<strong>非成员函数</strong>的运算符重载函数，则又没有类的访问权限，编写起来复杂</p>
<p>通过友元函数可以解决上述问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>&#123;<span class="comment">//定义一个时间类，用h，m，s来表示时间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Time</span>(<span class="type">int</span> h = <span class="number">0</span>,<span class="type">int</span> m = <span class="number">0</span>,<span class="type">int</span> s = <span class="number">0</span>)&#123;hour = h;minute=m;second = s;&#125;</span><br><span class="line">   <span class="keyword">friend</span> Time <span class="keyword">operator</span>+(<span class="type">int</span> num,Time t);</span><br><span class="line">   <span class="keyword">friend</span> Time <span class="keyword">operator</span>+(Time t,<span class="type">int</span> num);</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>友元函数不是成员函数，所以不能用成员运算符来调用。</p>
<p>友元函数需要访问哪个类的成员，就成为哪个类友元函数，而其他的参数类则没必要成为友元函数。比如下面的&lt;&lt;重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,Time &amp; t);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>只需要成为Time的友元即可，不需要成为ostream的友元，因此也就不需要修改ostream的内容。</p>
<p>注意：返回值应该是ostream，而不是引用</p>
<p>*拓展：当一个ostream引用作为参数时（在上文指的是os），默认是cout对象的引用。其他的ostream对象还有cerr（表示将输出发送到标准错误流）</p>
<h3 id="11-3类的自动转换和强制类型转换"><a href="#11-3类的自动转换和强制类型转换" class="headerlink" title="11.3类的自动转换和强制类型转换"></a>11.3类的自动转换和强制类型转换</h3><p>先定义一个类作为示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">weight</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">weight</span>()&#123;&#125;</span><br><span class="line">   <span class="built_in">weight</span>(<span class="type">int</span> ia)&#123;w = ia;&#125;</span><br><span class="line">   <span class="built_in">weight</span>(<span class="type">double</span> da)&#123;w = da;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">double</span> w;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-1赋值运算符的自动转换"><a href="#11-3-1赋值运算符的自动转换" class="headerlink" title="11.3.1赋值运算符的自动转换"></a>11.3.1赋值运算符的自动转换</h4><p>对于上面的weight类，有三个构造函数，分别对应了无参，有int参，有double参三种类型。</p>
<p>那么下面这种赋值方法是被允许的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   weight wei;</span><br><span class="line">   wei = <span class="number">12</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种被成为自动类型转换，这样会先生用适合的构造函数来生成一个临时对象，然后将这个临时对象赋值给wei，在上例中调用的是weight(int)构造函数（因为12是int类型的）</p>
<p>有时候这种自动转换会引起一些问题，所以可以在函数的声明中使用了关键字<strong>explicit</strong>，那么将不支持使用这个函数进行自动类型转换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">weight</span>&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">   explicit <span class="title function_">weight</span>(<span class="params">int ia</span>)&#123;w = ia;&#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>当构造函数中没有与赋值运算符右值（上文中是12）匹配的参数类型（即没有weight(int)）,那么会寻找<em>勉强合适</em>的构造函数（如weight(double)），然后通过将改变右值的类型(将12的类型改为double)来适配构造函数</p>
<p>但进行这种赋值的前提是1.<strong>使用的函数没有被explicit修饰</strong>。2<strong>.不存在二义性</strong>（比如同时有构造函数weight(double)和weight(float)，那么12就不知道要转换成double还是float）</p>
<h4 id="11-3-2强制类型转换"><a href="#11-3-2强制类型转换" class="headerlink" title="11.3.2强制类型转换"></a>11.3.2强制类型转换</h4><p>可以通过显式地调用构造函数来进行强制类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wei = <span class="built_in">weight</span>(<span class="number">12</span>);</span><br><span class="line">wei = (weight)<span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-3转换函数"><a href="#11-3-3转换函数" class="headerlink" title="11.3.3转换函数"></a>11.3.3转换函数</h4><p>上面讲到通过含有一个参数的构造函数可以将<strong>其他</strong>类型转换为<strong>类</strong>类型，那么如果要把<strong>类</strong>类型转换为<strong>其他</strong>类型，就需要用到转换函数</p>
<p>格式为：<strong>operator typeName()</strong></p>
<p>需要注意的是：<strong>1.**</strong>转换函数必须是类方法。2.转换函数不能指定返回类型。3.转换函数不能有参数。**</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">double</span>(w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">int</span>(w);&#125;</span><br></pre></td></tr></table></figure>
<p><strong>警惕二义性：</strong></p>
<p>如果同时定义了转换为int和double（或其他）的转换函数，又使用了如cout等支持多种数据类型的函数，那么会产生二义性导致编译失败。</p>
<p>可以使用<strong>显式转换来避免二义性</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">weight</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">double</span>(w);&#125;</span><br><span class="line">   <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">int</span>(w);&#125;</span><br><span class="line">   ...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">weight <span class="title">wei</span><span class="params">(<span class="number">12</span>)</span></span>;<span class="comment">//构造函数省去了</span></span><br><span class="line">   cout&lt;&lt;(<span class="type">double</span>)wei;<span class="comment">//显式转换函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>避免隐式转换的危害：</strong></p>
<p>像基本类型转换为类类型一样，同样可以使用explicit修饰转换函数来禁用隐式转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">double</span>(w);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用一个非转换函数来替代转换函数（因为非转换函数不支持隐式转换）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">int</span>(w);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">weight_to_int</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (<span class="type">int</span>)w;&#125;<span class="comment">//用这一行来替代上一行</span></span><br></pre></td></tr></table></figure>
<h2 id="12-类和动态内存分配"><a href="#12-类和动态内存分配" class="headerlink" title="12.类和动态内存分配"></a>12.类和动态内存分配</h2><p>在类构造函数中使用new运算符在程序运行的时候分配所需要的内存空间</p>
<h3 id="12-1动态内存和类"><a href="#12-1动态内存和类" class="headerlink" title="12.1动态内存和类"></a>12.1动态内存和类</h3><p>如果将new应用于类，即在构造函数中用new来为变量分配空间。那么就必须要用到析构函数，并且析构函数中应该有对应的delete来释放new申请的空间</p>
<h4 id="12-1-1静态成员变量"><a href="#12-1-1静态成员变量" class="headerlink" title="12.1.1静态成员变量"></a>12.1.1静态成员变量</h4><p>静态成员变量对于一个类，只会生成一个副本，不会随着对象数量的增多而增多。</p>
<p>注意：静态变量不能在类声明中初始化，对于多文件编程，初始化应该在类方法文件中，而不是类声明文件中。（例外：如果这个静态成员变量是cosnt整数类型或者枚举型，那么可以在类声明中初始化）</p>
<h4 id="12-1-2特殊成员变量"><a href="#12-1-2特殊成员变量" class="headerlink" title="12.1.2特殊成员变量"></a>12.1.2特殊成员变量</h4><p>C++会自动提供以下成员函数</p>
<p><strong>默认构造函数</strong>，如果没有定义构造函数</p>
<p><strong>默认析构函数</strong>，如果没有定义</p>
<p><strong>复制构造函数</strong>，如果没有定义（也称拷贝构造函数）</p>
<p><strong>赋值运算符</strong>，如果没有定义</p>
<p><strong>地址运算符，</strong>如果没有定义</p>
<p>如果一个类用到了new[].delete[]等，那么要警惕这些自动生成的成员函数造成的影响。（可能会导致构造函数中new[]和析构函数中delete[] 的调用次数不匹配）</p>
<h4 id="12-2-3复制构造函数"><a href="#12-2-3复制构造函数" class="headerlink" title="12.2.3复制构造函数"></a>12.2.3复制构造函数</h4><p>何时使用复制构造函数</p>
<p>1.按值传递对象</p>
<p>2.函数返回对象</p>
<p>3.生成临时对象</p>
<p>深拷贝和浅拷贝（深复制和浅复制）</p>
<p>默认复制函数会进行浅复制（指一个对象一个对象地进行复制），这样有时候会出错（比如将一个指针赋值给另一个指针，或者将一个地址赋值给另一个地址）</p>
<p>深拷贝需要程序员自己编写，区别在于为指针所指的内容分配额外空间来获得一份副本</p>
<h4 id="12-2-4赋值运算符"><a href="#12-2-4赋值运算符" class="headerlink" title="12.2.4赋值运算符"></a>12.2.4赋值运算符</h4><p>将一个已有的对象赋值给另一个对象的时候会使用重载的赋值运算符</p>
<p>初始化对象的时候不一样会使用赋值运算符（但总是会调用复制构造函数）</p>
<p>相比复制构造函数，赋值运算符函数与之类似，区别在于</p>
<p>1.由于目标对象可能已经引用了以前分配的数据，所以需要先使用delete[]来释放这些数据</p>
<p>2.函数应当避免自身赋值给自身，否则会导致delete[]删除掉内容</p>
<p>3.函数应该返回一个指向调用类型的引用</p>
<p>4.由于赋值运算符不生成新的对象，所以如果有一个静态变量存储了对象的数量，那么这个静态变量不需要自增。</p>
<h4 id="12-2-5关于临时对象的const问题"><a href="#12-2-5关于临时对象的const问题" class="headerlink" title="12.2.5关于临时对象的const问题"></a>12.2.5关于临时对象的const问题</h4><p>在一些函数的进行时，可能创建临时变量(比如重载后的赋值运算符）,而临时变量是自带const（无法被修改的），所以如果一个临时变量作为了一个函数的引用参数，那么这个引用参数需要加上const。（因为只有带const的引用才能够同时调用带const类型的变量或者不带const的变量，而不带const的引用只能调用不带const的变量。</p>
<p>所以<strong>如果不需要通过一个引用或指针来改变他指向的数据，那么一定要加上const</strong></p>
<h4 id="12-2-6一个关于内存分配的类实例"><a href="#12-2-6一个关于内存分配的类实例" class="headerlink" title="12.2.6一个关于内存分配的类实例"></a>12.2.6一个关于内存分配的类实例</h4><p>这个自定义类有基本的存储字符串的功能，并且会用new运算符自动分配合适的内存给字符串。用sum静态成员变量来记录目前实例化的对象数量，</p>
<p>但没有对中括号运算符[],比较运算符&lt;,&gt;,&lt;=,&gt;=,==以及加号运算符+进行重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mystring</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> sum;</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getsum</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sum;&#125;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> len;&#125;<span class="comment">//不需要修改对象数据的函数记得加const</span></span><br><span class="line">   <span class="function"><span class="type">char</span>* <span class="title">getstr</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> str;&#125;</span><br><span class="line">   <span class="comment">//默认构造函数和带参构造函数</span></span><br><span class="line">   <span class="built_in">mystring</span>(<span class="type">const</span> <span class="type">char</span>* str1=<span class="string">&quot;test&quot;</span>)&#123;len=<span class="built_in">strlen</span>(str1);str = <span class="keyword">new</span> <span class="type">char</span>[len];<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,str1);sum++;&#125;<span class="comment">//不需要更改数据的形参记得加const</span></span><br><span class="line">   <span class="comment">//复制构造函数</span></span><br><span class="line">   <span class="built_in">mystring</span>(<span class="type">const</span> mystring &amp; str1);<span class="comment">//参数列表中类引用需要加const</span></span><br><span class="line">   <span class="comment">//赋值运算符的重载函数</span></span><br><span class="line">   mystring &amp; <span class="keyword">operator</span>=(<span class="type">const</span> mystring &amp; str1);<span class="comment">//加const哦</span></span><br><span class="line">   <span class="comment">//析构函数</span></span><br><span class="line">   ~<span class="built_in">mystring</span>()&#123;<span class="keyword">delete</span>[] str;str = <span class="literal">nullptr</span>;sum--;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">char</span>* str;</span><br><span class="line">   <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> mystring::sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//复制构造函数的定义</span></span><br><span class="line">mystring::<span class="built_in">mystring</span>(<span class="type">const</span> mystring &amp; str1)&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;len = str<span class="number">1.</span><span class="built_in">getlen</span>();</span><br><span class="line">   <span class="keyword">this</span>-&gt;str = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">   <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,str<span class="number">1.</span>str);</span><br><span class="line">   sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值运算符重载函数的定义</span></span><br><span class="line">mystring &amp; mystring::<span class="keyword">operator</span>=(<span class="type">const</span> mystring &amp; str1)&#123;</span><br><span class="line">   <span class="keyword">if</span>(str<span class="number">1.</span>str==<span class="keyword">this</span>-&gt;str) <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//避免将对象赋给自身</span></span><br><span class="line">   <span class="keyword">delete</span>[] str;<span class="comment">//释放str原先所指的空间</span></span><br><span class="line">   <span class="keyword">this</span>-&gt;len = str<span class="number">1.</span><span class="built_in">getlen</span>();</span><br><span class="line">   <span class="keyword">this</span>-&gt;str = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">   <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,str<span class="number">1.</span>str);</span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#123;</span><br><span class="line">      mystring str1 = <span class="string">&quot;1111&quot;</span>;<span class="comment">//测试赋值运算符，const char*向mystring类转换的构造函数</span></span><br><span class="line">      cout&lt;&lt;mystring::<span class="built_in">getsum</span>()&lt;&lt;endl;</span><br><span class="line">      mystring str2 = str1;<span class="comment">//复制构造函数</span></span><br><span class="line">      cout&lt;&lt;mystring::<span class="built_in">getsum</span>()&lt;&lt;endl;</span><br><span class="line">      cout&lt;&lt;str<span class="number">2.</span><span class="built_in">getstr</span>()&lt;&lt;endl;</span><br><span class="line">   &#125;<span class="comment">//代码块结束了，删除所有的对象</span></span><br><span class="line">   cout&lt;&lt;mystring::<span class="built_in">getsum</span>()&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-3返回const对象"><a href="#12-3返回const对象" class="headerlink" title="12.3返回const对象"></a>12.3返回const对象</h3><h4 id="12-3-1返回指向const对象的引用"><a href="#12-3-1返回指向const对象的引用" class="headerlink" title="12.3.1返回指向const对象的引用"></a>12.3.1返回指向const对象的引用</h4><p>返回引用不会调用复制构造函数，所以运行效率更快</p>
<p>返回的引用必须在调用函数中有定义，否则会导致引用找不到目标。</p>
<p>如果一个引用是const引用，那么返回时也应该加const</p>
<h4 id="12-3-2返回指向非const的引用"><a href="#12-3-2返回指向非const的引用" class="headerlink" title="12.3.2返回指向非const的引用"></a>12.3.2返回指向非const的引用</h4><p>在以下两种情况，需要使用返回非const对象的引用，1.重载赋值运算符。2.重载于cout一起使用的&lt;&lt;</p>
<p>第一种这么做能提高效率，第二种则必须这么做</p>
<p>对于第二种情况，如果不返回 ostream &amp; 即 ostream的引用，而是返回ostream本身话，会尝试嗲用ostream的复制构造函数，而ostream类没有公有的复制构造函数。</p>
<h4 id="12-3-3返回对象"><a href="#12-3-3返回对象" class="headerlink" title="12.3.3返回对象"></a>12.3.3返回对象</h4><p>当被返回的对是调用函数的局部变量时，由于在调用函数的作用域种没有该变量，所以必须返回对象而不是返回对象的引用</p>
<h4 id="12-3-3返回const对象"><a href="#12-3-3返回const对象" class="headerlink" title="12.3.3返回const对象"></a>12.3.3返回const对象</h4><p>对于+加号重载运算符：则需要返回对象，而不是对象的引用。</p>
<p>然而返回的这个对象是可以作为左值被使用的。然而一般+加号运算符作用结果是不能作为左值的。所以可以通过返回一个const修饰的对象来禁止这种行为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mystring是一个类，str1,str2,str3都是这个类实例化的对象</span></span><br><span class="line">mystring str1;</span><br><span class="line">mystring str2;</span><br><span class="line">mystring str3;</span><br><span class="line">str1 = str1+str2;<span class="comment">//第一种使用方法</span></span><br><span class="line">str2+str1 - st3;<span class="comment">//第二种方法</span></span><br></pre></td></tr></table></figure>
<p>如果加号重载运算符返回的是一个const对象类型，那么就只能够使用第一种方法，而不能使用第二种方法</p>
<h3 id="12-4使用指向对象的指针"><a href="#12-4使用指向对象的指针" class="headerlink" title="12.4使用指向对象的指针"></a>12.4使用指向对象的指针</h3><p>如果一个指针指向了一个对象，那么同样可以使用解除引用运算符（*）来获取他指向的对象</p>
<h4 id="12-4-1使用new为对象分配内存"><a href="#12-4-1使用new为对象分配内存" class="headerlink" title="12.4.1使用new为对象分配内存"></a>12.4.1使用new为对象分配内存</h4><p>我们可以使用new为对象分配内存（并选择使用哪种构造函数），然后用一个指针来指向这个对象所在的内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mystring* pstr = <span class="keyword">new</span> <span class="built_in">mystring</span>(<span class="string">&quot;666&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在上文的例子中，先new为这个对象分配内存空间，然后调用构造函数，为对象中的字符串666使用new分配一个空间</p>
<p>当使用delete（注意对象是单个变量，所以不是使用delete[]）删除对象的时候，<strong>并不会删除在对象内所分配的空间</strong>（在这里指的是新建的用来存储666的空间，这一步会交给自定义的析构函数来完成）</p>
<h4 id="12-4-2定位new运算符和对象"><a href="#12-4-2定位new运算符和对象" class="headerlink" title="12.4.2定位new运算符和对象"></a>12.4.2定位new运算符和对象</h4><p>定位new运算符能够在分配内存的时候指定内存的位置。</p>
<p><code>C++prime plus P372</code></p>
<h2 id="13-类继承"><a href="#13-类继承" class="headerlink" title="13.类继承"></a>13.类继承</h2><p>使用类继承来更好地扩展和修改类</p>
<h3 id="13-1基类与派生类"><a href="#13-1基类与派生类" class="headerlink" title="13.1基类与派生类"></a>13.1基类与派生类</h3><h4 id="13-1-1派生一个类"><a href="#13-1-1派生一个类" class="headerlink" title="13.1.1派生一个类"></a>13.1.1派生一个类</h4><p>被继承的类叫基类，由基类派生出来的类叫派生类。</p>
<p>下面是一个基类和他的派生类的代码示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">const</span> string &amp; str = <span class="string">&quot;&quot;</span>) :<span class="built_in">str1</span>(str) &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Basefunc</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;this is Basefunc()&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string str1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ps</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Ps</span>(<span class="type">const</span> <span class="type">int</span> &amp; dat = <span class="number">0</span>,<span class="type">const</span> string &amp;str = <span class="string">&quot;0&quot;</span>): <span class="built_in">data</span>(dat),<span class="built_in">Base</span>(str) &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Psfunc</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;this is Psfunc()&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，基类是<strong>Base</strong>类，派生类是<strong>Ps</strong>类。在<strong>Ps</strong>的构造函数中使用Base的构造函数来构造继承的Base类的部分。</p>
<p>表明<strong>Base</strong>是<strong>Ps</strong>的一个公有继承。使用公有派生，<strong>基类的公有成员将成为派生类的公有成员，基类的私有部分也将成为派生类的一部分，但只能够通过基类的公有和保护方法来询问。</strong></p>
<p>在继承的时候：<br>派生类需要有自己的构造函数<br>派生类可以根据需要添加额外的成员或者函数</p>
<p><strong>注意：</strong><br>构造函数必须给新成员和记衡的成员提供数据。</p>
<h4 id="13-1-2访问权限"><a href="#13-1-2访问权限" class="headerlink" title="13.1.2访问权限"></a>13.1.2访问权限</h4><p>在创建派生类对象的时候，会先创建基类对象，嗲用基类构造函数。（如果初始化列表中没有调用基类构造函数，那么会自动调用默认构造函数）<br>所以下面两行代码等效</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码一</span></span><br><span class="line"><span class="built_in">Ps</span>(<span class="type">const</span> <span class="type">int</span> &amp; dat = <span class="number">0</span>,<span class="type">const</span> string &amp;str = <span class="string">&quot;0&quot;</span>): <span class="built_in">data</span>(dat),<span class="built_in">Base</span>() &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="built_in">Ps</span>(<span class="type">const</span> <span class="type">int</span> &amp; dat = <span class="number">0</span>,<span class="type">const</span> string &amp;str = <span class="string">&quot;0&quot;</span>): <span class="built_in">data</span>(dat) &#123;&#125;<span class="comment">//构造函数</span></span><br></pre></td></tr></table></figure>
<p>在实例化派生类对象时<strong>，先调用基类构造函数，再调用派生类构造函数</strong><br>在销毁派生类对象时，<strong>先调用派生类对象的析构函数，然后是基类对象的析构函数</strong></p>
<h4 id="13-1-3派生类和基类之间的关系"><a href="#13-1-3派生类和基类之间的关系" class="headerlink" title="13.1.3派生类和基类之间的关系"></a>13.1.3派生类和基类之间的关系</h4><p>1.派生类能够使用基类中的 <strong>公有（public</strong>）以及<strong>保护（protected）</strong>类型的成员</p>
<p>2.基类指针可以在不进行显式类型转换的情况下指向派生类对象，基类引用可以不进行显式类型转换的情况下引用派生类对象。<br>但是基类指针或者引用<strong>只能用于调用基类方法。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Ps <span class="title">p1</span><span class="params">(<span class="number">0</span>,<span class="string">&quot;111&quot;</span>)</span></span>;</span><br><span class="line">Base &amp; b1 = p1;<span class="comment">//基类引用指向派生类对象</span></span><br><span class="line">b<span class="number">1.</span><span class="built_in">Basefunc</span>();<span class="comment">//基类引用调用基类方法</span></span><br></pre></td></tr></table></figure>
<p>一个函数需要基类对象作为形参时，可以填入一个派生类对象实参</p>
<p>因此可以用派生类对象来给接类对象复制，因为会自动调用<strong>隐式重载赋值运算符函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Base &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base &amp; b1) &#123;str1 = b<span class="number">1.</span>str1;<span class="keyword">return</span> b1;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-2继承-is-a关系"><a href="#13-2继承-is-a关系" class="headerlink" title="13.2继承:is-a关系"></a>13.2继承:is-a关系</h3><p>继承分为 公有继承（public）保护继承（protected）私有继承（private）</p>
<p><strong>公有继承建立的是is-a关系</strong></p>
<ol>
<li><p>公有继承不能建立has-a关系</p>
</li>
<li><p>公有继承不能建立is-like-a关系</p>
</li>
<li>公有继承不建立is-implemented-as-a（作为…来实现）关系</li>
<li>公有继承不建立uses-a关系</li>
</ol>
<p><strong>私有继承或者包含建立has-a关系</strong></p>
<h3 id="13-3多态公有继承"><a href="#13-3多态公有继承" class="headerlink" title="13.3多态公有继承"></a>13.3多态公有继承</h3><h4 id="13-3-1使用虚方法"><a href="#13-3-1使用虚方法" class="headerlink" title="13.3.1使用虚方法"></a>13.3.1使用虚方法</h4><p>1.在派生类中重新定义基类的方法，<strong>如果派生类和基类中存在特征标相同的函数，派生类会优先调用自己定义的方法。</strong><br>2.使用<strong>虚方法virtual</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">const</span> string &amp; str = <span class="string">&quot;&quot;</span>) :<span class="built_in">str1</span>(str) &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base&quot;</span>&lt;&lt;endl;&#125;<span class="comment">//虚方法</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>()&#123;&#125;;<span class="comment">//虚析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string str1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ps</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Ps</span>(<span class="type">const</span> <span class="type">int</span> &amp; dat = <span class="number">0</span>,<span class="type">const</span> string &amp;str = <span class="string">&quot;&quot;</span>): <span class="built_in">data</span>(dat),<span class="built_in">Base</span>(str) &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Ps&quot;</span>&lt;&lt;endl;&#125;<span class="comment">//这行的virtual可以省略</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Base <span class="title">b1</span><span class="params">(<span class="string">&quot;111&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Ps <span class="title">p1</span><span class="params">(<span class="number">1</span>,<span class="string">&quot;222&quot;</span>)</span></span>;</span><br><span class="line">	Base &amp; b = p1;</span><br><span class="line">	b.<span class="built_in">func1</span>();<span class="comment">//调用Ps的函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-3-2一些注意事项"><a href="#13-3-2一些注意事项" class="headerlink" title="13.3.2一些注意事项"></a>13.3.2一些注意事项</h4><p>一、如果想要定义一个虚方法（虚函数），需要在基类的声明前加上virtual（如果定义和声明是分开的，那么定义前面不需要加），在派生类中的函数声明里可以不加virtual（会自动补上）</p>
<p>二、如果一个<strong>基类引用</strong> 引用了 <strong>派生类对象</strong>，并且通过引用试图使用一个 <strong>在基类和派生类中都被定义的函数</strong> ，那么<br>1.如果这个函数<strong>是虚函数，则调用引用变量所引用的对象的类型所定义函数</strong><br>2.如果这个函数<strong>不是虚函数，则调用引用变量本身类型的函数</strong></p>
<p>在上文中，b是Base类型的引用，他所指向的是Ps类型的对象，调用函数func1()，那么如果func1被定义为虚函数，则使用Ps类中的定义，如果不是虚函数，则使用Base类中的定义</p>
<p>三、使用<strong>虚析构函数</strong>能够确保释放派生对象的时候，优先调用基类虚构函数，从而确保正确的析构顺序。</p>
<h4 id="13-3-3虚方法应用：基类指针数组"><a href="#13-3-3虚方法应用：基类指针数组" class="headerlink" title="13.3.3虚方法应用：基类指针数组"></a>13.3.3虚方法应用：基类指针数组</h4><p>因为使用的是公有继承模型，所以可以使用基类指针（Base<em>）来指向基类对象（Base）或者派生类对象（Ps），当通过基类指针调用虚方法时，会根据它所致的对象类型（基类或者派生类1或者派生类2等等）来动态选择要用哪个方法，这样可以通过创建一个<em>*基类指针数组</em></em>，来同时管理基类和它的派生类。</p>
<h3 id="13-4静态联编和动态联编"><a href="#13-4静态联编和动态联编" class="headerlink" title="13.4静态联编和动态联编"></a>13.4静态联编和动态联编</h3><p>将源代码中的函数调用解释为执行特定函数的过程称为<strong>联编</strong></p>
<p>在编译过程中进行联编成为<strong>静态联编（早期联编）
</strong>在程序执行时进行的联编（虚函数）称为<strong>动态联编（晚期联编）</strong></p>
<h4 id="13-4-1指针和引用的类型的兼容性"><a href="#13-4-1指针和引用的类型的兼容性" class="headerlink" title="13.4.1指针和引用的类型的兼容性"></a>13.4.1指针和引用的类型的兼容性</h4><p>基类的引用或者指针可以引用派生类对象，不需要进行显式类型转换<br>将派生类引用或指针转换为基类引用或指针被称为<strong>向上强制转换（upcasting），</strong>这种转换是可传递的。</p>
<p>相反，将基类指针或者引用转换为派生列指针或引用称为<strong>向下强制转换（downcasting）</strong>,如果不使用显式类型转化，则这种转换时不允许的，因为is-a关系是不可逆的。</p>
<h4 id="13-4-2虚函数的工作原理"><a href="#13-4-2虚函数的工作原理" class="headerlink" title="13.4.2虚函数的工作原理"></a>13.4.2虚函数的工作原理</h4><p>编译器处理虚函数的方法：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址的指针，这种数组称为”虚函数表“（virtual function table，vbtl）<br>虚函数表中存储了为类对象进行声明的虚函数的地址。如果派生类提供了虚函数的新的定义，那么虚函数表会保存新函数的地址，如果没有重新定义虚函数，则保存原本的地址，如果定义了新的虚函数，那么这个函数地址也会被i坦加进去。（注意：不论类中包含的虚函数是一个还是十个，都只需在对象中添加一个隐藏的地址成员，指向虚函数表）</p>
<p>在使用虚函数时，在内存和执行速度方面都会有一些成本：<br>1.每个对象都将增大，增大两位存储地址的空间<br>2.对于每个类，编译器都将创建一个虚函数地址表（数组）<br>3.对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址</p>
<h4 id="13-4-3有关虚函数的注意事项"><a href="#13-4-3有关虚函数的注意事项" class="headerlink" title="13.4.3有关虚函数的注意事项"></a>13.4.3有关虚函数的注意事项</h4><p>在基类方法的声明中使用关键字<strong>virtual</strong>可使该方法在<strong>基类以及所有的派生类</strong>中事虚的<br>如果定义的类将被用作基类。则应该将那些<strong>要在派生类中重新定义类方法</strong>声明为虚的</p>
<p>1.构造函数<br>构造函数<strong>不能是</strong>虚函数</p>
<p>2.析构函数<br>析构函数<strong>应当是</strong>虚函数，除非类不做基类，比如employee是基类，singer是派生类，并添加了一个char <em> 成员，指向new分配的内存，当singer对象过期的时候，必须调用~singer()析构函数来释放内存，因此需要虚析构函数<br>如果使用默认的静态联编，delete语句会调用~Employee()析构函数，这会释放Singer对象中的Employee部分指向的内存，但不会释放新的类成员指向的内存。<br>如果使用动态联编，delete会先调用~singer()析构函数，然后调用~Employee()析构函数。<br>这意味着<em>*，即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应该提供虚析构函数</em></em></p>
<p>即使一个类不做基类来使用，定义为虚析构函数也是可以的，只是会牺牲一些效率。</p>
<p>3.友元<br>友元不能是虚函数，因为友元不是类成员，如果因为这个原因引起了设计问题，可以通过<strong>让友元函数使用虚成员函数来解决</strong></p>
<p>4.没有重新定义<br>如果派生类没有重新定义，那将使用最新的虚函数，例外情况是基类版本是隐藏的</p>
<p>5.重新定义将隐藏方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ps</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Ps p1;</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">show</span>();<span class="comment">//合法</span></span><br><span class="line">	p<span class="number">1.</span><span class="built_in">show</span>(<span class="number">2</span>);<span class="comment">//不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在Ps类中重新定义了虚函数show，所以隐藏了Base类中定义的<strong>所有</strong>show函数，这导致带参的show函数版本被隐藏，无法通过Ps对象来调用。</p>
<p>由此引出两条经验规则：<br>1.如果重新定义继承的方法，应该确保与原先的原型完全一致，但如果返回类型是基类引用或者指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变（covariance of return type） 因为允许返回类型随类型的变化而变化<br>（注意：这种变化只适用于返回值，不适用于参数）<br>2.如果基类声明被重载了，那么应该在派生类中重新定义所有重载基类版本<br>如果只需要重新定义其中部分函数，但还是需要将不需要修改的函数重新定义一下（void Ps::show() const {Base::show();}</p>
<h3 id="13-5访问控制：protected"><a href="#13-5访问控制：protected" class="headerlink" title="13.5访问控制：protected"></a>13.5访问控制：protected</h3><p>protected权限和private类似，<strong>在类外只能用公有类成员来访问protected部分中的类成员</strong>，但区别是<strong>派生类的成员可以直接访问基类的protected成员</strong>，但不能直接访问基类的私有成员</p>
<p>对于下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetB</span><span class="params">(<span class="type">double</span> data)</span></span>&#123;dat1 = data;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">double</span> dat1;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ps</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resetP</span><span class="params">(<span class="type">double</span> data)</span></span>&#123; dat1 = data;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然dat1是Base中的保护成员，本意希望只通过resetB()来更改dat1的数据，但是通过派生类Ps中的公有成员resetP()间接访问了受保护的dat1成员，这使得dat1似乎成为了公有变量</p>
<p>因此<strong>最好对类数据成员采用私有访问控制，不要使用保护访问控制，同时通过基类方法使得派生类能够访问基类数据</strong></p>
<h3 id="13-6抽象基类"><a href="#13-6抽象基类" class="headerlink" title="13.6抽象基类"></a>13.6抽象基类</h3><p>如果两个类有一些共性，可以把他们的共性抽象成一个基类，然后由这个基类来派生出这两个类。这样就可以使用基类指针数组来同时管理这两个类。</p>
<p>这个基类可以<strong>只指明所需要的函数，而将函数的具体实现交给它的派生类</strong></p>
<p>C++使用纯虚函数来实现这种基类<br>纯虚函数声明时要在函数头后面加上 =0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseEllipse</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span>  </span>= <span class="number">0</span>;<span class="comment">//area()是一个纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>:<span class="keyword">public</span> BaseEllipse&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.1415</span>*r*r;&#125;<span class="comment">//纯虚函数在派生类中的实现</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> r;<span class="comment">//半径</span></span><br><span class="line">	<span class="type">int</span> x,y;<span class="comment">//坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>:<span class="keyword">public</span> BaseEllipse&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span><span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="number">3.1415</span>*A*B;&#125;<span class="comment">//纯虚函数在派生类中的实现</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> A;<span class="comment">//半长轴</span></span><br><span class="line">	<span class="type">int</span> B;<span class="comment">//半短轴</span></span><br><span class="line">	<span class="type">int</span> x,y;<span class="comment">//坐标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>如果一个类中包含了纯虚函数，那么就不能创建该类的对象</strong>，因此这种类只能用作基类</p>
<p>在基类中的纯虚函数一般只需要声明而不需要定义，但在基类中给出纯虚函数的定义也是可以的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">BaseEllipse::area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>包含纯虚函数的类不能被实例化，这种类叫做<strong>抽象基类</strong></p>
<p>可以被实例化的类叫做<strong>具体(concrete)类</strong></p>
<h3 id="13-7继承和动态内存分配"><a href="#13-7继承和动态内存分配" class="headerlink" title="13.7继承和动态内存分配"></a>13.7继承和动态内存分配</h3><h4 id="13-7-1-情况一-派生类不使用new"><a href="#13-7-1-情况一-派生类不使用new" class="headerlink" title="13.7.1 情况一:派生类不使用new"></a>13.7.1 情况一:派生类不使用new</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseDMA</span>&#123;<span class="comment">//使用了动态内存分配的基类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> * label;</span><br><span class="line">	<span class="type">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BaseDMA</span>(<span class="type">const</span> <span class="type">char</span>* l = <span class="string">&quot;null&quot;</span>,<span class="type">int</span> t = <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">BaseDMA</span>(<span class="type">const</span> BaseDMA &amp; bs);</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">BaseDMA</span>();</span><br><span class="line">	BaseDMA &amp; <span class="keyword">operator</span>=(<span class="type">const</span> BaseDMA * bs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lacksDMA</span>:<span class="keyword">public</span> BaseDMA&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> color[<span class="number">40</span>];<span class="comment">//使用数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（上面的代码只给出了函数的声明，没有给出定义）<br>上面的代码中派生类lacksDMA中没有用new来分配内存，在基类中使用new来动态分配内存。<br>那么就<strong>不需要</strong>为派生类lacksDMA定<strong>义显式析构函数，复制构造函数和赋值运算符</strong></p>
<h4 id="13-7-2-情况二-派生类使用new"><a href="#13-7-2-情况二-派生类使用new" class="headerlink" title="13.7.2 情况二:派生类使用new"></a>13.7.2 情况二:派生类使用new</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hasDMA</span>:<span class="keyword">public</span> BaseDMA&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* color;<span class="comment">//使用new分配内存</span></span><br><span class="line">	~<span class="built_in">hasDMA</span>();</span><br><span class="line">	<span class="built_in">hasDMA</span>(<span class="type">const</span> <span class="type">char</span>* c = <span class="string">&quot;null&quot;</span>);</span><br><span class="line">	<span class="built_in">hasDMA</span>(<span class="type">const</span> hasDMA &amp; hs);</span><br><span class="line">	hasDMA &amp; <span class="keyword">operator</span>=(<span class="type">const</span> hasDMA * hs);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，必须为派生类定义显式析构函数，复制构造函数和复制运算符。</p>
<p><strong>析构函数：</strong>hasDMA的析构函数负责释放color管理的内存，然后以来baseDMA的析构函数来释放掉label管理的内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">BaseDMA::~<span class="built_in">BaseDMA</span>()&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] label;</span><br><span class="line">&#125;</span><br><span class="line">hasDMA::~<span class="built_in">hasDMA</span>()&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hasDMA复制构造函数只能访问hasDMA的数据，因此他必须调用baseDMA复制构造函数来处理共享的baseDMA数据。（也就是初始化成员列表中的<strong>BaseDMA(hs)</strong>）<br>在上面的代码中，成员初始化列表将一个hasDMA的引用出啊等你给了BaseDMA复制构造函数，，这用到了<strong>类继承中可以向上强制传递</strong>的性质。会将hs中的BaseDMA部分传递给BaseDMA的复制构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制构造函数</span></span><br><span class="line">hasDMA::<span class="built_in">hasDMA</span>(<span class="type">const</span> hasDMA &amp; hs):<span class="built_in">BaseDMA</span>(hs)&#123;</span><br><span class="line">	color = <span class="keyword">new</span> <span class="type">char</span>[std::<span class="built_in">strlen</span>(hs.color)<span class="number">+1</span>];</span><br><span class="line">	std::<span class="built_in">strcpy</span>(color,hs.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>赋值运算符和复制构造函数的代码类似，区别在于需要<strong>判断自己等于自己的情况</strong>，以及需要<strong>在函数块中调用BaseDMA的=运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值运算符</span></span><br><span class="line">hasDMA &amp; hasDMA::<span class="keyword">operator</span>=(<span class="type">const</span> hasDMA &amp; hs)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == &amp;hs) <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//防止误删自己</span></span><br><span class="line">	BaseDMA::<span class="keyword">operator</span>=(hs);</span><br><span class="line">	<span class="keyword">delete</span>[] color;</span><br><span class="line">	color = <span class="keyword">new</span> <span class="type">char</span>[std::<span class="built_in">strlen</span>(hs.color)<span class="number">+1</span>];</span><br><span class="line">	std::<span class="built_in">strcpy</span>(color,hs.color);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之当基类和派生类都采用动态内存分配的时候，派生类的析构函数，复制构造函数，赋值运算符<strong>都必须使用相应的基类方法来处理基类元素</strong></p>
<h3 id="13-8类设计回顾"><a href="#13-8类设计回顾" class="headerlink" title="13.8类设计回顾"></a>13.8类设计回顾</h3><h4 id="13-8-1要遵循is-a关系"><a href="#13-8-1要遵循is-a关系" class="headerlink" title="13.8.1要遵循is-a关系"></a>13.8.1要遵循is-a关系</h4><p>表示is-a关系的方法之一是，无需进行显式类型转换，基类指针就可以指向派生类指针，积累引用可以引用派生类对象。</p>
<h4 id="13-8-2什么不能被继承"><a href="#13-8-2什么不能被继承" class="headerlink" title="13.8.2什么不能被继承"></a>13.8.2什么不能被继承</h4><p>构造函数，析构函数，赋值运算符不能被继承</p>
<h4 id="13-8-3赋值运算符"><a href="#13-8-3赋值运算符" class="headerlink" title="13.8.3赋值运算符"></a>13.8.3赋值运算符</h4><p>可以将派生类对象赋值给基类对象<br>但如果相反，想要将基类对象赋值给派生类对象，会有一些前提：<br>一、包含了这样的构造函数，即对将基类对象转换为派生类对象机型了定义，则可以将基类对象昂赋给派生对象<br>二、如果派生类定义了用于将基类对象赋给派生对象的赋值运算符，则可以这样做<br>三、如果上述两个条件都不满足，那么就不能将基类对象赋值给派生对象，除非使用显式强制类型转换。</p>
<h4 id="13-8-4私有成员与保护成员"><a href="#13-8-4私有成员与保护成员" class="headerlink" title="13.8.4私有成员与保护成员"></a>13.8.4私有成员与保护成员</h4><p>使用私有数据成员比使用保护数据成员更好，但保护方法很有用</p>
<h4 id="13-8-5虚方法"><a href="#13-8-5虚方法" class="headerlink" title="13.8.5虚方法"></a>13.8.5虚方法</h4><p>1.如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的，这样可以启用动态联编</p>
<p>2.如果不希望基类中的方法被重新定义，则不要声明为虚函数，虽然当这个类被继承的时候仍然可以重新定义，但是这能起到提示作用</p>
<p>3.不适当的代码会阻止动态联编<br>比如下面两个函数（其中Base是基类，Ps是派生类。二者有虚函数View();分别使用show和inadequate两个函数来调用View函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> Base &amp; rba)</span></span>&#123;</span><br><span class="line">	ba.<span class="built_in">View</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inadequate</span><span class="params">(Base ba)</span></span>&#123;</span><br><span class="line">	p.<span class="built_in">View</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数中调用过程</span></span><br><span class="line">Ps t;</span><br><span class="line"><span class="built_in">show</span>(t);</span><br><span class="line"><span class="built_in">inadequate</span>(t);</span><br></pre></td></tr></table></figure>
<p>第一个函数按引用传递对象，第二个函数按值传递对象，传递的是派生类Ps的对象t。</p>
<p>1.在show中，由于Base类的引用可以引用Ps类的对象，所以rba所引用的仍然是一个Ps类对象。由于虚方法的特性，ba.View()调用的是Ps版本的View()函数</p>
<p>2.在inadequate中，传递的实参是Ps类的对象，会先转换成Base类对象再传递给形参p，所以ba是一个Base类对象，因此ba,View()是Base版本的View函数</p>
<h2 id="14-C-中的代码重用"><a href="#14-C-中的代码重用" class="headerlink" title="14.C++中的代码重用"></a>14.C++中的代码重用</h2><p>has-a关系通常可以用以下两种方法来实现：</p>
<p>一是一个类中的数据成员可以是另一个类的对象，这种方法被称为<strong>包含（containment）、组合（composition）</strong>或<strong>层次化（layering）</strong>。</p>
<p>另一种方法是使用私有继承或保护继承。</p>
<h3 id="14-1包含对象成员的类"><a href="#14-1包含对象成员的类" class="headerlink" title="14.1包含对象成员的类"></a>14.1包含对象成员的类</h3><p>在下面的代码中，student类包含了string类和score类的对象成员，是is-a关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">score</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">score</span>(<span class="type">int</span> c= <span class="number">0</span>,<span class="type">int</span> m = <span class="number">0</span>,<span class="type">int</span> e = <span class="number">0</span>):<span class="built_in">Chinese</span>(c),<span class="built_in">Math</span>(m),<span class="built_in">English</span>(e)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> Chinese;</span><br><span class="line">	<span class="type">int</span> Math;</span><br><span class="line">	<span class="type">int</span> English;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">student</span>(string n=“”,<span class="type">int</span> c=<span class="number">0</span>,<span class="type">int</span> m=<span class="number">0</span>,<span class="type">int</span> e=<span class="number">0</span>):<span class="built_in">name</span>(n),<span class="built_in">sco</span>(c,m,e)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	score sco;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="14-2私有继承"><a href="#14-2私有继承" class="headerlink" title="14.2私有继承"></a>14.2私有继承</h3><p>使用私有继承，基类的公有方法将称为派生类的私有方法，</p>
<p>派生类不继承基类的接口，这种不完全继承是has-a关系的一部分。</p>
<p>私有继承提供的特性和包含相同：<strong>获得实现，但不获得接口</strong>，所以私有继承可以用来实现has-a关系</p>
<p>在继承时，private是默认的，因此不写明继承方法时，默认为私有继承</p>
<h4 id="14-2-1初始化基类组件"><a href="#14-2-1初始化基类组件" class="headerlink" title="14.2.1初始化基类组件"></a>14.2.1初始化基类组件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">private</span> score&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">student</span>(string n,<span class="type">int</span> c,<span class="type">int</span> m,<span class="type">int</span> e):<span class="built_in">name</span>(n),<span class="built_in">score</span>(c,m,e)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和包含的区别在：对于继承类，新版本的构造函数将使用成员初始化列语法，使用类名而不是成员名来表示构造函数<br>（在上面的代码体现在score(c,m,e)而不是sco(e,m,e)）</p>
<h4 id="14-2-2访问基类的函数"><a href="#14-2-2访问基类的函数" class="headerlink" title="14.2.2访问基类的函数"></a>14.2.2访问基类的函数</h4><p>使用类名和作用域解析运算符来调用基类的方法。比如假设基类score中有成员函数sum()，那么在派生类中可以通过score::sum()来调用。</p>
<h4 id="14-2-3访问基类对象"><a href="#14-2-3访问基类对象" class="headerlink" title="14.2.3访问基类对象"></a>14.2.3访问基类对象</h4><p>通过<strong>强制类型转换</strong>，将派生类转换为基类，从而来访问基类内部的数据成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//派生类调用基类成员</span></span><br><span class="line"><span class="function"><span class="type">const</span> score <span class="title">student::Score</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">const</span> score &amp;) *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-2-4访问基类友元函数"><a href="#14-2-4访问基类友元函数" class="headerlink" title="14.2.4访问基类友元函数"></a>14.2.4访问基类友元函数</h4><p>不能用类名加作用域运算符的形式来调用友元函数，因为友元函数不是类成员函数。但是可以通过显式地转换为基类来调用正确的函数</p>
<p>假设基类中有如下&lt;&lt;友元函数，用来输出三个科目的分数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="type">const</span> score &amp; sco)&#123;<span class="comment">//友元函数</span></span><br><span class="line">		os&lt;&lt;<span class="string">&quot;Chinese:&quot;</span>&lt;&lt;sco.Chinese&lt;&lt;<span class="string">&quot; Math:&quot;</span>&lt;&lt;sco.Math&lt;&lt;<span class="string">&quot; English&quot;</span>&lt;&lt;sco.English&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>主函数可以这样写来调用基类中的友元函数（这里为调用基类中的&lt;&lt;友元函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">student <span class="title">stu</span><span class="params">(<span class="string">&quot;小李&quot;</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;(<span class="type">const</span> score &amp;)stu;</span><br></pre></td></tr></table></figure>
<h3 id="14-3保护继承"><a href="#14-3保护继承" class="headerlink" title="14.3保护继承"></a>14.3保护继承</h3><p>保护继承是私有继承的变体，使用保护继承的时候<strong>基类的公有成员和保护成员变为派生类的保护成员</strong>，和私有继承一样，和积累的接口在派生类中可以直接使用，但是在继承层次结构之外不可使用</p>
<h3 id="14-4多重继承"><a href="#14-4多重继承" class="headerlink" title="14.4多重继承"></a>14.4多重继承</h3><h4 id="14-4-1虚基类"><a href="#14-4-1虚基类" class="headerlink" title="14.4.1虚基类"></a>14.4.1虚基类</h4><p>虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象</p>
<p>在类声明中使用关键字virtual使得基类被用作虚基类（virtual和public的次序关系随意），这样就可以避免重复继承。</p>
<p>比如有基类worker，派生出了类singer和dancer。之后又由singer和dancer派生出star。那么需要在继承worker的时候加上virtual关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">worker</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">worker</span>(string name = <span class="string">&quot;null&quot;</span>):<span class="built_in">name</span>(name)&#123;&#125;</span><br><span class="line">	<span class="built_in">worker</span>(<span class="type">const</span> worker&amp; wk)&#123;<span class="keyword">this</span>-&gt;name = wk.name;&#125;</span><br><span class="line">	<span class="function">string <span class="title">getname</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(string name)</span></span>&#123;<span class="keyword">this</span>-&gt;name = name;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dancer</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> worker&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">dancer</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">dancer</span>(<span class="type">const</span> worker&amp; wk,<span class="type">int</span> ddat = <span class="number">0</span>):<span class="built_in">worker</span>(wk),<span class="built_in">ddat</span>(ddat)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>	ddat;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singer</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> worker&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">singer</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">singer</span>(<span class="type">const</span> worker&amp; wk,<span class="type">int</span> sdat = <span class="number">0</span>):<span class="built_in">worker</span>(wk),<span class="built_in">sdat</span>(sdat)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> sdat;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">star</span>:<span class="keyword">public</span> dancer,<span class="keyword">public</span> singer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">star</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">star</span>(<span class="type">const</span> worker&amp; wk,<span class="type">int</span> ddat = <span class="number">0</span>,<span class="type">int</span> sdat = <span class="number">0</span>,<span class="type">int</span> age = <span class="number">0</span>) :<span class="built_in">worker</span>(wk),<span class="built_in">dancer</span>(wk,ddat),<span class="built_in">singer</span>(wk,sdat),<span class="built_in">age</span>(age)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">worker <span class="title">w1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">star <span class="title">s</span><span class="params">(w1,<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">getname</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免通过不同的途径给基类的成员赋值，虚<strong>函数禁止了信息通过中间类自动传递给基类</strong>。因此无法通过原本的方法来定义构造函数，在上例中无法在star类中获取name然后将name信息传递给worker。这样会传递失败，然后worker部分<strong>会调用默认构造函数。
</strong>因此在star的构造函数的初始化成员列表<strong>必须直接使用work的某个构造函数来构造work</strong>（如果work不是虚基类，这样是不合法的），就似乎是star直接继承了worker一样。</p>
<p>如果不希望只使用虚基类的默认构造函数，那么必须显式地调用改虚基类的某个构造函数</p>
<h4 id="14-4-2使用哪个成员函数？"><a href="#14-4-2使用哪个成员函数？" class="headerlink" title="14.4.2使用哪个成员函数？"></a>14.4.2使用哪个成员函数？</h4><p>在单继承中如果没有重新定义基类中的成员函数，调用时会使用基类的定义，而在<strong>多继承中，调用基类成员函数可能会导致二义性。</strong></p>
<p>1.可以使用作用域运算符来选择使用哪个版本的成员函数。<br>例如s为star的对象。<br>使用<strong>s.singer::show()</strong>来调用singer版本的show()函数</p>
<p>2.更好的方法是重新定义这个函数，然后在这个函数中选择调用哪个版本的函数<br>例如给出star中show()的定义<strong>void star::show(){singer::show()}</strong></p>
<p>分析两种方法可以得到：<strong>第一种方法有一定的安全隐患，而第二种方法则会只显示singer部分的成员，而无法显示dancer部分的成员</strong><br>第二种方法的补救措施是<strong>分别调用singer::show()和dancer::show()</strong>。 但这又会导致<strong>重复调用了worker::show()</strong>。<br>补救措施的完善方法是：将模块化数据，让singer::data()只显示专属于singer 的部分，dancer同理。在star::work()部分则分别调用singer::data(),dancer::data(),worker::data(),并额外显示专属于star的部分。</p>
<p>总之，在祖先相同时，使用多重继承必须使用虚基类，并且修改构造函数初始化列表的规则。</p>
<h4 id="14-4-3混合使用虚基类和非虚基类"><a href="#14-4-3混合使用虚基类和非虚基类" class="headerlink" title="14.4.3混合使用虚基类和非虚基类"></a>14.4.3混合使用虚基类和非虚基类</h4><p>如果有类B被用作C和D的虚基类，X和Y的非虚基类。然后CDXY都用于M的基类，那么M会从CD中继承一个B类子对象，从X和Y中分别继承一个B类子对象。因此它包含了三个B类子对象。</p>
<h4 id="14-4-4虚基类和支配"><a href="#14-4-4虚基类和支配" class="headerlink" title="14.4.4虚基类和支配"></a>14.4.4虚基类和支配</h4><p>入股哦一个类从不同的类那里继承了两个或多个成员（数据或方法）那么使用改成员名的时候，入股哦么有类名进行限定，会导致二义性，如果使用的是虚基类，就<strong>不一定</strong>会导致二义性，这时，如果某个名称<strong>优先于</strong>其他所有名称，那么使用它的时候即使没有限定符也不会导致二义性。<br>优先性的判断规则是：<strong>派生类中的名称优先于直接或间接祖先类中的相同名称</strong></p>
<h3 id="14-4类模板"><a href="#14-4类模板" class="headerlink" title="14.4类模板"></a>14.4类模板</h3><p>通过模板类可以用来实现容器类<strong>container class</strong>(如STL中的stack和queue等容器)，容器类设计用来存储其他对象或者数据结构。</p>
<p><strong>本节比较难懂，且代码都很长，做好心理准备</strong></p>
<h4 id="14-4-1定义类模板"><a href="#14-4-1定义类模板" class="headerlink" title="14.4.1定义类模板"></a>14.4.1定义类模板</h4><p>和定义模板函数类似，模板类以下面的代码开头<br><code>template&lt;class Type&gt;</code></p>
<p>这里的Type 不必是一个类，而只是表明这是一个通用的类型说明符。可以用不太容易混淆的<strong>typename</strong>关键字来替换掉class。</p>
<p>下面是一个模板类的声明和定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stacktp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACKTP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKTP_H_</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10</span>;</span><br><span class="line">	Type items[MAX];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Stack</span>();</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> Type &amp; item)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Type &amp; item)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板类中函数的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">Stack&lt;Type&gt;::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">	top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;Type&gt;::<span class="built_in">isempty</span>()&#123;</span><br><span class="line">	<span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;Type&gt;::<span class="built_in">isfull</span>()&#123;</span><br><span class="line">	<span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;Type&gt;::<span class="built_in">push</span>(<span class="type">const</span> Type &amp; item)&#123;</span><br><span class="line">    <span class="keyword">if</span>(top &lt; MAX)&#123;</span><br><span class="line">        items[top++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;Type&gt;::<span class="built_in">pop</span>(Type &amp; item)&#123;</span><br><span class="line">    <span class="keyword">if</span>(top &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        item = items[--top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>模板类声明和普通类基本相同，区别在于<br>1.最前面要加上模板声明template<typename Type>以及把之后的数据类型替换为Type。<br>2.在使用类限定符的时候应该从<strong>Stack;:</strong> 改为<strong>Stack<Type>::</strong></p>
<p>模板必须和特定的模板实例化请求一起使用，为此，最简单的方法是<strong>将所有模板信息放在一个头文件中</strong></p>
<p><strong>使用模板类：</strong><br>在上例中可以通过Stack<int> s;来创建一个参数为int的Stack类</p>
<h4 id="14-4-2模板的具体化"><a href="#14-4-2模板的具体化" class="headerlink" title="14.4.2模板的具体化"></a>14.4.2模板的具体化</h4><p>类模板和函数模板很相似，因此可以又隐式实例化，显式实例化和显式具体化，它们统称为具体化（<strong>specialization</strong>）</p>
<p>1.隐式实例化（implicit instantiation）<br>定义好一个类模板后，在创建某对象的时候，会自动进行这个参数类型的类进行隐式实例化，在这之前不会生成类的隐式实例化。<br>比如在创建<strong>Stack<int> s1;</strong>的时候会创建参数类型为int 的Stack类对象s1。这时候就对Stack<int>进行了隐式实例化</p>
<p>2.显式实例化（explicit instantiation）<br>顾名思义就是我们直接要求进行的实例化，这时，虽然没有创建或提及类对象，编译器也会生成类声明（包括方法定义）所用到的语句为<strong>template class Stack<int>;</strong></p>
<p>3.显式具体化（explicit specialization）<br>有时候我们想要这个模板在某个参数的时候给出不同的定义，这时候就需要对这个参数类型的类进行特殊的定义<br><strong>template &lt;&gt; class Stack<int>{…};
</strong>这行代码的特点在于前缀template &lt;&gt;</p>
<p>4.部分具体化（partial specialization）<br>C++还允许部分具体化，即部分限制模板的通用性，例如:<br>假设有类模板<strong>template <typename Type1,typename Type2>class Array{…}</strong>我们可以使用<strong>template<typename T> class Array<T,int>{…}</strong>对所有模板参数为<strong>第一个任意，第二个为int</strong>的模板类进行重新定义。这和显式具体化类似，区别在于只给出了部分模板参数的具体化，而其他的模板参数（上例中的Type1）仍然为待定状态。</p>
<h4 id="14-4-3成员模板"><a href="#14-4-3成员模板" class="headerlink" title="14.4.3成员模板"></a>14.4.3成员模板</h4><p>模板可用作结构、类胡总和模板类的成员。下面的示例代码为一个模板类，它将另一个模板类和模板韩素作为它的成员。试着去理解这段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">beta</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt; <span class="comment">//模板类作为成员</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">hold</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		V val;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">hold</span>(V v = <span class="number">0</span>) : <span class="built_in">val</span>(v) &#123;&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout&lt;&lt; val&lt;&lt;endl;&#125;</span><br><span class="line">		<span class="function">V <span class="title">Value</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	hold &lt;T&gt; q;</span><br><span class="line">	hold&lt;<span class="type">int</span>&gt; n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">beta</span>(T t,<span class="type">int</span> i):<span class="built_in">q</span>(t),<span class="built_in">n</span>(i) &#123;&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">//模板成员函数</span></span><br><span class="line">	<span class="function">U <span class="title">blab</span><span class="params">(U u,T t)</span></span>&#123;<span class="keyword">return</span> (n.<span class="built_in">Value</span>() + q.<span class="built_in">Value</span>()) * u / t;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;q.<span class="built_in">show</span>();n.<span class="built_in">show</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">beta&lt;<span class="type">double</span>&gt; <span class="title">guy</span><span class="params">(<span class="number">3.5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;T was set to double n&quot;</span>;</span><br><span class="line">	guy.<span class="built_in">Show</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;V was set to T,which is double, then V was set to int n&quot;</span>;</span><br><span class="line">	cout&lt;&lt;guy.<span class="built_in">blab</span>(<span class="number">10</span>,<span class="number">2.3</span>)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;U was set to int n&quot;</span>;</span><br><span class="line">	cout&lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10.0</span>,<span class="number">2.3</span>) &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;U was set to double n&quot;</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Donen&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类定义过程：</strong><br>hold模板是在私有部分声明的，因此只能在beta类中访问它，beta类使用hold模板声明了两个数据成员：<br><code>hold&lt;T&gt; q;</code><br><code>hold&lt;int&gt; n;</code><br>n是基于int类型的hold对象，q成员是基于T类型的hold对象。</p>
<p><strong>使用过程：</strong><br><strong>1.创建模板类对象</strong><br>在main中创建guy的时候，模板参数为T是double类型，gay中的q是T类型的（也就是double）类型的hold对象，n是int类型的hold对象。<br><strong>2.调用模板类对象中的模板函数（此时模板类的各个模板参数已经确定）</strong><br>之后调用guy. blab(10,2.3)的时候，传入的第一个参数是int类型的，所以blab是参数列表为(int,double)，返回值为int的函数。而之后在调用guy.blab(10.0,2.3)的时候，又创建了参数列表为(double,double)，返回值为double的函数。需要注意的是，因为blab的第二个参数在生成guy的时候已经确定了是double(T为double),所以不管调用函数的时候传入的是什么类型的参数，都会转换为double类型的参数进行处理。</p>
<h4 id="14-4-4将模板用作另一模板的模板参数"><a href="#14-4-4将模板用作另一模板的模板参数" class="headerlink" title="14.4.4将模板用作另一模板的模板参数"></a>14.4.4将模板用作另一模板的模板参数</h4><p>模板可以包含<strong>类型参数(如typename T)</strong>和<strong>非类型参数（如int n）</strong>，模板还可以包含<strong>本身就是模板的参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stacktp.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Thing</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crab</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Thing&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	Thing&lt;<span class="type">double</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Crab</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> x)</span></span>&#123;<span class="keyword">return</span> s<span class="number">1.</span><span class="built_in">push</span>(a) &amp;&amp; s<span class="number">2.</span><span class="built_in">push</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> &amp; a, <span class="type">double</span> &amp; x )</span></span>&#123;<span class="keyword">return</span> s<span class="number">1.</span><span class="built_in">pop</span>(a) &amp;&amp; s<span class="number">2.</span><span class="built_in">pop</span>(x);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Crab&lt;Stack&gt; nebula;</span><br><span class="line">	<span class="type">int</span> ni;</span><br><span class="line">	<span class="type">double</span> nb;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Enter int double pairs, such as 4 3.5(0 0 to end):n&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;ni&gt;&gt;nb &amp;&amp; ni&gt;<span class="number">0</span> &amp;&amp; nb &gt; <span class="number">0</span>)&#123;<span class="comment">//输入并判断输入是否河狸</span></span><br><span class="line">		<span class="keyword">if</span>(!nebula.<span class="built_in">push</span>(ni,nb))&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(nebula.<span class="built_in">pop</span>(ni,nb))&#123;</span><br><span class="line">		cout&lt;&lt;ni&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;nb&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Done.n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中用到了14.4.1中的代码段作为头文件，用来提供一个模板。与此同时又创建了<strong>参数为一个模板的</strong>新的模板。这个模板类包含了一个int类型的模板和double类型的模板。用来同时调用二者的push函数和pop函数。<br>在主函数调用中，我们<strong>传入的参数模板必须包含有push函数和pop函数接口</strong>，因此Stack作为参数是合适的。<br>之后在主函数中以Stack为参数实例化了相关的类和对象（nebula是对象）。然后就可以用这个nebula对象来存储数据了。</p>
<h4 id="14-4-5模板类和友元"><a href="#14-4-5模板类和友元" class="headerlink" title="14.4.5模板类和友元"></a>14.4.5模板类和友元</h4><p>模板类声明也可以有友元，模板的友元分为三类：<br><strong>1.非模板友元</strong><br><strong>2.约束（bound）模板友元</strong>，即友元的类型取决于类被实例化时的类型<br><strong>3.非约束（unbound）模板友元</strong>，即友元的所有具体化都是类的每一个具体化的友元</p>
<ol>
<li>模板类的非模板友元函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frnd2tmp.cpp</span></span><br><span class="line"><span class="comment">//1.模板类的非模板友元函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasFriend</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T item;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ct;<span class="comment">//朋友数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasFriend</span>(<span class="type">const</span> T &amp; i) : <span class="built_in">item</span>(i) &#123;ct++;&#125;</span><br><span class="line">    ~<span class="built_in">HasFriend</span>()&#123;ct--;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;<span class="comment">//显示数量</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">reports</span><span class="params">(HasFriend&lt;T&gt; &amp;)</span></span>;<span class="comment">//显示这个对象的item信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> HasFriend&lt;T&gt;:: ct = <span class="number">0</span>;<span class="comment">//为每个实例化的静态函数赋初值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;int count: &quot;</span>&lt;&lt; HasFriend&lt;<span class="type">int</span>&gt;::ct&lt;&lt;<span class="string">&quot;;&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;double count: &quot;</span>&lt;&lt;HasFriend&lt;<span class="type">double</span>&gt;::ct&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要对带模板参的友元函数进行具体化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reports</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt; &amp; hf)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;HasFriend&lt;int&gt;:&quot;</span>&lt;&lt;hf.item&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reports</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt; &amp; hf)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;HasFriend&lt;int&gt;:&quot;</span>&lt;&lt;hf.item&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No objects declared: &quot;</span>;</span><br><span class="line">    <span class="built_in">counts</span>();</span><br><span class="line">    <span class="function">HasFriend&lt;<span class="type">int</span>&gt; <span class="title">hfi1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//has friend int</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After hfi1 declared: &quot;</span>;</span><br><span class="line">    <span class="built_in">counts</span>();</span><br><span class="line">    <span class="function">HasFriend&lt;<span class="type">int</span>&gt; <span class="title">hfi2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After hfi2 declared: &quot;</span>;</span><br><span class="line">    <span class="built_in">counts</span>();</span><br><span class="line">    <span class="function">HasFriend&lt;<span class="type">double</span>&gt; <span class="title">hfdb</span><span class="params">(<span class="number">10.5</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After hfdb declared: &quot;</span>;</span><br><span class="line">    <span class="built_in">counts</span>();</span><br><span class="line">    <span class="built_in">reports</span>(hfi1);</span><br><span class="line">    <span class="built_in">reports</span>(hfi2);</span><br><span class="line">    <span class="built_in">reports</span>(hfdb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的编译器会对使用非模板友元发出警告。警告内容为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,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" alt="img"></p>
<p><code>friend void reports(HasFriend&lt;T&gt; &amp;);</code></p>
<p>上面中的counts友元函数是所有实例化的友元，例如它同时是HasFriend <int>和HasFriend<double>的友元<br>counts通过以下方式来访问HasFriend对象<strong>1.访问全局对象2.通过全局指针访问非全局对象3.创建自己的对象4.访问独立于对象的模板类的静态数据成员</strong></p>
<p>如果要为友元函数提供模板类参数，那么应该这样声明；<br><code>friend void report(HasFriend**&lt;T&gt;** &amp;);</code></p>
<p>重点在于参数中的<code>&lt;T&gt;</code>，这是<strong>不可省的</strong>，这样，带<code>HasFriend&lt;int&gt;</code>参数的<strong>report友元函数</strong>将会是<code>HasFriend&lt;int&gt;</code>类的友元，它会和带<code>HasFriend&lt;double&gt;</code>参数的<strong>report</strong>友元函数组成重载</p>
<p>2.模板类的约束模板友元函数<br>可以修改前一个代码示例，使友元函数本身成为模板，没具体地说，为约束模板友元做准备，来使<strong>类的每一个具体化都获得与友元匹配的具体化，</strong>这比非模板友元复杂一些<br><strong>首先，在类定义的前面声明每个模板函数</strong><br><code>template &lt;typename T&gt; void counts();</code><br><code>template &lt;typename T&gt; void report(T &amp; );</code><br><strong>然后在函数中再次将模板声明为友元</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasFriendT</span>&#123;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">counts</span>&lt;TT&gt;();</span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> report&lt;&gt;(HasFriendT&lt;TT&gt; &amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在声明中&lt;&gt;指出这是<strong>模板具体化</strong></p>
<p>3.模板类的非约束模板友元函数<br>在<strong>类内</strong>创建非约束友元函数，每个函数具体化都是每个类具体化的友元</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ManyFriend</span>&#123;  </span><br><span class="line">    <span class="comment">//…  </span></span><br><span class="line">    <span class="keyword">template</span> &lt; <span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt; <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show2</span><span class="params">(C &amp;,D &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在友元函数中的模板参数可以和类模板中的模板参数不同</p>
<h4 id="14-4-6模板别名"><a href="#14-4-6模板别名" class="headerlink" title="14.4.6模板别名"></a>14.4.6模板别名</h4><p>可以用<strong>typedef</strong>为模板具体化指定别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">double</span>,12&gt; arrd;</span><br><span class="line"><span class="keyword">typedef</span> std::array&lt;std::string,12&gt; arrst;</span><br><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">int</span>,12&gt; arri;</span><br></pre></td></tr></table></figure>
<p>C++11之后能够<strong>使用模板提供一系列别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> arrtype = std::array&lt;T,<span class="number">12</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="15-友元、异常、其他"><a href="#15-友元、异常、其他" class="headerlink" title="15.友元、异常、其他"></a>15.友元、异常、其他</h2><h2 id="16-string类和标准模板库"><a href="#16-string类和标准模板库" class="headerlink" title="16.string类和标准模板库"></a>16.string类和标准模板库</h2><h2 id="17-输入、输出和文件"><a href="#17-输入、输出和文件" class="headerlink" title="17.输入、输出和文件"></a>17.输入、输出和文件</h2><h3 id="17-1C-输入输出概述"><a href="#17-1C-输入输出概述" class="headerlink" title="17.1C++输入输出概述"></a>17.1C++输入输出概述</h3><p>C++的输入输出依赖于iostream和fstream内定义的的一系列类。</p>
<h4 id="17-1-1流和缓冲区"><a href="#17-1-1流和缓冲区" class="headerlink" title="17.1.1流和缓冲区"></a>17.1.1流和缓冲区</h4><p>通过使用流，C++ 程序处理输入输出的方式将独立于其去向</p>
<p>管理输入包含两步：<br>1.将流和输入去向的程序关联起来<br>2.将流和文件连接起来<br>管理输出同理</p>
<p>通常通过缓冲区可以高效地处理输入和输出<br>在输出时，程序会首先填满缓冲区，然后把整块数据传输给硬盘，并清空缓冲区，以备下一批输出使用，这被称为刷新缓冲区（flushing the buffer）</p>
<h4 id="17-1-2流、缓冲区和iostream文件"><a href="#17-1-2流、缓冲区和iostream文件" class="headerlink" title="17.1.2流、缓冲区和iostream文件"></a>17.1.2流、缓冲区和iostream文件</h4><p>在程序中包含iostream文件将自动创建8个流对象（4个用于窄字符流，四个用于宽字符流）</p>
<p>分别为<strong>cin 、cout、cerr、clog的</strong>窄字符和宽字符版本</p>
<h4 id="17-1-3重定向"><a href="#17-1-3重定向" class="headerlink" title="17.1.3重定向"></a>17.1.3重定向</h4><p>通过输入重定向&lt;和输出重定向&gt;，可以使用改变输入和输出流的连接目标.(默认为键盘和显示器)</p>
<p>对标准输出重定向并不会影响到cerr或clog。因此如果使用其中一个对象来打印错误信息，程序会在屏幕上显示错误信息。</p>
<h3 id="17-2使用cout来进行输出"><a href="#17-2使用cout来进行输出" class="headerlink" title="17.2使用cout来进行输出"></a>17.2使用cout来进行输出</h3><p>C++将输出看作字节流，很多数据都是以数值类型存储的，因此ostream流最重要的任务之一就是将数值类型（int或double等）转换成以文本形式表示的字符流</p>
<h4 id="17-2-1重载的-lt-lt-运算符"><a href="#17-2-1重载的-lt-lt-运算符" class="headerlink" title="17.2.1重载的&lt;&lt;运算符"></a>17.2.1重载的&lt;&lt;运算符</h4><p>&lt;&lt;默认是按位左移运算符，但是被ostream重新定义为了为了输出，<strong>&lt;&lt;</strong>叫做<strong>插入运算符，</strong>插入运算符的重载使之能够识别C++中所有的基本类型。</p>
<p><strong>拼接输出：cout&lt;&lt;“ABC“</strong>返回的是<strong>cout对象</strong>（的引用），因此这个表达式本身可以再使用&lt;&lt;运算符，这就实现了拼接的效果。可以通过cout&lt;&lt;“ABC”&lt;&lt;‘d’&lt;&lt;endl来不断拼接想要输出的内容。</p>
<h4 id="17-2-2其他ostream方法"><a href="#17-2-2其他ostream方法" class="headerlink" title="17.2.2其他ostream方法"></a>17.2.2其他ostream方法</h4><p>除了各种operator&lt;&lt;()函数外，ostream类还提供了put()和write()方法，前者用于显示字符，后者用于显示字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//打印字符a</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;b&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;c&#x27;</span>);<span class="comment">//put()方法返回ostream类，因此可以拼接</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">66</span>).<span class="built_in">put</span>(<span class="number">66.7</span>);<span class="comment">//都会转换为ASCII码为66的字符，即B</span></span><br></pre></td></tr></table></figure>
<ol>
<li>put方法用来输出一个字符</li>
<li>put方法返回ostream对象，因此可以拼接</li>
<li>数值类型（int,double)会转换成字符类型再打印</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * state1 = <span class="string">&quot;test1&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * state2 = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line">cout.<span class="built_in">write</span>(state1,<span class="built_in">strlen</span>(state1)).<span class="built_in">write</span>(state2,<span class="built_in">strlen</span>(state2));</span><br><span class="line">cout.<span class="built_in">write</span>(state1,<span class="number">10</span>);<span class="comment">//设定的打印字符数量大于字符串字符数，溢出打印，不仅打印了test1，还多打印了ABCD</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>cout.write()</strong>有两个参数，第一个表示要打印的内容，第二个表示要打印多少字符</li>
<li><strong>cout.write()</strong>返回值是<strong>ostream类型</strong>的对象，所以可以拼接</li>
<li><strong>write()方法检测到空字符也不会停止，因此如果要打印的字符比字符串长就会导致溢出</strong>（例子中虽然指定的是打印state1，但是由于溢出了4个字符，所以还打印 了state2中的前四个字符</li>
</ol>
<h4 id="17-2-3刷新输出缓冲区"><a href="#17-2-3刷新输出缓冲区" class="headerlink" title="17.2.3刷新输出缓冲区"></a>17.2.3刷新输出缓冲区</h4><p>通常缓冲区为512字节或它的整数倍，在屏幕输出的时候不必填满缓冲区也可以刷新，如将换行符发送到缓冲区后，将刷新缓冲区。<br>1.在即将输入的时候会刷新输出缓冲区<br>2.控制符endl也会刷新缓冲区<br>3.控制符flush<br>4.控制符也是函数，因此可以使用语句<strong>flush(cout)</strong>来刷新输出缓冲区</p>
<h4 id="17-2-4用cout进行格式化"><a href="#17-2-4用cout进行格式化" class="headerlink" title="17.2.4用cout进行格式化"></a>17.2.4用cout进行格式化</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="lsk404.github.io">Little_sk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://lsk404.github.io/0a85d83dfe8a/">https://lsk404.github.io/0a85d83dfe8a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/avator.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/611f7aaa17d8/" title="小白月赛 76"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">小白月赛 76</div></div><div class="info-2"><div class="info-item-1">牛客小白月赛76 https://ac.nowcoder.com/acm/contest/60393 F. Kevin的矩阵1.题意给出n个数字的数字序列组成一个矩阵，m表示矩阵初始的列数，这n个数从左至右从上至下排列在矩阵中。要求进行若干次操作，使得矩阵的某一列的值全部为k可以执行的操作有:1.将矩阵的列数加1或者减12.改变矩阵中某个数的值一共有t组数据，并且保证所有数据中的n的和小于2e5 2.思路不论数据怎样，每组样例中所进行的操作数都不多于2 次操作1.初始的列数m小于 ,那么可以花费至多 – m次 操作将列数变为 ，然后花费至多 + 1 次操作改变某一列上面的值来保证这一列的值全部为k。假设m为最糟糕的情况，即m = 1，那么总共最多需要 2  次操作。2.初始的列数m大于 那么直接将某一列中的所有不为k的数都变为k。最多花费  次操作表示即可符合要求，因为m  所以，所以总操作数永远小于 2 因此可以只对列数 [m – ,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/3b4839b3d1b7/" title="2023ICPC网络赛第一场"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-18</div><div class="info-item-2">2023ICPC网络赛第一场</div></div><div class="info-2"><div class="info-item-1">The 2023 ICPC Asia Regionals Online Contest (1)，不要选时光机，用签到送的金币就可以练习 G Spanning Tree题意起初树只有n个节点，没有边，按照如下操作进行n-1次，对于第i次操作，选择$a_i,b_i$ ,从$a_i$ 所在的块中随机选出一个节点$u_i$，从$b_i$ 所在的块中随机选出一个节点$v_i$， 连接$u_i,v_i$保证最终会形成一个树，求构造出的这个树和给出的标准的树T能够完全相同的期望（对 998244353取模） 保证第$i$次操作前,$a_i,b_i$ 不在同一个块。 定义一个节点v所在的块即v能到达的所有节点的集合（包括v本身） 请注意，所求的期望可能是0。 思路可以得出，最终期望一定是0或者 $\frac{1}{s}$ ： 每次连接两个块时，最多只有一种连接方式能够使得所连边的情况和最终的树匹配。而本次操作会使得操作前的期望$s_{i-1}$ 再乘上 $\frac{1}{sz_a*sz_b}$ ($sz_a,sz_b$表示a和b当前所在块的节点数量)。 ...</div></div></div></a><a class="pagination-related" href="/026c0040b952/" title="2023ICPC网络赛第二场"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="info-item-2">2023ICPC网络赛第二场</div></div><div class="info-2"><div class="info-item-1">The 2023 ICPC Asia Regionals Online Contest (2) (pintia.cn) K Super-knight题意有一个士兵，起初在n*n的棋盘的左下角，每次向右移动a格，向上移动b格，当越过地图边界时，则到地图的另一边（类似于没有边界墙的贪吃蛇），对这个士兵能到达的格子做标记，所有被标记的格子中，离左下角格子最近的距离是多少。（假设最近的格子为$(x, y)$，就输出$(x - 1)^2+(y - 1)^2$ ) （ $2 \le n \le 10^{18}, 1 \le a,b \le 200$) 思路可以得出，在经过n次移动后，一定回回到起始点，所以最终的路径一定是循环的。 但n太大，无法通过这样判断所有的被标记的点。 可以发现，在移动了若干次后，除非穿过地图边界，否则只会增加 与原点的距离。因此我们只需要考虑刚穿过地图边界的点...</div></div></div></a><a class="pagination-related" href="/c6413222be25/" title="2023年10月ZZUACM实验室招新赛题解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="info-item-2">2023年10月ZZUACM实验室招新赛题解</div></div><div class="info-2"><div class="info-item-1">注意事项请注意！：  题解仅代表个人看法，不代表最优解  每道题都会附上ac代码，但是仅作参考，要看懂后再了解代码。补题不要直接抄代码！禁止自欺欺人！  只提供题解，不提供题目信息 ac代码为C++版本，如果遇到不懂的语法请自行百度 ac代码中的循环经常用到了for(int i = 1;i&lt;=n;i++) ，这种在for的括号中int i的操作只有大于等于C++11标准才可以使用，编译错误时请检查自己编译使用的标准。  A.数位分解对于一个数x，   使用  x % 10 (% 是取余数) ，就可以得到他的最后一位 使用 x /= 10  (除以十并取整数)，就可以舍掉他的最后一位  使用while(x) 来进行循环 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123;	int x;	cin&gt;&gt;x;	while(x)&#123;		cout&lt;&lt; x % 10 &lt;&lt;&quot; &quot;;		x = x / 10;	&#125;	return...</div></div></div></a><a class="pagination-related" href="/17fe9a65a7dc/" title="AtCoder Beginner Contest 346"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-09</div><div class="info-item-2">AtCoder Beginner Contest 346</div></div><div class="info-2"><div class="info-item-1">AtCoder Beginner Contest 346 A - Adjacent Product题意给你一个数组$a1,a_2,…,a_n$ ，现在有$b_i = a_i * a{i+1}$ 输出$b1,b_2,…,b{n-1}$ 思路照着题意写就行 代码12345n = int(input())lst = [int(x) for x in input().split()]ans = []for i in range(len(lst)-1):    print(lst[i] * lst[i+1],end=&#x27; &#x27;) B - Piano题意有一个字符串，由无数个wbwbwwbwbwbw 重复得来，现在给出两个数W和B$(1\le W,B \le 100 )$ 问是否存在某个子串满足：包含$W$个w以及$B$ 个b 思路这个子串一定不会超过200位，所以我们重复wbwbwwbwbwbw 40次(长度$12*40 = 480$)就可以保证所有的子串都在其中，然后我们求所有长度为$W+B$...</div></div></div></a><a class="pagination-related" href="/1f41d16e4fe3/" title="Codeforces Round 897 (Div. 2)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-12</div><div class="info-item-2">Codeforces Round 897 (Div. 2)</div></div><div class="info-2"><div class="info-item-1">Dashboard - Codeforces Round 897 (Div. 2) - Codeforces A - green_gold_dog, array and permutation题意有一个长度为n的数组a，请你找出一个长度为n的排列b。 根据数组a和b来构造出数组c。$c[i] = a[i] - b[i]$ ，尽可能地使c数组中的 互不相同的数的数量。 思路好妙的思路！ 让最小的$a[i]$ 减去n,次小的减去$n-1$ ,这样每个$c[i]$ 都不一样。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N = 4e4 + 5;pair&lt;int,int&gt; a[N];pair&lt;int,int&gt; b[N];int...</div></div></div></a><a class="pagination-related" href="/1bf0beed8499/" title="Codeforces Round 929 (Div. 3)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-29</div><div class="info-item-2">Codeforces Round 929 (Div. 3)</div></div><div class="info-2"><div class="info-item-1">题目链接 A. Turtle Puzzle: Rearrange and Negate题意有一个长度为n的数组a，进行两步操作，第一步重新排列数组内元素的顺序， 第二部选择一个连续区间，将其中的元素取反。问进行完这两步操作后，数组元素的值的总和 最大是多少。 思路 很显然，把所有的负数放到一起，然后把这段区间取反即可。答案就是所有数的绝对值的和。 代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define int long long#define rep(i,l,r) for(int i = l;i&lt;=r;i++)#define per(i,r,l) for(int i = r;i&gt;=l;i--)const int INF = 0x3f3f3f3f3f3f3f3f;typedef...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Little_sk</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lsk404/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">加我友链！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E6%9D%82%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">0. 杂类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cin-cout"><span class="toc-number">1.1.</span> <span class="toc-text">cin&#x2F;cout</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%80%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">提速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-lt-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">&lt;&lt;的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0%E5%BA%93cctype"><span class="toc-number">1.1.3.</span> <span class="toc-text">字符函数库cctype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAIO"><span class="toc-number">1.1.4.</span> <span class="toc-text">文件输入输出IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">顺序点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%9C%B0%E4%BD%BF%E7%94%A8const"><span class="toc-number">1.3.2.</span> <span class="toc-text">尽可能地使用const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8D%87%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">提升可读性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E4%BD%9C%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82"><span class="toc-number">1.4.1.</span> <span class="toc-text">字符串&#x2F;字符指针作函数形参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">4.复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1字符串字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1%E5%85%B6%E4%BB%96%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">4.1.1其他形式的字符串字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">4.1.2原始字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E6%8C%87%E9%92%88%E5%92%8C%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2指针和自由存储空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%E8%87%AA%E7%94%B1%E5%82%A8%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">4.2.1自由储存空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">4.2.2动态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">4.2.3指针和const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E6%95%B0%E7%BB%84%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81vector-array"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3数组的替代品vector&#x2F;array</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">7.函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E5%87%BD%E6%95%B0%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.1.</span> <span class="toc-text">7.1函数和二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.6.2.</span> <span class="toc-text">7.2函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">7.2.1获取函数的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2%E5%A3%B0%E6%98%8E%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">7.2.2声明指向函数的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">7.2.3使用函数指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">7.2.4深入探讨函数指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD"><span class="toc-number">1.7.</span> <span class="toc-text">8.函数探幽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">8.1内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">8.2引用变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1%E5%B0%86%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">8.2.1将引用作为函数参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">8.3默认参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">8.3.1声明和定义带默认参数的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2%E8%B0%83%E7%94%A8%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">8.3.2调用带默认参数的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.4.</span> <span class="toc-text">8.4函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">8.4.1注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2%E9%87%8D%E8%BD%BD%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">8.4.2重载引用参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">8.4.3何时使用函数模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.7.5.</span> <span class="toc-text">8.5函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">8.5.1声明和定义函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">8.5.2重载的模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">8.5.2模板的局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3%E6%98%BE%E5%BC%8F%E5%85%B7%E4%BD%93%E5%8C%96"><span class="toc-number">1.7.5.4.</span> <span class="toc-text">8.5.3显式具体化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-4%E5%85%B7%E4%BD%93%E5%8C%96%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.7.5.5.</span> <span class="toc-text">8.5.4具体化和实例化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">1.8.</span> <span class="toc-text">9.内存模型和名称空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E5%8D%95%E7%8B%AC%E7%BC%96%E8%AF%91"><span class="toc-number">1.8.1.</span> <span class="toc-text">9.1单独编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%93%BE%E6%8E%A5%E6%80%A7"><span class="toc-number">1.8.2.</span> <span class="toc-text">9.2存储持续性，作用域和链接性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">9.2.1作用域和链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">9.2.2自动存储持续性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3%E9%9D%99%E6%80%81%E6%8C%81%E7%BB%AD%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">9.2.3静态持续变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-4%E9%9D%99%E6%80%81%E6%8C%81%E7%BB%AD%E6%80%A7%EF%BC%8C%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5%E6%80%A7"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">9.2.4静态持续性，外部链接性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-5%E9%9D%99%E6%80%81%E6%8C%81%E7%BB%AD%E6%80%A7%EF%BC%8C%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5%E6%80%A7"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">9.2.5静态持续性，内部链接性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-6%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%80%A7%EF%BC%8C%E6%97%A0%E9%93%BE%E6%8E%A5%E6%80%A7"><span class="toc-number">1.8.2.6.</span> <span class="toc-text">9.2.6静态存储持续性，无链接性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-7%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%92%8C%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.8.2.7.</span> <span class="toc-text">9.2.7说明符和限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-8%E5%87%BD%E6%95%B0%E5%92%8C%E9%93%BE%E6%8E%A5%E6%80%A7"><span class="toc-number">1.8.2.8.</span> <span class="toc-text">9.2.8函数和链接性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-9%E8%AF%AD%E8%A8%80%E9%93%BE%E6%8E%A5%E6%80%A7"><span class="toc-number">1.8.2.9.</span> <span class="toc-text">9.2.9语言链接性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">1.8.3.</span> <span class="toc-text">9.3名称空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1using%E5%A3%B0%E6%98%8E%E5%92%8Cusing%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">9.3.1using声明和using编译指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-number">1.9.</span> <span class="toc-text">10.对象和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E6%8A%BD%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-number">1.9.1.</span> <span class="toc-text">10.1抽象和类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">10.1.1访问控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">10.1.2类成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.2.</span> <span class="toc-text">10.2类的构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">10.2.1构造函数的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">10.2.2析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-3const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">10.2.3const成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-4%E5%85%B6%E4%BB%96"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">10.2.4其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3this%E6%8C%87%E9%92%88"><span class="toc-number">1.9.3.</span> <span class="toc-text">10.3this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.4.</span> <span class="toc-text">10.4对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.9.5.</span> <span class="toc-text">10.5类作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-1%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%B8%B8%E9%87%8F"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">10.5.1作用域为类的常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-2%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E6%9E%9A%E4%B8%BE%EF%BC%88C-11%EF%BC%89"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">10.5.2作用域内枚举（C++11）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BD%BF%E7%94%A8%E7%B1%BB"><span class="toc-number">1.10.</span> <span class="toc-text">11.使用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.10.1.</span> <span class="toc-text">11.1运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">11.1.1运算符重载的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">11.1.2注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2%E5%8F%8B%E5%85%83"><span class="toc-number">1.10.2.</span> <span class="toc-text">11.2友元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">11.2.1为什么要使用友元函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.10.3.</span> <span class="toc-text">11.3类的自动转换和强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">11.3.1赋值运算符的自动转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">11.3.2强制类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-3%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">11.3.3转换函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.11.</span> <span class="toc-text">12.类和动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E7%B1%BB"><span class="toc-number">1.11.1.</span> <span class="toc-text">12.1动态内存和类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-1%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">12.1.1静态成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-2%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">12.1.2特殊成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-3%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">12.2.3复制构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-4%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.11.1.4.</span> <span class="toc-text">12.2.4赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-5%E5%85%B3%E4%BA%8E%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84const%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.1.5.</span> <span class="toc-text">12.2.5关于临时对象的const问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-6%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%B1%BB%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.11.1.6.</span> <span class="toc-text">12.2.6一个关于内存分配的类实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3%E8%BF%94%E5%9B%9Econst%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.2.</span> <span class="toc-text">12.3返回const对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91const%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">12.3.1返回指向const对象的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E9%9D%9Econst%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">12.3.2返回指向非const的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-3%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">12.3.3返回对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-3%E8%BF%94%E5%9B%9Econst%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.2.4.</span> <span class="toc-text">12.3.3返回const对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.11.3.</span> <span class="toc-text">12.4使用指向对象的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1%E4%BD%BF%E7%94%A8new%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">12.4.1使用new为对象分配内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-2%E5%AE%9A%E4%BD%8Dnew%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">12.4.2定位new运算符和对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">1.12.</span> <span class="toc-text">13.类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1%E5%9F%BA%E7%B1%BB%E4%B8%8E%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">1.12.1.</span> <span class="toc-text">13.1基类与派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1%E6%B4%BE%E7%94%9F%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">13.1.1派生一个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">13.1.2访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-3%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">13.1.3派生类和基类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2%E7%BB%A7%E6%89%BF-is-a%E5%85%B3%E7%B3%BB"><span class="toc-number">1.12.2.</span> <span class="toc-text">13.2继承:is-a关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">1.12.3.</span> <span class="toc-text">13.3多态公有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-1%E4%BD%BF%E7%94%A8%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">13.3.1使用虚方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-2%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">13.3.2一些注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-3%E8%99%9A%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8%EF%BC%9A%E5%9F%BA%E7%B1%BB%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">1.12.3.3.</span> <span class="toc-text">13.3.3虚方法应用：基类指针数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">1.12.4.</span> <span class="toc-text">13.4静态联编和动态联编</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-1%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">13.4.1指针和引用的类型的兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-2%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.12.4.2.</span> <span class="toc-text">13.4.2虚函数的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-3%E6%9C%89%E5%85%B3%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.12.4.3.</span> <span class="toc-text">13.4.3有关虚函数的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9Aprotected"><span class="toc-number">1.12.5.</span> <span class="toc-text">13.5访问控制：protected</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.12.6.</span> <span class="toc-text">13.6抽象基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.12.7.</span> <span class="toc-text">13.7继承和动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-1-%E6%83%85%E5%86%B5%E4%B8%80-%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8D%E4%BD%BF%E7%94%A8new"><span class="toc-number">1.12.7.1.</span> <span class="toc-text">13.7.1 情况一:派生类不使用new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-2-%E6%83%85%E5%86%B5%E4%BA%8C-%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%BD%BF%E7%94%A8new"><span class="toc-number">1.12.7.2.</span> <span class="toc-text">13.7.2 情况二:派生类使用new</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.12.8.</span> <span class="toc-text">13.8类设计回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-1%E8%A6%81%E9%81%B5%E5%BE%AAis-a%E5%85%B3%E7%B3%BB"><span class="toc-number">1.12.8.1.</span> <span class="toc-text">13.8.1要遵循is-a关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-2%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="toc-number">1.12.8.2.</span> <span class="toc-text">13.8.2什么不能被继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-3%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.12.8.3.</span> <span class="toc-text">13.8.3赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-4%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98"><span class="toc-number">1.12.8.4.</span> <span class="toc-text">13.8.4私有成员与保护成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-5%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">1.12.8.5.</span> <span class="toc-text">13.8.5虚方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-C-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8"><span class="toc-number">1.13.</span> <span class="toc-text">14.C++中的代码重用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1%E5%8C%85%E5%90%AB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB"><span class="toc-number">1.13.1.</span> <span class="toc-text">14.1包含对象成员的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">1.13.2.</span> <span class="toc-text">14.2私有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">14.2.1初始化基类组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-2%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">14.2.2访问基类的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-3%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.13.2.3.</span> <span class="toc-text">14.2.3访问基类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-4%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.2.4.</span> <span class="toc-text">14.2.4访问基类友元函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="toc-number">1.13.3.</span> <span class="toc-text">14.3保护继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.13.4.</span> <span class="toc-text">14.4多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-1%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.13.4.1.</span> <span class="toc-text">14.4.1虚基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.13.4.2.</span> <span class="toc-text">14.4.2使用哪个成员函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-3%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E8%99%9A%E5%9F%BA%E7%B1%BB%E5%92%8C%E9%9D%9E%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.13.4.3.</span> <span class="toc-text">14.4.3混合使用虚基类和非虚基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-4%E8%99%9A%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%94%AF%E9%85%8D"><span class="toc-number">1.13.4.4.</span> <span class="toc-text">14.4.4虚基类和支配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.13.5.</span> <span class="toc-text">14.4类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-1%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.13.5.1.</span> <span class="toc-text">14.4.1定义类模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%85%B7%E4%BD%93%E5%8C%96"><span class="toc-number">1.13.5.2.</span> <span class="toc-text">14.4.2模板的具体化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-3%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.13.5.3.</span> <span class="toc-text">14.4.3成员模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-4%E5%B0%86%E6%A8%A1%E6%9D%BF%E7%94%A8%E4%BD%9C%E5%8F%A6%E4%B8%80%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">1.13.5.4.</span> <span class="toc-text">14.4.4将模板用作另一模板的模板参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-5%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83"><span class="toc-number">1.13.5.5.</span> <span class="toc-text">14.4.5模板类和友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-6%E6%A8%A1%E6%9D%BF%E5%88%AB%E5%90%8D"><span class="toc-number">1.13.5.6.</span> <span class="toc-text">14.4.6模板别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number">1.14.</span> <span class="toc-text">15.友元、异常、其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">1.15.</span> <span class="toc-text">16.string类和标准模板库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">1.16.</span> <span class="toc-text">17.输入、输出和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A6%82%E8%BF%B0"><span class="toc-number">1.16.1.</span> <span class="toc-text">17.1C++输入输出概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1-1%E6%B5%81%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.16.1.1.</span> <span class="toc-text">17.1.1流和缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1-2%E6%B5%81%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8Ciostream%E6%96%87%E4%BB%B6"><span class="toc-number">1.16.1.2.</span> <span class="toc-text">17.1.2流、缓冲区和iostream文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1-3%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.16.1.3.</span> <span class="toc-text">17.1.3重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2%E4%BD%BF%E7%94%A8cout%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%87%BA"><span class="toc-number">1.16.2.</span> <span class="toc-text">17.2使用cout来进行输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-1%E9%87%8D%E8%BD%BD%E7%9A%84-lt-lt-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.16.2.1.</span> <span class="toc-text">17.2.1重载的&lt;&lt;运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-2%E5%85%B6%E4%BB%96ostream%E6%96%B9%E6%B3%95"><span class="toc-number">1.16.2.2.</span> <span class="toc-text">17.2.2其他ostream方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-3%E5%88%B7%E6%96%B0%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.16.2.3.</span> <span class="toc-text">17.2.3刷新输出缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-4%E7%94%A8cout%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.16.2.4.</span> <span class="toc-text">17.2.4用cout进行格式化</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/555324d54baf/" title="期末回顾">期末回顾</a><time datetime="2025-06-06T04:00:00.000Z" title="Created 2025-06-06 12:00:00">2025-06-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/887930e5b441/" title="强化学习数学原理笔记">强化学习数学原理笔记</a><time datetime="2025-04-16T09:53:00.000Z" title="Created 2025-04-16 17:53:00">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/d49b5a7aa584/" title="2025蓝桥杯PythonA组省赛题解">2025蓝桥杯PythonA组省赛题解</a><time datetime="2025-04-12T12:28:00.000Z" title="Created 2025-04-12 20:28:00">2025-04-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/0ed69ce9ed7c/" title="电子扫盲">电子扫盲</a><time datetime="2025-03-09T04:00:00.000Z" title="Created 2025-03-09 12:00:00">2025-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/27d697c28fe4/" title="十六届蓝桥杯模拟赛3题解">十六届蓝桥杯模拟赛3题解</a><time datetime="2025-02-12T04:00:00.000Z" title="Created 2025-02-12 12:00:00">2025-02-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(img/bg3.png);"><div id="footer-wrap"><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20250258" target="_blank">萌ICP备20250258号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'jY5tnMLwMUhZNOv61yXvepci-gzGzoHsz',
      appKey: 'gZbn0Lr7joLZ83iUlbqPfk4J',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>